<!doctype html>
<html lang="en">

<script>try{if(typeof window.$!=='function'){window.$=(id)=>document.getElementById(id);}}catch(e){}</script>

<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>StagSynth ‚Äî FINAL FX Fix</title>
<link rel="icon" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="30" fill="none" stroke="%23ff2727" stroke-width="6"/><text x="32" y="42" text-anchor="middle" font-size="32" fill="%23ff2727">ü¶â</text></svg>' />
<style>
/* ===== Theme ===== */
:root{
  --bg1:#2b0000; --bg2:#060004;
  --panel:#0e0a0a; --panel2:#1a1212;
  --border:#3a2323; --fg:#f7e9e9; --dim:#c99a9a;
  --accent:#ff2727; --green:#25ff85; --warn:#ff844a;
  --chevron1:#0b0b0b; --chevron2:#1c1c1c;
  --tb: 60px;
}
*{box-sizing:border-box}
html,body{margin:0;height:100%;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}

/* Mobile feel */
body, .app, .keypad-wrap, .keypad, .key {-webkit-user-select:none; user-select:none; -webkit-touch-callout:none}
.key { touch-action:none; }
* { -webkit-tap-highlight-color: transparent; }
input, select, textarea { -webkit-user-select:text; user-select:text }

/* ===== Topbar ===== */
.topbar{
  display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap;
  padding:10px 12px;position:sticky;top:0;z-index:50;background:
  radial-gradient(1200px 220px at 50% -60px, #5d0a0a55, transparent 70%),
  linear-gradient(180deg,rgba(43,0,0,.95),rgba(6,0,4,.65) 85%,transparent);
  border-bottom:1px solid rgba(255,255,255,.06)
}
h1{margin:0;font-weight:900;font-size:18px;letter-spacing:.08em}
.tb-row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.synth-btn{
  background:
    linear-gradient(180deg,rgba(255,255,255,.04),transparent),
    linear-gradient(180deg,var(--panel),var(--panel2));
  border:1px solid var(--border);color:var(--fg);
  padding:8px 12px;border-radius:999px;cursor:pointer;
  box-shadow:0 1px 0 rgba(255,255,255,.06) inset,0 8px 20px rgba(0,0,0,.25);
  transition:box-shadow .15s ease, transform .05s ease, opacity .15s ease;
  font-size:14px; line-height:1; min-height:34px;
}
.synth-btn:hover{box-shadow:0 1px 0 rgba(255,255,255,.06) inset,0 8px 20px rgba(0,0,0,.25),0 0 0 3px rgba(255,39,39,.12)}
.synth-btn:active{transform:translateY(1px)}
.synth-btn[disabled]{opacity:.45;cursor:not-allowed}
.pill{padding:6px 10px;border-radius:999px;border:1px solid var(--border);background:linear-gradient(180deg,var(--panel),var(--panel2));display:inline-flex;align-items:center}
.pill.dim{opacity:.6}
.badge{font-size:12px;opacity:.9;margin-left:8px}
.warn{color:var(--warn)}
@media (max-width: 430px){
  h1{font-size:14px}
  .tb-row{gap:6px}
  .synth-btn{padding:6px 9px;font-size:12px;min-height:30px}
  .pill{padding:5px 8px}
}
#recDot{display:inline-block;width:10px;height:10px;border-radius:50%;background:#ff2727;margin-right:6px;box-shadow:0 0 8px rgba(255,39,39,.6)}
@keyframes pulse{0%{transform:scale(1)}50%{transform:scale(1.2)}100%{transform:scale(1)}}
.pill.recording{background:linear-gradient(180deg,#3b0a0a,#1a0b0b);border-color:#6b1f1f;box-shadow:0 0 0 2px rgba(255,39,39,.18) inset,0 0 18px rgba(255,39,39,.22);opacity:1}
.pill.recording #recDot{animation:pulse 0.9s infinite}

/* App & keypad */
.app{max-width:1000px;margin:0 auto;padding:12px 12px 96px}
.keypad-wrap{border:1px solid var(--border);border-radius:14px;padding:10px;background:
  repeating-linear-gradient(135deg,var(--chevron1) 0 14px,var(--chevron2) 14px 28px),
  linear-gradient(180deg,var(--panel),#0a0507);max-height:72vh;overflow:auto;box-shadow:inset 0 0 0 1px rgba(255,255,255,.03)}
.keypad{display:grid;grid-template-columns:repeat(4,1fr);grid-auto-rows:minmax(56px,1fr);gap:8px;user-select:none}
.key{background:
  radial-gradient(100px 60px at 30% 30%,#311414,#140708),
  linear-gradient(180deg,#0f090a,#0c0507);
  border:1px solid var(--border);border-radius:12px;min-height:56px;display:flex;align-items:center;justify-content:center;box-shadow:inset 0 1px 0 rgba(255,255,255,.04)}
.key.on{outline:2px solid var(--accent);box-shadow:0 0 18px rgba(255,39,39,.35),inset 0 1px 0 rgba(255,255,255,.04)}
.controls{display:flex;gap:10px;align-items:center;justify-content:space-between;margin-bottom:10px;flex-wrap:wrap}
.readout{width:40px;height:40px;display:grid;place-items:center;border:1px solid var(--border);border-radius:10px;background:#0b0a0b;box-shadow:inset 0 1px 0 rgba(255,255,255,.04)}
.wheel{width:64px;height:64px;border-radius:999px;border:2px solid var(--border);background:radial-gradient(circle at 30% 30%, #3a1212, #0b0a0b);position:relative;box-shadow:inset 0 0 10px #0006;touch-action:none;cursor:grab}
.wheel .center{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:2px;height:84%;background:#3a2323;opacity:.85}
.wheel .marker{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:10px;height:22px;border-radius:4px;background:#ffe9e9;opacity:.95;box-shadow:0 0 10px rgba(255,255,255,.25)}
.owl{width:42px;height:42px;display:grid;place-items:center;border-color:#14532d}
.owl.micro-on{outline:2px solid var(--green);box-shadow:0 0 14px #25ff8570}

/* Panels */
.synth-panel{
  position:fixed; left:0; right:0;
  top:var(--tb); height:calc(100vh - var(--tb));
  transform:translateY(-120%); transition:transform .25s ease;
  background:#0a0507ea;color:var(--fg);z-index:45;padding:12px;backdrop-filter:blur(8px);
  overflow:auto; overscroll-behavior:contain;
  border-bottom:1px solid var(--border); border-top:1px solid rgba(255,255,255,.06);
}
.synth-panel.open{transform:translateY(0)}
.section{display:grid;grid-template-columns:170px 1fr;gap:8px 12px;padding:10px 0;border-top:1px solid var(--border)}
.section h4{grid-column:1 / -1;margin:.25rem 0;opacity:.95;letter-spacing:.04em}
@media (max-width:700px){.section{grid-template-columns:1fr}}
@media (max-width:430px){
  .synth-panel{padding:10px}
  .section{gap:6px 10px; padding:8px 0}
  .section h4{font-size:13px}
  .synth-panel label{font-size:12px}
  .synth-panel input[type="range"]{touch-action:pan-y}
  .synth-panel select, .synth-panel input[type="number"], .synth-panel input[type="text"]{font-size:12px}
}
.footer{position:fixed;bottom:0;left:0;right:0;padding:8px 12px;font-size:12px;opacity:.85;background:linear-gradient(0deg,#2b0000,transparent)}
.midi-learn-on{outline:2px solid var(--accent)}
.kv{display:flex;gap:6px;align-items:center}
.kv small{opacity:.8}
.synth-btn.ll-on{outline:2px solid var(--accent); box-shadow:0 0 10px var(--accent);} 
#llToggleOverlay{position:relative; z-index:12; pointer-events:auto}
</style>

<style>
/* seq media */
@media (max-width: 480px){
  #seqStepsStrip{position:relative; margin:10px auto 8px auto; width:min(860px,98vw); display:grid; grid-template-columns: repeat(32, 1fr); gap:5px; z-index:1;}
  #seqStepsStrip .led{height:12px; border-radius:4px; background:#1e1e1e; box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);}
}
</style>


<style>
/* seq final media */
@media (max-width: 900px){
  #seqStepsStrip{ width: 96vw; gap:4px; }
}
@media (max-width: 540px){
  #seqStepsStrip{ width: 96vw; gap:3px; margin:8px auto 10px auto; }
  #seqStepsStrip .led{ height:14px; border-radius:5px; }
}
</style>

<style>@media (max-width: 540px){#seqStepsStrip{display:grid;grid-template-columns:repeat(var(--seq-cols,12),1fr);grid-auto-rows:34px;gap:8px;width:96vw;margin:10px auto 14px auto;touch-action:manipulation}#seqStepsStrip .led{min-height:34px;border-radius:10px;box-shadow:inset 0 0 0 1px rgba(255,255,255,.08)}}</style>
<style>
  #customPanel .pill{ padding:6px 10px; border:1px solid #444; border-radius:10px; background:#202020; cursor:pointer }
  #customPanel .pill:hover{ background:#272727 }
  #wt_frames .thumb{ width:56px; height:40px; border:1px solid #333; border-radius:6px; background:#151515; position:relative; flex:0 0 auto }
  #wt_frames .thumb canvas{ width:100%; height:100% }
  #wt_frames .thumb.active{ outline:2px solid #88f }
</style>

</head>
<body>
<style>
  </style>

<style>
  #seqStepsStrip{position:relative; margin:10px auto 8px auto; width:min(860px,98vw); display:grid; grid-template-columns: repeat(32, 1fr); gap:5px; z-index:1;}
  #seqStepsStrip .led{height:12px; border-radius:4px; background:#1e1e1e; box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);}
  #seqStepsStrip .led.has{background:linear-gradient(#444,#555)}
  #seqStepsStrip .led.active{background:#ffd34d; box-shadow:0 0 10px #ffd34d, inset 0 0 0 1px rgba(0,0,0,.5)}
  #seqStepsStrip .led.play{background:#ff7a00; box-shadow:0 0 10px #ff7a00, inset 0 0 0 1px rgba(0,0,0,.6)}
  /* keypad note highlights */
  .key.seq-has{box-shadow:inset 0 0 0 2px rgba(255,211,77,.8)}
  .key.seq-play{background:rgba(255,122,0,.25)}
</style>
<div id="seqStepsStrip" style="display:none"></div><header class="topbar" id="topbar">
  <h1>StagSynth</h1>
  <div class="tb-row">
    <button id="startBtn" class="synth-btn" title="Start or Resume Audio">Start Audio</button>
    <button id="resetBtn" class="synth-btn" title="Reset Audio Engine (close & reinit)">Reset Audio</button>
    <button id="midiBtn" class="synth-btn" title="Connect MIDI (USB/BLE)">ùÑû MIDI</button>
    <button id="midiLearnBtn" class="synth-btn" title="MIDI CC Learn" disabled>MIDI Map</button>
    <button id="synthToggle" class="synth-btn" aria-expanded="false" aria-controls="synthPanel">Synth</button>
    <button id="granularToggle" class="synth-btn" aria-expanded="false" aria-controls="granularPanel">Granular</button>
    <button id="samplerToggle" class="synth-btn" aria-expanded="false" aria-controls="samplerPanel">Sampler</button>
    <button id="vocoderToggle" class="synth-btn" aria-expanded="false" aria-controls="vocoderPanel">Vocoder</button>
        <button id="customToggle" class="synth-btn" aria-expanded="false" aria-controls="customPanel">Custom/Wavetable</button>
<div style="display:flex;gap:6px;align-items:center">
      <button id="recBtn" class="pill dim" title="Record short take (whole output)">
        <span id="recDot"></span> <span id="recLabel">Record</span>
      </button>
      <span id="recTimer" class="badge" aria-live="polite"></span>
    </div>
  </div>
</header>


<!-- Synth panel -->
<div id="synthPanel" class="synth-panel" role="region" aria-label="Synth controls">
  <div class="section">
    <h4>Oscillators</h4>
    <label>Shape <select id="shape" data-midicc><optgroup label="Custom/Wavetables" data-custom="1"></optgroup><option>sawtooth</option><option>square</option><option>triangle</option><option>sine</option><option>noise</option></select></label>
    <label>Sub Shape <select id="subShape" data-midicc><optgroup label="Custom/Wavetables" data-custom="1"></optgroup><option>off</option><option>sine</option><option>square</option><option>triangle</option><option>saw</option><option>noise</option></select></label>
    <label>Detune (cents) <input type="range" id="detune" data-midicc min="-50" max="50" step="1" value="0"/></label>
    <label>Sub Detune (cents) <input type="range" id="subDetune" data-midicc min="-50" max="50" step="1" value="0"/></label>
    <label>Sub Level <input type="range" id="subLevel" data-midicc min="0" max="1" step="0.01" value="0.8"/></label>
    <label>Sub Octave <select id="subOctave" data-midicc><option value="1" selected>1x</option><option value="0.5">¬Ωx</option></select></label>
    <label>Noise Color <select id="noiseColor" data-midicc><option>white</option><option>pink</option></select></label>
  </div>

  <div class="section">
    <h4>Filter</h4>
    <label>Mode <select id="mode" data-midicc><option>lp</option><option>bp</option><option>hp</option></select></label>
    <label>Cutoff <input type="range" id="cutoff" data-midicc min="60" max="12000" step="1" value="1600"/></label>
    <label>Resonance <input type="range" id="resonance" data-midicc min="0" max="1" step="0.01" value="0.2"/></label>
  </div>

  <!-- ===== FULL FX SUITE (all neutral on load) ===== -->
  <div class="section" id="fxSuite">
    
<div class="section" id="seqControlsInline" style="display:none">
  <h4>Sequencer</h4>
  <label style="grid-column:1/span 1">BPM <input type="range" id="seq_bpm" min="40" max="220" step="1" value="120"></label>
  <label style="grid-column:2/span 1">Steps <input type="range" id="seq_steps" min="1" max="32" step="1" value="16"></label>
  <label style="grid-column:1/span 1">Gate (%) <input type="range" id="seq_gate" min="5" max="100" step="1" value="60"></label>
  <label style="grid-column:2/span 1">Swing (%) <input type="range" id="seq_swing" min="0" max="60" step="1" value="0"></label>
  <label style="grid-column:1/span 1">Division
    <select id="seq_div"><option value="4">1/4</option><option value="8">1/8</option><option value="16" selected>1/16</option><option value="32">1/32</option></select>
  </label>
  <label style="grid-column:2/span 1">Transpose <input type="range" id="seq_trans" min="-24" max="24" step="1" value="0"></label>
  <label style="grid-column:1/span 2">Velocity <input type="range" id="seq_vel" min="0.1" max="1" step="0.01" value="0.9"></label>
  <div style="grid-column:1/-1;display:flex;gap:8px;flex-wrap:wrap"><button id="seq_clear" class="synth-btn" type="button">Clear</button></div>
</div>
<h4>FX Suite</h4>

    <!-- Reverb (neutral = MIX 0) -->
    <label>Reverb Room Size <input type="range" id="fx_rev_room" data-midicc min="0.1" max="1.0" step="0.01" value="0.6"/></label>
    <label>Reverb Decay (s) <input type="range" id="fx_rev_decay" data-midicc min="0.2" max="12" step="0.1" value="3.0"/></label>
    <label>Reverb Pre-delay (ms) <input type="range" id="fx_rev_predelay" data-midicc min="0" max="200" step="1" value="20"/></label>
    <label>Reverb Damping (Hz) <input type="range" id="fx_rev_damp" data-midicc min="1000" max="20000" step="10" value="6000"/></label>
    <label>Reverb Mix <input type="range" id="fx_rev_mix" data-midicc min="0" max="1" step="0.01" value="0.0"/></label>

    <!-- Chorus (neutral = MIX 0) -->
    <label>Chorus Rate (Hz) <input type="range" id="fx_ch_rate" data-midicc min="0.05" max="8" step="0.01" value="1.0"/></label>
    <label>Chorus Depth (ms) <input type="range" id="fx_ch_depth" data-midicc min="0" max="20" step="0.1" value="6"/></label>
    <label>Chorus Voices <input type="number" id="fx_ch_voices" min="1" max="4" step="1" value="2"/></label>
    <label>Stereo Width <input type="range" id="fx_ch_width" data-midicc min="0" max="1" step="0.01" value="0.8"/></label>
    <label>Chorus Mix <input type="range" id="fx_ch_mix" data-midicc min="0" max="1" step="0.01" value="0.0"/></label>

    <!-- Distortion (neutral = MIX 0, Drive 0, Tone 20kHz) -->
    <label>Dist Type
      <select id="fx_dist_type" data-midicc>
        <option value="soft" selected>Soft</option>
        <option value="tanh">Tanh</option>
        <option value="hard">Hard Clip</option>
      </select>
    </label>
    <label>Dist Drive <input type="range" id="fx_dist_drive" data-midicc min="0" max="1" step="0.01" value="0.0"/></label>
    <label>Dist Tone (Hz) <input type="range" id="fx_dist_tone" data-midicc min="1000" max="20000" step="10" value="20000"/></label>
    <label>Dist Mix <input type="range" id="fx_dist_mix" data-midicc min="0" max="1" step="0.01" value="0.0"/></label>

    <!-- Compressor (neutral = ratio 1, makeup 0, threshold 0) -->
    <label>Comp Threshold (dB) <input type="range" id="fx_comp_thr" data-midicc min="-60" max="0" step="1" value="0"/></label>
    <label>Comp Ratio <input type="range" id="fx_comp_ratio" data-midicc min="1" max="20" step="0.1" value="1"/></label>
    <label>Comp Attack (ms) <input type="range" id="fx_comp_att" data-midicc min="0.1" max="200" step="0.1" value="5"/></label>
    <label>Comp Release (ms) <input type="range" id="fx_comp_rel" data-midicc min="10" max="1000" step="1" value="200"/></label>
    <label>Makeup Gain <input type="range" id="fx_comp_makeup" data-midicc min="0" max="12" step="0.1" value="0"/></label>

    <!-- Bitcrusher (neutral = MIX 0) -->
    <label>Bit Depth <input type="range" id="fx_bc_bits" data-midicc min="1" max="24" step="1" value="24"/></label>
    <label>Downsample (Hz) <input type="range" id="fx_bc_rate" data-midicc min="100" max="48000" step="50" value="48000"/></label>
    <label>Bitcrusher Mix <input type="range" id="fx_bc_mix" data-midicc min="0" max="1" step="0.01" value="0.0"/></label>

    <!-- Ring Mod (neutral = MIX 0 and Depth 0) -->
    <label>Ring Carrier Freq (Hz) <input type="range" id="fx_rm_freq" data-midicc min="0.1" max="20000" step="0.1" value="30"/></label>
    <label>Ring Carrier Wave
      <select id="fx_rm_wave" data-midicc>
        <option>sine</option><option>triangle</option><option>square</option><option>sawtooth</option>
      </select>
    </label>
    <label>Ring Depth <input type="range" id="fx_rm_depth" data-midicc min="0" max="1.5" step="0.01" value="0.0"/></label>
    <label>Ring Mix <input type="range" id="fx_rm_mix" data-midicc min="0" max="1" step="0.01" value="0.0"/></label>

    <!-- Original color bus -->
    <label>Drive (Color) <input type="range" id="drive" data-midicc min="0" max="1" step="0.01" value="0.0"/></label>
    <label>Color Mix <input type="range" id="mix" data-midicc min="0" max="1" step="0.01" value="0.0"/></label>
  </div>

  <div class="section">
    <h4>Presets</h4>
    <label>Preset <select id="presetSelect"></select></label>
    <label>Name <input id="presetName" type="text" placeholder="New preset name"/></label>
    <div style="grid-column:1 / -1; display:flex; gap:8px; flex-wrap:wrap; margin-top:6px">
      <button id="savePresetBtn" class="synth-btn">Save</button>
      <button id="loadPresetBtn" class="synth-btn">Load</button>
      <button id="deletePresetBtn" class="synth-btn">Delete</button>
      <button id="exportPresetsBtn" class="synth-btn">Export</button>
      <button id="importPresetsBtn" class="synth-btn">Import</button>
      <input id="importPresetsFile" type="file" accept=".json,application/json" style="display:none"/>
      <button id="shareLinkBtn" class="synth-btn">Copy Share Link</button>
      <span id="presetMsg" class="badge"></span>
    </div>
  </div>
</div>
<!-- Granular panel -->
<div id="granularPanel" class="synth-panel" role="region" aria-label="Granular controls">
  <div class="section">
    <h4>Recordings</h4>
    <div style="grid-column:1/-1;display:flex;gap:8px;flex-wrap:wrap;align-items:center">
      <button id="g_startRec" class="synth-btn">Start Rec</button>
      <button id="g_stopRec" class="synth-btn" disabled>Stop Rec</button>
      <button id="g_saveTake" class="synth-btn" disabled>Save Take</button>
      <button id="g_importFile" class="synth-btn">Import File</button>
      <input id="g_file" type="file" accept="audio/*" style="display:none">
      <button id="g_exportTake" class="synth-btn" disabled>Export Take</button>
    </div>
    <label>Take <select id="g_takeList"></select></label>
    <div style="grid-column:1/-1;display:flex;gap:8px;flex-wrap:wrap">
      <button id="g_deleteTake" class="synth-btn" disabled>Delete</button>
      <span id="g_status" class="badge"></span>
    </div>
  </div>
  <div class="section">
    <h4>Grains</h4>
    <label>Position (%) <input type="range" id="g_pos" data-midicc min="0" max="100" step="0.1" value="0"/></label>
    <label>Scan Rate (pct/s) <input type="range" id="g_scan" data-midicc min="-100" max="100" step="1" value="10"/></label>
    <label>Grain Size (ms) <input type="range" id="g_size" data-midicc min="10" max="500" step="1" value="120"/></label>
    <label>Overlap (ms) <input type="range" id="g_overlap" data-midicc min="0" max="300" step="1" value="60"/></label>
    <label>Density (gr/s) <input type="range" id="g_density" data-midicc min="1" max="80" step="1" value="30"/></label>
    <label>Spray (ms) <input type="range" id="g_spray" data-midicc min="0" max="120" step="1" value="15"/></label>
    <label>Playback Rate <input type="range" id="g_rate" data-midicc min="0.25" max="2" step="0.01" value="1"/></label>
    <label>Gain <input type="range" id="g_gain" data-midicc min="0" max="1.2" step="0.01" value="0.7"/></label>
    <div style="grid-column:1/-1;display:flex;gap:8px;flex-wrap:wrap">
      <label class="pill kv"><input type="checkbox" id="g_loop" data-midicc checked> <small>Loop</small></label>
      <label class="pill kv"><input type="checkbox" id="g_freeze" data-midicc> <small>Freeze Scan</small></label>
      <button id="g_play" class="synth-btn">Play Granular</button>
      <button id="g_stop" class="synth-btn">Stop Granular</button>
    </div>
  </div>
</div>

<!-- Sampler panel -->
<div id="samplerPanel" class="synth-panel" role="region" aria-label="Sampler controls">
  <div class="section"><h4>Library</h4>
    <div style="grid-column:1/-1;display:flex;gap:8px;flex-wrap:wrap;align-items:center">
      <button id="sam_fromGranular" class="synth-btn">Load From Granular</button>
      <button id="sam_import" class="synth-btn">Import File</button>
      <input id="sam_file" type="file" accept="audio/*" style="display:none">
      <button id="sam_export" class="synth-btn" disabled>Export WAV</button>
    </div>
    <label>Sample <select id="sam_list"></select></label>
    <label>Name <input id="sam_name" type="text" placeholder="Sample name"/></label>
    <div style="grid-column:1/-1;display:flex;gap:8px;flex-wrap:wrap">
      <button id="sam_save" class="synth-btn" disabled>Save/Overwrite</button>
      <button id="sam_delete" class="synth-btn" disabled>Delete</button>
      <span id="sam_status" class="badge"></span>
    </div>
  </div>
  <div class="section"><h4>Mapping</h4>
    <label>Instrument Mode 
      <select id="sam_mode" data-midicc>
        <option value="off">Off (use Synth)</option>
        <option value="sampler">Sampler Only</option>
        <option value="both">Both (layer)</option>
      </select>
    </label>
    <label>Root Note (MIDI) <input type="number" id="sam_root" min="0" max="127" step="1" value="60"/></label>
    <label>Tune (cents) <input type="range" id="sam_tune" data-midicc min="-100" max="100" step="1" value="0"/></label>
    <label>Start (%) <input type="range" id="sam_start" data-midicc min="0" max="99" step="0.1" value="0"/></label>
    <label>End (%) <input type="range" id="sam_end" data-midicc min="1" max="100" step="0.1" value="100"/></label>
    <label><input type="checkbox" id="sam_loop" data-midicc/> Loop</label>
  </div>
  <div class="section"><h4>Envelope & Filter</h4>
    <label>A <input type="range" id="sam_a" data-midicc min="0" max="1" step="0.001" value="0.005"/></label>
    <label>D <input type="range" id="sam_d" data-midicc min="0" max="1" step="0.001" value="0.08"/></label>
    <label>S <input type="range" id="sam_s" data-midicc min="0" max="1" step="0.01" value="0.8"/></label>
    <label>R <input type="range" id="sam_r" data-midicc min="0" max="2" step="0.01" value="0.2"/></label>
    <label>Gain <input type="range" id="sam_gain" data-midicc min="0" max="1.5" step="0.01" value="0.9"/></label>
    <label>Cutoff <input type="range" id="sam_cut" data-midicc min="60" max="10000" step="1" value="10000"/></label>
    <label>Resonance <input type="range" id="sam_q" data-midicc min="0" max="1" step="0.01" value="0.0"/></label>
  </div>
</div>


<!-- Vocoder panel (added) -->
<div id="vocoderPanel" class="synth-panel" role="region" aria-label="Vocoder controls">
  <div class="section">
    <h4>Signal</h4>
    <label>Carrier
      <select id="voc_carrier" data-midicc>
        <option value="off" selected>Off</option>
        <option value="synth">Synth</option>
        <option value="sampler">Sampler</option>
        <option value="both">Both</option>
      </select>
    </label>
    <label>Wet/Dry <input type="range" id="voc_mix" data-midicc min="0" max="1" step="0.01" value="0.0"/></label>
    <label>Output Gain <input type="range" id="voc_out" data-midicc min="0" max="2" step="0.01" value="1.0"/></label>
  </div>
  <div class="section">
    <h4>Bands</h4>
    <label>Bands <select id="voc_bands"><option>8</option><option selected>12</option><option>16</option></select></label>
    <label>Low Freq (Hz) <input type="range" id="voc_lo" min="120" max="600" step="1" value="200"/></label>
    <label>High Freq (Hz) <input type="range" id="voc_hi" min="3000" max="12000" step="10" value="5000"/></label>
    <label>Bandwidth (Q) <input type="range" id="voc_q" min="0.5" max="6" step="0.1" value="2.0"/></label>
    <label>Formant Shift (st) <input type="range" id="voc_shift" min="-6" max="6" step="0.1" value="0"/></label>
    <label>Sibilance Mix <input type="range" id="voc_sib" min="0" max="1" step="0.01" value="0.15"/></label>
  </div>
  <div class="section">
    <h4>Modulator (Mic)</h4>
    <label>Mod Gain <input type="range" id="voc_mod_gain" min="0" max="6" step="0.01" value="1.0"/></label>
    <label>Gate (dB) <input type="range" id="voc_gate" min="-90" max="0" step="1" value="-70"/></label>
    <label>Attack (ms) <input type="range" id="voc_att" min="0" max="200" step="1" value="12"/></label>
    <label>Release (ms) <input type="range" id="voc_rel" min="20" max="1000" step="1" value="160"/></label>
    <div style="grid-column:1/-1;display:flex;gap:8px;flex-wrap:wrap;align-items:center">
      <button id="voc_test" class="synth-btn">Test Mic</button>
      <span id="voc_status" class="badge"></span>
    </div>
  </div>
</div>

<main class="app">
  <div class="controls">
    <div style="display:flex;align-items:center;gap:8px">
      <button id="octDown" class="synth-btn" style="width:40px">‚àí</button>
      <div id="octReadout" class="readout">0</div>
      <button id="octUp" class="synth-btn" style="width:40px">+</button>
    </div>
    <div class="wheel" id="bendWheel" title="Pitch Bend">
      <div class="center"></div>
      <div class="marker" id="bendMarker"></div>
    </div>
    <button id="microBtn" class="synth-btn owl" title="Quartertone mode">
      <svg viewBox="0 0 100 100" width="22" height="22"><circle cx="50" cy="50" r="40" fill="none" stroke="#25ff85" stroke-width="8"/><text x="50" y="58" text-anchor="middle" font-size="42" fill="#25ff85">ü¶â</text></svg>
    </button>
<button id="seqToggle" type="button" class="synth-btn" aria-pressed="false" title="Sequencer On/Off">Sequencer</button>
<button id="seqModeBtn" type="button" class="synth-btn" aria-pressed="false" title="Switch Input/Play" style="display:none">Input</button>
<button id="seqClearBtn" type="button" class="synth-btn" title="Clear sequence" style="display:none">Clear</button>
    <span id="midiState" class="badge" aria-live="polite"></span>
  </div>
  <div id="keypadWrap" class="keypad-wrap">
    <div id="keypad" class="keypad" aria-label="Keypad"></div>
  </div>
</main>

<footer class="footer">WebAudio ‚Ä¢ WebMIDI + CC Learn ‚Ä¢ Full Synth ‚Ä¢ FX Suite ‚Ä¢ Granular ‚Ä¢ Sampler</footer>

<script>
/* ===== Utilities ===== */
const clamp=(v,min,max)=>v<min?min:v>max?max:v;
function u8ToB64(u8){ const CHUNK=0x7000; let out=''; for(let i=0;i<u8.length;i+=CHUNK){ const slice=u8.subarray(i,i+CHUNK); out+=String.fromCharCode.apply(null,slice); } return btoa(out); }
function b64EncodeUnicode(str){ try{ return btoa(unescape(encodeURIComponent(str))); }catch{ return btoa(str); } }
function b64DecodeUnicode(str){ try{ return decodeURIComponent(escape(atob(str))); }catch{ return atob(str); } }
const midiToFreq=m=>440*Math.pow(2,(m-69)/12);
function tapToUnlockAudio(){
  try{
    if(!audioCtx) return;
    const b = audioCtx.createBuffer(1, 1, audioCtx.sampleRate);
    const s = audioCtx.createBufferSource(); s.buffer = b; s.connect(audioCtx.destination);
    try{ s.start(0); }catch(e){} s.disconnect();
  }catch(e){}
}

/* ===== Core state ===== */
let audioCtx=null; let GRID_W=4; let gridRows=/Android|iPhone|iPad|iPod/i.test(navigator.userAgent)?8:4;
let octaveOffset=0; const BASE_MIDI=60;
let bendSemis=0; let bendRange=2; let microMode=false;

/* ===== Recording bus & shared stores ===== */
let mixNode=null, limiter=null, mediaStreamDest=null, mediaRecorder=null;
let recChunks=[], recStartTs=0, recInter=null; const MAX_REC_S=15;
const TAKES_KEY='stagsynth_takes_v5';
function loadTakes(){ try{ return JSON.parse(localStorage.getItem(TAKES_KEY)||'{}'); }catch{return{}} }
function saveTakes(o){ try{ localStorage.setItem(TAKES_KEY, JSON.stringify(o)); }catch(e){} }
/* ===== Setup / teardown ===== */
function setupRecordingBus(){
  const a=audioCtx;
  mixNode=a.createGain(); mixNode.gain.value=.95;

  // Safety limiter at the very end
  limiter=a.createDynamicsCompressor();
  limiter.threshold.value=-10; limiter.knee.value=20; limiter.ratio.value=8;
  limiter.attack.value=0.003; limiter.release.value=0.25;

  const dcBlock = a.createBiquadFilter(); dcBlock.type='highpass'; dcBlock.frequency.value=25; dcBlock.Q.value=0.707;
mixNode.connect(dcBlock).connect(limiter).connect(a.destination);

  // Recorder taps the post-limiter signal so captured audio matches what you hear
  mediaStreamDest=a.createMediaStreamDestination();
  limiter.connect(mediaStreamDest);
}

/* Choose recording mime that works broadly; iOS-friendly first */
function pickBestAudioMime(){
  const prefer=[
    'audio/mp4', 'audio/aac', 'audio/mpeg',
    'audio/ogg;codecs=opus', 'audio/webm;codecs=opus', 'audio/webm'
  ];
  for(const m of prefer){
    try{ if(window.MediaRecorder && MediaRecorder.isTypeSupported(m)) return m; }catch(e){}
  }
  return '';
}

function startTopRecording(){
  if(!mediaStreamDest) return;
  if(!('MediaRecorder' in window)){
    document.getElementById('recTimer').textContent='Recording not supported on this browser.';
    return;
  }
  if(mediaRecorder && mediaRecorder.state==='recording') return;

  const mime = pickBestAudioMime();
  try{
    mediaRecorder = mime
      ? new MediaRecorder(mediaStreamDest.stream,{ mimeType:mime, audioBitsPerSecond:128000 })
      : new MediaRecorder(mediaStreamDest.stream);
  }catch(err){
    document.getElementById('recTimer').textContent='Recorder init failed.';
    console.warn('MediaRecorder init error', err);
    return;
  }

  recChunks=[];
  const recBtn=document.getElementById('recBtn');
  const recLabel=document.getElementById('recLabel');
  recBtn.classList.remove('dim'); recBtn.classList.add('recording'); recLabel.textContent='Stop';

  mediaRecorder.ondataavailable=(e)=>{ if(e.data && e.data.size>0) recChunks.push(e.data); };
  mediaRecorder.onstop = async ()=>{
    try{
      const blob = new Blob(recChunks, { type: mediaRecorder.mimeType || mime || 'audio/mp4' });
      const arr  = await blob.arrayBuffer();
      await ensureAudio();

      let decoded=null;
      try{ decoded = await audioCtx.decodeAudioData(arr.slice(0)); }catch(decErr){ console.warn('decodeAudioData failed', decErr); }

      if(!decoded){
        const url = URL.createObjectURL(blob);
        const el  = new Audio(); el.src = url; el.crossOrigin='anonymous';
        await el.play().catch(()=>{}); el.pause();
        const dur = Math.max(0.01, isFinite(el.duration) && el.duration>0 ? el.duration : 1.0);
        const off = new OfflineAudioContext(2, Math.ceil((audioCtx.sampleRate||48000) * dur), audioCtx.sampleRate||48000);
        const src = off.createMediaElementSource(el);
        src.connect(off.destination);
        el.currentTime = 0;
        decoded = await off.startRendering();
        URL.revokeObjectURL(url);
      }

      // Stash & auto-load into Granulator
      const wavAB = encodeWAVFromBuffer(decoded);
      const b64   = u8ToB64(new Uint8Array(wavAB));
      const takes = loadTakes();
      const nm    = 'Master '+new Date().toLocaleTimeString();
      takes[nm]   = { wavB64:b64, sampleRate: decoded.sampleRate };
      saveTakes(takes);

      currentTakeBuffer = decoded;
      currentTakeName   = nm;
      enableGranularButtons();
      refreshTakeList();
      setGranularStatus('Added & loaded "'+nm+'" from main Record');
    }catch(e){
      console.warn('decode/auto-add error', e);
      setGranularStatus('Recording finished, but decode failed');
    }

    const recBtn=document.getElementById('recBtn'); const recLabel=document.getElementById('recLabel');
    recBtn.classList.remove('recording'); recBtn.classList.add('dim'); recLabel.textContent='Record';
  };

  mediaRecorder.start(100);
  recStartTs = performance.now();

  recInter = setInterval(()=>{
    const elapsed = ((performance.now()-recStartTs)/1000)|0;
    const left    = Math.max(0, MAX_REC_S - elapsed);
    document.getElementById('recTimer').textContent =
      'REC '+(left/60|0)+':'+String(left%60).padStart(2,'0')+' left / '+MAX_REC_S+'s';
    if (elapsed >= MAX_REC_S) stopTopRecording();
  }, 250);
}

function stopTopRecording(){
  if(mediaRecorder && mediaRecorder.state==='recording'){ try{ mediaRecorder.stop(); }catch(e){} }
  clearInterval(recInter);
  document.getElementById('recTimer').textContent='';
  const recBtn=document.getElementById('recBtn'); const recLabel=document.getElementById('recLabel');
  recBtn.classList.remove('recording'); recBtn.classList.add('dim'); recLabel.textContent='Record';
}

/* ===== Audio bootstrap / reset ===== */
function ensureAudio(){
  if(audioCtx && audioCtx.state==='suspended'){ audioCtx.resume?.(); }
  if(synth) return Promise.resolve(true);

  audioCtx=new (window.AudioContext||window.webkitAudioContext)({latencyHint:'interactive'});

  // iOS Chrome/Safari unlock
  const unlock = ()=>{ audioCtx.resume?.(); tapToUnlockAudio(); };
  window.addEventListener('touchend', unlock, { once:true, passive:true });
  window.addEventListener('click', unlock, { once:true, passive:true });

  setupRecordingBus();
  synth=makeSynth(audioCtx);
  pushParams();
  try{ window.dispatchEvent(new CustomEvent("audio:ready")); }catch(e){}
return Promise.resolve(true);
}
async function hardResetAudio(){
  try{ stopTopRecording(); }catch(e){}
  try{ stopGranular(true); }catch(e){}
  try{ killSamplerAll(); }catch(e){}
  try{ synth?.killAll?.(); }catch(e){}
  try{ if(mixNode){ mixNode.disconnect(); } }catch(e){}
  try{ if(limiter){ limiter.disconnect(); } }catch(e){}
  try{ if(mediaStreamDest){ mediaStreamDest.disconnect(); } }catch(e){}
  try{ if(audioCtx){ await audioCtx.close(); } }catch(e){}
  audioCtx=null; mixNode=null; limiter=null; mediaStreamDest=null; mediaRecorder=null;
  synth=null;

  grainTicker=null; scanTicker=null; grainActive=null; granularOut=null;
  samplerBus={out:null, filter:null};

  await ensureAudio();
}

/* ===== Curves ===== */
function makeDriveCurve(amount=0){
  const k=amount*20; const n=44100; const c=new Float32Array(n);
  for(let i=0;i<n;i++){ const x=i/(n-1)*2-1; c[i]=(1+k)*x/(1+k*Math.abs(x)); }
  return c;
}

/* ===== Bitcrusher Worklet (inline) ===== */
let bitcrusherNode=null, bitcrusherMix=null;
async function initBitcrusherWorklet(ctx){
  const isLocal = typeof location!=='undefined' && location.protocol==='file:';
  const isSecure = (typeof isSecureContext!=='undefined' && isSecureContext) || (location && (location.protocol==='https:' || location.hostname==='localhost'));
  if(!ctx.audioWorklet || isLocal || !isSecure){ ctx._bcRegistered=false; ctx._bcLoading=false; return; }

  if(ctx.audioWorklet && !ctx._bcRegistered && !ctx._bcLoading){
    ctx._bcLoading=true;
    const code = `
      class BitcrusherProcessor extends AudioWorkletProcessor{
        static get parameterDescriptors(){
          return [
            { name:'bits', defaultValue:24, minValue:1, maxValue:24, automationRate:'k-rate' },
            { name:'downRate', defaultValue:48000, minValue:50, maxValue:96000, automationRate:'k-rate' }
          ];
        }
        constructor(){ super(); this._phase=0; this._lastL=0; this._lastR=0; }
        process(inputs, outputs, params){
          const input = inputs[0], output = outputs[0];
          if(!input || !input[0] || !output || !output[0]) return true;
          const inL=input[0], inR=input[1]||input[0], outL=output[0], outR=output[1]||output[0];
          const bits = Math.max(1, Math.min(24, params.bits[0]|0));
          const step = Math.max(1, Math.floor(sampleRate / Math.max(50, params.downRate[0]||48000)));
          const levels = Math.max(2, (1<<Math.min(23,bits)));
          const q = 2/levels;
          for(let i=0;i<outL.length;i++){
            if(this._phase===0){
              const l = Math.max(-1,Math.min(1, Math.round(inL[i]/q)*q));
              const r = Math.max(-1,Math.min(1, Math.round(inR[i]/q)*q));
              this._lastL = l; this._lastR = r;
            }
            outL[i]=this._lastL; outR[i]=this._lastR;
            this._phase = (this._phase+1)%step;
          }
          return true;
        }
      }
      try{ if(!globalThis.__bitcrusherRegistered){ registerProcessor('bitcrusher-processor', BitcrusherProcessor); globalThis.__bitcrusherRegistered=true; } }catch(e){ globalThis.__bitcrusherRegistered=true; }
    `;
    const blob = new Blob([code], {type:'application/javascript'});
    const url  = URL.createObjectURL(blob);
    await ctx.audioWorklet.addModule(url);
    URL.revokeObjectURL(url);
    ctx._bcRegistered = true;
    ctx._bcLoading = false;
  }
}

/* ===== Synth engine with WORKING core Filter + FX Suite (all reactive) ===== */
let synth=null;
function makeSynth(a){
  const voices=new Map();

  /* === ALWAYS-IN-PATH CORE FILTER === */
  const coreFilter = a.createBiquadFilter();
  coreFilter.type='lowpass'; coreFilter.frequency.value=1600; coreFilter.Q.value=0.2;

  /* === Optional COLOR bus (drive + wet/dry) AFTER core filter === */
  const colorDry = a.createGain(); colorDry.gain.value=1.0;
  const colorWet = a.createGain(); colorWet.gain.value=0.0;
  const colorSum = a.createGain();
  const colorFilter = a.createBiquadFilter(); colorFilter.type='lowpass'; colorFilter.frequency.value=1600; colorFilter.Q.value=0.2;
  const colorShaper = a.createWaveShaper(); colorShaper.curve = makeDriveCurve(0);

  // coreFilter ‚Üí (dry‚Üísum) + (filter‚Üíshaper‚Üíwet‚Üísum)
  coreFilter.connect(colorDry).connect(colorSum);
  coreFilter.connect(colorFilter).connect(colorShaper).connect(colorWet).connect(colorSum);

  /* === Ring Mod (AM) with depth + wet/dry MIX (FIXED) === */
  const rmCarrier = a.createOscillator(); rmCarrier.type='sine'; rmCarrier.frequency.value=30;
  const rmDepth   = a.createGain(); rmDepth.gain.value=0.0;
  const ringVCA   = a.createGain(); ringVCA.gain.value=0.0;

  const ringDry = a.createGain(); ringDry.gain.value=1.0;
  const ringWet = a.createGain(); ringWet.gain.value=0.0;
  const ringMix = a.createGain();

  colorSum.connect(ringDry);
  colorSum.connect(ringVCA);
  rmCarrier.connect(rmDepth).connect(ringVCA.gain);

  ringVCA.connect(ringWet);
  ringDry.connect(ringMix);
  ringWet.connect(ringMix);

  /* === Chorus (L/R delays) with MIX === */
  const chIn = a.createGain();
  const chDry = a.createGain(); chDry.gain.value=1.0;
  const chWet = a.createGain(); chWet.gain.value=0.0;
  const chOut = a.createGain();
  const chDelayL = a.createDelay(0.05), chDelayR = a.createDelay(0.05);
  const chLFO1 = a.createOscillator(), chLFO2 = a.createOscillator();
  const chDepthL = a.createGain(), chDepthR = a.createGain();
  chLFO1.type='sine'; chLFO2.type='sine';
  chDepthL.gain.value = 0.006; chDepthR.gain.value = 0.006;

  ringMix.connect(chIn);
  chIn.connect(chDelayL).connect(chWet);
  chIn.connect(chDelayR).connect(chWet);
  chIn.connect(chDry);
  chDry.connect(chOut); chWet.connect(chOut);
  chLFO1.connect(chDepthL).connect(chDelayL.delayTime);
  chLFO2.connect(chDepthR).connect(chDelayR.delayTime);

  /* === Distortion (Drive/Tone/Mix) === */
  const distIn  = a.createGain();
  const distPre = a.createGain();
  const distWS  = a.createWaveShaper();
  const distTone= a.createBiquadFilter(); distTone.type='lowpass'; distTone.frequency.value=20000;
  const distDry = a.createGain(); distDry.gain.value=1.0;
  const distWet = a.createGain(); distWet.gain.value=0.0;
  const distSum = a.createGain();

  chOut.connect(distIn);
  distIn.connect(distDry).connect(distSum);
  distIn.connect(distPre).connect(distWS).connect(distTone).connect(distWet).connect(distSum);

  /* === Bitcrusher (worklet) with MIX === */
  const bcIn  = a.createGain();
  const bcDry = a.createGain(); bcDry.gain.value = 1.0;
  const bcWet = a.createGain(); bcWet.gain.value = 0.0;
  const bcSum = a.createGain();
  distSum.connect(bcIn);
  bcIn.connect(bcDry).connect(bcSum);
  (async ()=>{
    await initBitcrusherWorklet(a);
    let node=null; try{ if(a && a._bcRegistered){ node = new AudioWorkletNode(a,'bitcrusher-processor',{numberOfInputs:1,numberOfOutputs:1,outputChannelCount:[2]}); } }catch(e){ console.warn('[bitcrusher] node create failed', e && e.name); }bitcrusherNode = node;
    bitcrusherMix  = { dry: bcDry, wet: bcWet };
    if(node){ bcIn.connect(node).connect(bcWet); }
    bcWet.connect(bcSum);
  })();

  /* === Reverb (predelay ‚Üí convolver ‚Üí damp LPF) with MIX === */
  const revIn = a.createGain(), revOut = a.createGain();
  const revDry = a.createGain(); revDry.gain.value=1.0;
  const revWet = a.createGain(); revWet.gain.value=0.0;
  const revPre = a.createDelay(0.25);
  const revConv = a.createConvolver();
  const revDamp = a.createBiquadFilter(); revDamp.type='lowpass'; revDamp.frequency.value=6000;

  bcSum.connect(revIn);
  revIn.connect(revDry).connect(revOut);
  revIn.connect(revPre).connect(revConv).connect(revDamp).connect(revWet).connect(revOut);

  /* === Compressor + Makeup ‚Üí master limiter === */
  const comp = a.createDynamicsCompressor();
  const makeup = a.createGain(); makeup.gain.value=1.0;
  const synthBus = a.createGain(); synthBus.gain.value=1.0; revOut.connect(comp).connect(makeup).connect(synthBus).connect(mixNode); try{ window._stagsynth_synthBus=synthBus; window._stagsynth_synthCtx=a; }catch(e){}

  // Start carriers/LFOs
  try{ rmCarrier.start(); chLFO1.start(); chLFO2.start(); }catch(e){}

  // ===== Params (neutral FX by default) =====
  const params={
    // Core synth filter
    mode:'lp', cutoff:1600, resonance:0.2,

    // Color bus
    drive:0, mix:0,

    // Reverb (predelay in ms in UI)
    fx_rev_room:0.6, fx_rev_decay:3.0, fx_rev_predelay:20, fx_rev_damp:6000, fx_rev_mix:0.0,

    // Chorus (depth in ms in UI)
    fx_ch_rate:1.0, fx_ch_depth:6, fx_ch_voices:2, fx_ch_width:0.8, fx_ch_mix:0.0,

    // Distortion
    fx_dist_type:'soft', fx_dist_drive:0.0, fx_dist_tone:20000, fx_dist_mix:0.0,

    // Compressor (attack/release in ms in UI)
    fx_comp_thr:0, fx_comp_ratio:1, fx_comp_att:5, fx_comp_rel:200, fx_comp_makeup:0,

    // Bitcrusher
    fx_bc_bits:24, fx_bc_rate:48000, fx_bc_mix:0.0,

    // Ring Mod
    fx_rm_freq:30, fx_rm_wave:'sine', fx_rm_depth:0.0, fx_rm_mix:0.0,

    // Osc / env
    shape:'sawtooth', subShape:'off', detune:0, subDetune:0, subLevel:0.8, subOctave:1, noiseColor:'white',
    a:0.01,d:0.08,s:0.6,r:0.15
  };

  // ===== Setters =====
  function applyCoreFilter(){
    coreFilter.type = (params.mode==='hp')?'highpass' : (params.mode==='bp')?'bandpass' : 'lowpass';
    coreFilter.frequency.value = Math.max(40, params.cutoff||1600);
    coreFilter.Q.value = Math.max(0, Math.min(20, (params.resonance||0.2)*20));
    // color prefilter follows core tone so drive coloration tracks
    colorFilter.type = coreFilter.type;
    colorFilter.frequency.value = coreFilter.frequency.value;
    colorFilter.Q.value = coreFilter.Q.value*0.6;
  }
  function setColor(){
    colorShaper.curve = makeDriveCurve(Math.max(0, Math.min(1, params.drive||0)));
    const m = Math.max(0, Math.min(1, params.mix||0));
    colorWet.gain.value = m; colorDry.gain.value = 1 - m;
  }
  function regenImpulse(room=0.6, decay=3.0){
    const dur = Math.max(0.2, decay) * (0.6 + room*0.8);
    const len = Math.ceil(a.sampleRate * Math.min(12, dur));
    const buf = a.createBuffer(2, len, a.sampleRate);
    for(let ch=0; ch<2; ch++){
      const data = buf.getChannelData(ch);
      for(let i=0;i<len;i++){
        const t = i/len;
        const env = Math.pow(1 - t, 2.5);
        data[i] = (Math.random()*2-1) * env;
      }
    }
    return buf;
  }
  function setReverb(){
    const predelaySec = Math.max(0, (params.fx_rev_predelay||20) / 1000); // ms ‚Üí s
    revConv.buffer = regenImpulse(params.fx_rev_room, params.fx_rev_decay);
    revPre.delayTime.value = predelaySec;
    revDamp.frequency.value = params.fx_rev_damp;
    const mix = Math.max(0, Math.min(1, params.fx_rev_mix||0));
    revWet.gain.value = mix; revDry.gain.value = 1 - mix;
  }
  function setChorus(){
    const rate = params.fx_ch_rate;
    const depthSec = Math.max(0, (params.fx_ch_depth||6))/1000; // ms‚Üís
    chDepthL.gain.value = depthSec;
    chDepthR.gain.value = depthSec * (0.5 + params.fx_ch_width*0.5);
    chLFO1.frequency.value = rate;
    chLFO2.frequency.value = rate * (0.9 + params.fx_ch_width*0.2);
    chWet.gain.value = params.fx_ch_mix;
    chDry.gain.value = 1 - params.fx_ch_mix;
  }
  function makeDistCurve(type='soft', drive=0){
    const n = 44100, curve = new Float32Array(n);
    const kSoft = 1e-3 + drive * 40;
    const kTanh = 1 + drive * 10;
    const tHard = 1 - 0.8 * drive;
    for(let i=0;i<n;i++){
      const x = i/(n-1)*2 - 1;
      let y = x;
      if(type==='soft'){
        y = (1+kSoft)*x/(1+kSoft*Math.abs(x));
      }else if(type==='tanh'){
        y = Math.tanh(kTanh * x);
      }else{
        const t = Math.max(0.2, tHard);
        const c = Math.max(-t, Math.min(t, x));
        y = c / t;
      }
      curve[i]=y;
    }
    return curve;
  }
  function setDistortion(){
    const type = params.fx_dist_type||'soft';
    const drv  = Math.max(0, Math.min(1, params.fx_dist_drive||0));
    distWS.curve = makeDistCurve(type, drv);
    distPre.gain.value = 1 + drv * 20;
    distTone.frequency.value = Math.max(1000, Math.min(20000, params.fx_dist_tone||20000));
    const mix = Math.max(0, Math.min(1, params.fx_dist_mix||0));
    distWet.gain.value = mix; distDry.gain.value = 1 - mix;
  }
  function setRing(){
    rmCarrier.type = params.fx_rm_wave||'sine';
    rmCarrier.frequency.value = params.fx_rm_freq||30;
    rmDepth.gain.value = Math.max(0, params.fx_rm_depth||0); // AM depth
    const mix = Math.max(0, Math.min(1, params.fx_rm_mix||0));
    ringWet.gain.value = mix;      // effective now
    ringDry.gain.value = 1 - mix;  // effective now
  }
  function setBitcrusher(){
    const sr = a.sampleRate || 48000;
    const rate = Math.max(50, Math.min(sr, params.fx_bc_rate || sr));
    const bits = Math.max(1, Math.min(24, params.fx_bc_bits || 24));
    if(bitcrusherNode){
      bitcrusherNode.parameters.get('bits')?.setValueAtTime(bits, a.currentTime);
      bitcrusherNode.parameters.get('downRate')?.setValueAtTime(rate, a.currentTime);
    }
    const mix = Math.max(0, Math.min(1, params.fx_bc_mix||0));
    bcWet.gain.value = mix; bcDry.gain.value = 1 - mix;
  }
  function setCompressor(){
    const attSec = Math.max(0.0001, (params.fx_comp_att||5) / 1000);  // ms‚Üís
    const relSec = Math.max(0.001,  (params.fx_comp_rel||200) / 1000);
    comp.threshold.value = params.fx_comp_thr;
    comp.ratio.value     = params.fx_comp_ratio;
    comp.attack.value    = attSec;
    comp.release.value   = relSec;
    makeup.gain.value    = Math.pow(10, (params.fx_comp_makeup||0)/20);
  }

  // Initialize processing graph states
  applyCoreFilter(); setColor(); setReverb(); setChorus(); setDistortion(); setRing(); setCompressor();
  (async()=>{ await initBitcrusherWorklet(a); setBitcrusher(); })();

  // ===== Voice helpers =====
  const shapeMap={saw:'sawtooth',sawtooth:'sawtooth',square:'square',triangle:'triangle',sine:'sine',noise:'noise',off:'off'};
  const isCustomShape=(v)=>typeof v==='string' && v.startsWith('custom:');
  function noise(color){
    const buffer=a.createBuffer(1, a.sampleRate*2, a.sampleRate);
    const data=buffer.getChannelData(0);
    if(color==='pink'){ let b0=0, AA=0.997; for(let i=0;i<data.length;i++){ const w=Math.random()*2-1; b0=AA*b0+(1-AA)*w; data[i]=b0*1.5; } }
    else { for(let i=0;i<data.length;i++) data[i]=Math.random()*2-1; }
    const src=a.createBufferSource(); src.buffer=buffer; src.loop=true; return src;
  }
  function osc(freq, type){ if(type==='noise') return noise(params.noiseColor||'white'); const o=a.createOscillator(); o.type=type; o.frequency.value=freq; return o; }
  function env(){ const clamp01=(x)=>Math.max(0,Math.min(1,x)); return { a:Math.max(.001,params.a), d:Math.max(.001,params.d), s:clamp01(params.s), r:Math.max(.001,params.r) }; }

  // ===== Public synth API =====
  return{
    _params: {...params},
    set(name,value){
      this._params[name]=value;
      // Core filter
      if(name==='mode'||name==='cutoff'||name==='resonance'){ params[name]=value; applyCoreFilter(); return; }
      // Color drive/mix
      if(name==='drive'||name==='mix'){ params[name]=value; setColor(); return; }
      // FX
      if(name.startsWith('fx_rev_')){ params[name]=value; setReverb(); return; }
      if(name.startsWith('fx_ch_')){ params[name]=value; setChorus(); return; }
      if(name.startsWith('fx_dist_')){ params[name]=value; setDistortion(); return; }
      if(name.startsWith('fx_comp_')){ params[name]=value; setCompressor(); return; }
      if(name.startsWith('fx_bc_')){ params[name]=value; setBitcrusher(); return; }
      if(name.startsWith('fx_rm_')){ params[name]=value; setRing(); return; }
      // Osc / env params
      params[name]=value;
      if(name==='detune'||name==='subDetune'){ this.setBend?.(bendSemis); }
    },
    setBend(semi){
      const ratio=Math.pow(2,(semi||0)/12);
      for(const v of voices.values()){
        const base=v.baseFreq;
        v.main?.forEach(o=>{ if(o.frequency){ o.frequency.value = base * Math.pow(2,((this._params?.detune)||0)/1200) * ratio; } });
        v.sub ?.forEach(o=>{ if(o.frequency){ const b=((this._params?.subOctave||1)===0.5)?(base/2):base; o.frequency.value = b * Math.pow(2,((this._params?.subDetune)||0)/1200) * ratio; } });
      }
    },
    noteOn(m,vel=0.9){
      const key = Math.round(m*2)/2;
      const freq = midiToFreq(m);
      const existing = voices.get(key);
      const e = env(); const t=a.currentTime; const peak=.28*vel;
      if(existing){
        try{
          existing.g.gain.cancelScheduledValues(t); existing.g.gain.setValueAtTime(1e-5,t);
          existing.g.gain.linearRampToValueAtTime(peak,t+e.a);
          existing.g.gain.linearRampToValueAtTime(peak*e.s,t+e.a+e.d);
          existing.e=e; existing.baseFreq=freq;
        }catch(e){}
        try{ this.setBend?.(bendSemis) }catch(e){};
        return;
      }
      // Per-voice gain ‚Üí CORE FILTER (global) ‚Üí rest of graph
      const g=a.createGain(); g.gain.value=1e-5; g.connect(coreFilter);

      // Main & sub osc
      const mainType=isCustomShape(params.shape)?params.shape:(shapeMap[params.shape]||'sawtooth');
      const subType =isCustomShape(params.subShape)?params.subShape:(shapeMap[params.subShape]||'off');
      const main=(mainType==='noise')?[noise(params.noiseColor||'white')]:[ (window.oscFactory?window.oscFactory(a, freq*Math.pow(2,(params.detune||0)/1200), mainType, params) : osc(freq*Math.pow(2,(params.detune||0)/1200),mainType)) ];
      const base=((params.subOctave||1)===0.5)?(freq/2):freq;
      const sub =(subType==='off')?[]:(subType==='noise')?[noise(params.noiseColor||'white')]:[ (window.oscFactory?window.oscFactory(a, base*Math.pow(2,(params.subDetune||0)/1200), subType, params) : osc(base*Math.pow(2,(params.subDetune||0)/1200),subType)) ];

      const subG=a.createGain(); subG.gain.value=Math.max(0,Math.min(1,params.subLevel||0)); subG.connect(g);
      main.forEach(nd=>{ nd.connect(g); try{ nd.start() }catch(e){} });
      sub.forEach (nd=>{ nd.connect(subG); try{ nd.start() }catch(e){} });

      // ADSR
      g.gain.setValueAtTime(1e-5,t); g.gain.linearRampToValueAtTime(peak,t+e.a); g.gain.linearRampToValueAtTime(peak*e.s,t+e.a+e.d);

      voices.set(key,{g,e,baseFreq:freq,main,sub});
      try{ this.setBend?.(bendSemis) }catch(e){};
    },
    noteOff(m){
      const key=Math.round(m*2)/2; const v=voices.get(key); if(!v) return;
      const t=a.currentTime, stopAt=t+v.e.r+.02;
      try{
        v.g.gain.cancelScheduledValues(t);
        v.g.gain.setValueAtTime(v.g.gain.value,t);
        v.g.gain.linearRampToValueAtTime(1e-5,stopAt);
        v.main?.forEach(nd=>{ try{ nd.stop(stopAt) }catch(e){} });
        v.sub ?.forEach(nd=>{ try{ nd.stop(stopAt) }catch(e){} });
      }catch(e){}
      setTimeout(()=>voices.delete(key),120);
    },
    killAll(){
      const t=a.currentTime+.01;
      for(const [k,v] of voices.entries()){
        try{
          v.g.gain.cancelScheduledValues(t);
          v.g.gain.setValueAtTime(1e-5,t);
          v.main?.forEach(nd=>{ try{ nd.stop(t+.02) }catch(e){} });
          v.sub ?.forEach(nd=>{ try{ nd.stop(t+.02) }catch(e){} });
        }catch(e){}
      }
      voices.clear();
    }
  };
}

/* ===== Presets ===== */
const PRESET_KEY='stagsynth_presets_v5';
const PRESET_PARAMS=[
  'shape','subShape','detune','subDetune','subLevel','subOctave','noiseColor',
  'mode','cutoff','resonance','a','d','s','r','drive','mix',
  'fx_rev_room','fx_rev_decay','fx_rev_predelay','fx_rev_damp','fx_rev_mix',
  'fx_ch_rate','fx_ch_depth','fx_ch_voices','fx_ch_width','fx_ch_mix',
  'fx_dist_type','fx_dist_drive','fx_dist_tone','fx_dist_mix',
  'fx_comp_thr','fx_comp_ratio','fx_comp_att','fx_comp_rel','fx_comp_makeup',
  'fx_bc_bits','fx_bc_rate','fx_bc_mix',
  'fx_rm_freq','fx_rm_wave','fx_rm_depth','fx_rm_mix'
];
function loadPresetStore(){ try{ return JSON.parse(localStorage.getItem(PRESET_KEY)||'{}'); }catch{return{}} }
function savePresetStore(s){ try{ localStorage.setItem(PRESET_KEY, JSON.stringify(s)); }catch(e){} }
function readUI(){ const o={}; PRESET_PARAMS.forEach(k=>{ const el=document.getElementById(k); if(el){ o[k]=(el.type==='range'||el.type==='number')?parseFloat(el.value):el.value; } }); return o; }
function applyPreset(p){ if(!p) return; Object.entries(p).forEach(([k,v])=>{ const el=document.getElementById(k); if(!el) return; el.value = (el.type==='range'||el.type==='number')? String(v): v; }); pushParams(); }
function initPresets(){
  const sel=document.getElementById('presetSelect');
  const name=document.getElementById('presetName');
  const saveB=document.getElementById('savePresetBtn');
  const loadB=document.getElementById('loadPresetBtn');
  const delB=document.getElementById('deletePresetBtn');
  const expB=document.getElementById('exportPresetsBtn');
  const impB=document.getElementById('importPresetsBtn');
  const impF=document.getElementById('importPresetsFile');
  const shareB=document.getElementById('shareLinkBtn');
  const msg=document.getElementById('presetMsg');
  let store=loadPresetStore();

  const incoming=(location.hash||'').match(/[#&]presets=([^&]+)/);
  if(incoming){ try{ const obj=JSON.parse(b64DecodeUnicode(incoming[1])); store={...store, ...obj}; savePresetStore(store); history.replaceState(null,'',location.pathname); }catch(e){} }

  if(Object.keys(store).length===0){ store['Init']=readUI(); savePresetStore(store); }
  function refresh(nm){ const prev=sel.value; sel.innerHTML=''; Object.keys(store).sort().forEach(n=>{ const o=document.createElement('option'); o.value=n; o.textContent=n; sel.appendChild(o); }); sel.value = nm ? nm : (prev || sel.value); }
  refresh('Init');

  saveB.onclick=()=>{ const nm=(name.value||'Preset').trim(); store[nm]=readUI(); savePresetStore(store); refresh(nm); };
  loadB.onclick=()=>{ applyPreset(store[sel.value]); };
  delB.onclick=()=>{ const nm=sel.value; delete store[nm]; savePresetStore(store); refresh(); };
  expB.onclick=()=>{ const blob=new Blob([JSON.stringify(store,null,2)],{type:'application/json'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='stagsynth-presets.json'; a.click(); setTimeout(()=>URL.revokeObjectURL(url),1000); };
  impB.onclick=()=>impF.click();
  impF.onchange=async()=>{ const f=impF.files?.[0]; if(!f) return; try{ const txt=await f.text(); const data=JSON.parse(txt); store={...store,...data}; savePresetStore(store); refresh(); }catch(e){} impF.value='';
  };
  shareB.onclick=async()=>{
    const url=location.origin+location.pathname + '#presets=' + b64EncodeUnicode(JSON.stringify(store));
    try{ await navigator.clipboard.writeText(url); msg.textContent='Link copied'; setTimeout(()=>msg.textContent='',1200); }catch{ prompt('Copy URL', url); }
  };
}

/* ===== Param push (includes FX) ===== */
function pushParams(){
  if(!synth) return;
  [
    'shape','subShape','detune','subDetune','mode','cutoff','resonance','a','d','s','r','drive','mix','subLevel','subOctave','noiseColor',
    'fx_rev_room','fx_rev_decay','fx_rev_predelay','fx_rev_damp','fx_rev_mix',
    'fx_ch_rate','fx_ch_depth','fx_ch_voices','fx_ch_width','fx_ch_mix',
    'fx_dist_type','fx_dist_drive','fx_dist_tone','fx_dist_mix',
    'fx_comp_thr','fx_comp_ratio','fx_comp_att','fx_comp_rel','fx_comp_makeup',
    'fx_bc_bits','fx_bc_rate','fx_bc_mix',
    'fx_rm_freq','fx_rm_wave','fx_rm_depth','fx_rm_mix'
  ].forEach(id=>{
    const el=document.getElementById(id);
    if(!el) return;
    const val=(el.type==='range'||el.type==='number')?parseFloat(el.value):el.value;
    try{synth.set(id,val)}catch(e){};
  });
}

/* ===== Keypad, micro, bend ===== */
function buildKeypad(){
  const pad=document.getElementById('keypad'); pad.innerHTML=''; pad.style.gridTemplateColumns='repeat('+GRID_W+',1fr)';
  const total=GRID_W*gridRows, step = microMode?0.5:1;
  for(let i=0;i<total;i++){
    const m=BASE_MIDI + i*step + 12*octaveOffset;
    const b=document.createElement('button'); b.className='key'; b.dataset.midi=String(m); b.textContent='';
    b.onpointerdown=(e)=>{ e.preventDefault(); b.setPointerCapture?.(e.pointerId); b.classList.add('on'); routeNoteOn(m,.9); };
    b.onpointerup=()=>{ b.classList.remove('on'); routeNoteOff(m); };
    b.onpointerleave=()=>{ b.classList.remove('on'); routeNoteOff(m); };
    pad.appendChild(b);
  }
  try{ window.dispatchEvent(new CustomEvent("rebuild:keypad")); }catch(e){}

}
function bindKeyboard(){
  const map=['a','w','s','e','d','f','t','g','y','h','u','j','k','o','l','p'];
  window.addEventListener('keydown',e=>{ if(e.repeat) return; const idx=map.indexOf(e.key?.toLowerCase?.()); if(idx<0) return; const btn=document.querySelectorAll('.key')[idx]; if(!btn) return; btn.dispatchEvent(new PointerEvent('pointerdown',{bubbles:true})); });
  window.addEventListener('keyup',e=>{ const idx=map.indexOf(e.key?.toLowerCase?.()); if(idx<0) return; const btn=document.querySelectorAll('.key')[idx]; if(!btn) return; btn.dispatchEvent(new PointerEvent('pointerup',{bubbles:true})); });
}
function bindBendAndMicro(){
  const wheel=document.getElementById('bendWheel');
  const marker=document.getElementById('bendMarker');
  let active=false;
  function setBendFromY(y, rect){
    const rel = 1 - (y/rect.height);
    let semi = (rel - 0.5) * (bendRange*2);
    bendSemis = clamp(semi, -bendRange, bendRange);
    const pct = (0.5 - bendSemis/(bendRange*2)) * 100;
    marker.style.top = pct + '%';
    try{ synth?.setBend?.(bendSemis) }catch(e){}
  }
  function resetWheel(){ bendSemis = 0; try{ synth?.setBend?.(0) }catch(e){} marker.style.top='50%'; }
  wheel?.addEventListener('pointerdown', (e)=>{ active=true; wheel.setPointerCapture?.(e.pointerId); const r=wheel.getBoundingClientRect(); setBendFromY(e.clientY - r.top, r); });
  wheel?.addEventListener('pointermove', (e)=>{ if(!active) return; const r=wheel.getBoundingClientRect(); setBendFromY(e.clientY - r.top, r); });
  function upHandler(e){ if(!active) return; active=false; wheel.releasePointerCapture?.(e.pointerId); resetWheel(); }
  wheel?.addEventListener('pointerup', upHandler);
  wheel?.addEventListener('pointerleave', upHandler);

  const micro=document.getElementById('microBtn');
  micro?.addEventListener('click', ()=>{
    microMode = !microMode;
    bendRange = microMode ? 4 : 2;
    if(microMode){ micro.classList.add('micro-on'); } else { micro.classList.remove('micro-on'); }
    buildKeypad();
  });
}
/* ===== WebMIDI + CC Learn ===== */
let midiAccess=null; let midiLearn=false, learnTarget=null;
const MIDIMAP_KEY='stagsynth_midi_cc_map_v1'; let midiMapStore={ cc:{} };
function loadMidiMap(){ try{ const raw=localStorage.getItem(MIDIMAP_KEY); if(raw) midiMapStore=JSON.parse(raw)||{cc:{}}; }catch(e){} }
function saveMidiMap(){ try{ localStorage.setItem(MIDIMAP_KEY, JSON.stringify(midiMapStore)); }catch(e){} }
function setMidiState(t){ const el=document.getElementById('midiState'); if(el) el.textContent=t||''; }
async function connectMIDI(){
  try{
    const acc=await navigator.requestMIDIAccess({sysex:false}); midiAccess=acc;
    if(acc.inputs && acc.inputs.size>0){
      for(const input of acc.inputs.values()){ input.onmidimessage=onMIDI; }
      acc.onstatechange=(e)=>{
        if(e.port.type==='input'){ e.port.onmidimessage=onMIDI; const any=Array.from(acc.inputs.values()).some(p=>p.state==='connected'); setMidiState(any?'MIDI connected':'No MIDI inputs'); }
      };
      setMidiState('MIDI connected');
      document.getElementById('midiLearnBtn').disabled=false;
    }else{
      setMidiState('No MIDI inputs');
      document.getElementById('midiLearnBtn').disabled=true;
    }
  }catch(e){
    setMidiState('MIDI unavailable');
    document.getElementById('midiLearnBtn').disabled=true;
  }
}
function applyCCToElement(el, value){
  if(!el) return;
  if(el.tagName==='SELECT'){
    const opts=Array.from(el.options);
    const idx=Math.min(opts.length-1, Math.max(0, Math.round(value*(opts.length-1))));
    el.selectedIndex=idx; el.dispatchEvent(new Event('input',{bubbles:true})); pushParams();
  }else if(el.type==='checkbox'){
    el.checked = value >= 0.5; el.dispatchEvent(new Event('input',{bubbles:true}));
  }else{
    const min=parseFloat(el.min||'0'), max=parseFloat(el.max||'1');
    const val=min+(max-min)*value;
    el.value=String(val); el.dispatchEvent(new Event('input',{bubbles:true})); pushParams();
  }
}
let lastSeenCC=0;
function mapMidiNoteToMicro(midiNote){ const n=midiNote-60; return microMode ? (BASE_MIDI+n*0.5+12*octaveOffset) : (BASE_MIDI+n+12*octaveOffset); }
function onMIDI(ev){
  const [st,d1,d2]=ev.data; const cmd=st&0xF0;
  if(cmd===0x90 && d2>0){ const m=mapMidiNoteToMicro(d1); routeNoteOn(m, Math.max(.2,d2/127)); return; }
  if(cmd===0x80 || (cmd===0x90 && d2===0)){ const m=mapMidiNoteToMicro(d1); routeNoteOff(m); return; }
  if(cmd===0xE0){
    const lsb=d1|0, msb=d2|0; const value=(msb<<7)|lsb; const norm=(value-8192)/8192;
    bendSemis = clamp(norm*bendRange, -bendRange, bendRange);
    try{ synth?.setBend?.(bendSemis) }catch(e){}
    const marker=document.getElementById('bendMarker'); if(marker){ const pct=(0.5 - bendSemis/(bendRange*2))*100; marker.style.top=pct+'%'; }
    return;
  }
  if(cmd===0xB0){
    lastSeenCC=d1|0; const norm=(d2|0)/127;
    if(midiLearn && learnTarget){
      midiMapStore.cc[String(lastSeenCC)] = learnTarget; saveMidiMap();
      const msg=document.getElementById('midiState'); if(msg) msg.textContent='Mapped CC '+lastSeenCC+' ‚Üí '+learnTarget;
      document.querySelectorAll('[data-midicc]').forEach(e=>e.classList.remove('midi-learn-on'));
      learnTarget=null; midiLearn=false; document.getElementById('midiLearnBtn').classList.remove('midi-learn-on'); return;
    }
    const targetId=midiMapStore.cc[String(lastSeenCC)]; if(targetId){ const el=document.getElementById(targetId); applyCCToElement(el, norm); }
  }
}
function attachLearnClicks(){
  document.querySelectorAll('[data-midicc]').forEach(el=>{
    el.addEventListener('click', ()=>{
      if(!midiLearn) return;
      document.querySelectorAll('[data-midicc]').forEach(e=>e.classList.remove('midi-learn-on'));
      learnTarget=el.id; el.classList.add('midi-learn-on');
    });
  });
}

/* ===== Granular ===== */
let currentTakeBuffer=null, currentTakeName='';
let grainTicker=null, scanTicker=null, grainActive=null;
let granularOut=null;
const g={};
function setGranularStatus(t){ const el=document.getElementById('g_status'); if(el) el.textContent=t||''; }
function enableGranularButtons(){ const has=!!currentTakeBuffer; const gl=document.getElementById('g_takeList'); document.getElementById('g_saveTake').disabled=!has; document.getElementById('g_exportTake').disabled=!has; document.getElementById('g_deleteTake').disabled=!gl.value; }
function refreshTakeList(){
  const list=document.getElementById('g_takeList'); if(!list) return;
  const store=loadTakes(); const names=Object.keys(store).sort();
  const prev=list.value; list.innerHTML='';
  names.forEach(n=>{ const o=document.createElement('option'); o.value=n; o.textContent=n; list.appendChild(o); });
  list.value=prev && names.includes(prev) ? prev : (names[0]||'');
  enableGranularButtons();
  const del=document.getElementById('g_deleteTake');
  if(del) del.onclick=()=>{ const nm=list.value; if(!nm) return; const s=loadTakes(); delete s[nm]; saveTakes(s); refreshTakeList(); setGranularStatus('Deleted '+nm); };
}
function encodeWAVFromBuffer(buf){
  const nCh=buf.numberOfChannels, len=buf.length, sr=buf.sampleRate;
  const dataLen=len*nCh*2; const total=dataLen+44;
  const ab=new ArrayBuffer(total), v=new DataView(ab);
  function w(off,str){ for(let i=0;i<str.length;i++) v.setUint8(off+i,str.charCodeAt(i)); }
  w(0,'RIFF'); v.setUint32(4,total-8,true); w(8,'WAVE'); w(12,'fmt '); v.setUint32(16,16,true); v.setUint16(20,1,true); v.setUint16(22,nCh,true); v.setUint32(24,sr,true); v.setUint32(28,sr*2*nCh,true); v.setUint16(32,2*nCh,true); v.setUint16(34,16,true); w(36,'data'); v.setUint32(40,dataLen,true);
  let pos=44; const ch=[]; for(let c=0;c<nCh;c++) ch.push(buf.getChannelData(c));
  for(let i=0;i<len;i++){ for(let c=0;c<nCh;c++){ let s=Math.max(-1,Math.min(1,ch[c][i])); v.setInt16(pos, s<0?s*0x8000:s*0x7FFF, true); pos+=2; } }
  return ab;
}
async function saveCurrentTake(){
  if(!currentTakeBuffer) return;
  const nm=prompt('Take name:', currentTakeName||('Take '+new Date().toLocaleTimeString())); if(!nm) return;
  const wav=encodeWAVFromBuffer(currentTakeBuffer);
  const b64=u8ToB64(new Uint8Array(wav));
  const s=loadTakes(); s[nm]={ wavB64:b64, sampleRate: currentTakeBuffer.sampleRate }; saveTakes(s);
  refreshTakeList(); setGranularStatus('Saved "'+nm+'"');
}
function exportCurrentTake(){
  if(!currentTakeBuffer) return;
  const wav=encodeWAVFromBuffer(currentTakeBuffer); const blob=new Blob([wav],{type:'audio/wav'});
  const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=(currentTakeName||'take')+'.wav'; a.click(); setTimeout(()=>URL.revokeObjectURL(url),1e3);
}
async function loadSelectedTake(){
  const nm=document.getElementById('g_takeList').value; if(!nm) return;
  const s=loadTakes(); const rec=s[nm]; if(!rec) return;
  const bin=atob(rec.wavB64); const u8=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) u8[i]=bin.charCodeAt(i);
  await ensureAudio(); const ab=await audioCtx.decodeAudioData(u8.buffer.slice(0)); currentTakeBuffer=ab; currentTakeName=nm; setGranularStatus('Loaded "'+nm+'" ('+ab.duration.toFixed(2)+'s)'); enableGranularButtons();
}
function startGranular(){
  if(!currentTakeBuffer||!audioCtx){ setGranularStatus('No take'); return; }
  stopGranular(true);
  granularOut=audioCtx.createGain(); granularOut.gain.value=parseFloat(g['g_gain'].value||'0.7');
  granularOut.connect(mixNode);
  grainActive=new Set();
  let posPct=(parseFloat(g['g_pos'].value)||0)/100;
  let last=audioCtx.currentTime; let acc=0;
  const buf=currentTakeBuffer;
  function read(){ return { loop:g['g_loop'].checked, freeze:g['g_freeze'].checked, sizeSec:Math.max(.01,(parseFloat(g['g_size'].value)||120)/1000), density:Math.max(1,(parseFloat(g['g_density'].value)||30)), spray:(parseFloat(g['g_spray'].value)||15)/1000, rate:Math.max(.05,parseFloat(g['g_rate'].value)||1), gain:Math.max(0,parseFloat(g['g_gain'].value)||.7), scan:(parseFloat(g['g_scan'].value)||10)/100 }; }
  function spawn(t,P){
    let start=posPct*buf.duration + (Math.random()*2-1)*P.spray;
    if(P.loop){ while(start<0) start+=buf.duration; while(start>buf.duration) start-=buf.duration; } else { if(start<0||start>=buf.duration) return; }
    const dur=P.sizeSec;
    const src=audioCtx.createBufferSource(); src.buffer=buf; src.playbackRate.value=P.rate;
    const gNode=audioCtx.createGain(); gNode.gain.value=0.0;
    src.connect(gNode).connect(granularOut);
    grainActive.add(src);
    const t0=t, t1=t0+Math.max(.003,dur*.25), t2=t0+Math.max(.006,dur*.75), t3=t0+dur;
    gNode.gain.setValueAtTime(0.0,t0); gNode.gain.linearRampToValueAtTime(P.gain,t1); gNode.gain.linearRampToValueAtTime(P.gain,t2); gNode.gain.linearRampToValueAtTime(0.0,t3);
    try{ src.start(t0, Math.max(0,start), dur); src.stop(t3+.05); }catch(e){}
    src.onended=()=>{ try{ grainActive.delete(src); }catch(e){} };
  }
  grainTicker=setInterval(()=>{
    const now=audioCtx.currentTime; const dt=Math.max(.005, now-last); last=now;
    const P=read();
    acc += P.density*dt; const n=(acc|0); acc-=n;
    for(let i=0;i<n;i++) spawn(now+.02+i*.002,P);
  },20);
  scanTicker=setInterval(()=>{
    const P=read();
    if(!P.freeze){ posPct += P.scan*.02; if(P.loop){ while(posPct<0) posPct+=1; while(posPct>1) posPct-=1; } else { posPct=clamp(posPct,0,1); } document.getElementById('g_pos').value=(posPct*100).toFixed(1); }
  },20);
  setGranularStatus('Granular: playing');
}
function stopGranular(hard=false){
  try{ clearInterval(grainTicker); clearInterval(scanTicker); }catch(e){}
  grainTicker=null; scanTicker=null;
  if(hard && grainActive){ try{ grainActive.forEach(s=>{ try{s.stop(0);}catch(e){} }); grainActive.clear(); }catch(e){} }
  try{ if(granularOut){ granularOut.disconnect(); granularOut=null; } }catch(e){}
  setGranularStatus('Granular: stopped');
}
function bindGranularPanel(){
  ['g_pos','g_scan','g_size','g_overlap','g_density','g_spray','g_rate','g_gain','g_loop','g_freeze'].forEach(id=> g[id]=document.getElementById(id));
  const recA=document.getElementById('g_startRec');
  const recB=document.getElementById('g_stopRec');
  const save=document.getElementById('g_saveTake');
  const imp=document.getElementById('g_importFile');
  const file=document.getElementById('g_file');
  const exp=document.getElementById('g_exportTake');
  const play=document.getElementById('g_play');
  const stop=document.getElementById('g_stop');
  const list=document.getElementById('g_takeList');
  recA.onclick=()=>{ ensureAudio().then(()=>{ startTopRecording(); recA.disabled=true; recB.disabled=false; }); };
  recB.onclick=()=>{ stopTopRecording(); recA.disabled=false; recB.disabled=true; };
  save.onclick=saveCurrentTake;
  imp.onclick=()=>file.click();
  file.onchange=async()=>{ const f=file.files?.[0]; if(!f) return; const arr=await f.arrayBuffer(); await ensureAudio(); const buf=await audioCtx.decodeAudioData(arr.slice(0)); currentTakeBuffer=buf; currentTakeName=f.name.replace(/\.[^/.]+$/,'')||'Imported'; enableGranularButtons(); setGranularStatus('Loaded file '+currentTakeName); refreshTakeList(); file.value=''; };
  exp.onclick=exportCurrentTake;
  play.onclick=()=> startGranular();
  stop.onclick=()=> stopGranular();
  list.onchange=loadSelectedTake;
  refreshTakeList(); enableGranularButtons();
}

/* ===== Sampler ===== */
const SAMPLER_KEY='stagsynth_sampler_v3';
let samplerLib={}; let samplerCurrent={name:'',buffer:null,root:60};
let samplerVoices=new Map(); let samplerBus={out:null, filter:null};
function loadSamplerLib(){ try{ samplerLib=JSON.parse(localStorage.getItem(SAMPLER_KEY)||'{}'); }catch{ samplerLib={}; } }
function saveSamplerLib(){ try{ localStorage.setItem(SAMPLER_KEY, JSON.stringify(samplerLib)); }catch(e){} }
function refreshSamplerList(selName){
  const list=document.getElementById('sam_list'); if(!list) return;
  const names=Object.keys(samplerLib).sort(); const prev=list.value; list.innerHTML=''; names.forEach(n=>{ const o=document.createElement('option'); o.value=n; o.textContent=n; list.appendChild(o); });
  list.value = selName ? selName : (prev || list.value);
  document.getElementById('sam_delete').disabled = !list.value;
  document.getElementById('sam_export').disabled = !list.value;
  document.getElementById('sam_save').disabled = !samplerCurrent.buffer;
}
async function decodeB64ToBuffer(b64){
  const bin=atob(b64); const u8=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) u8[i]=bin.charCodeAt(i);
  await ensureAudio(); return audioCtx.decodeAudioData(u8.buffer.slice(0));
}
async function samplerLoadByName(nm){
  const rec=samplerLib[nm]; if(!rec) return;
  const buf=await decodeB64ToBuffer(rec.wavB64);
  samplerCurrent={ name:nm, buffer:buf, root:rec.root||60 };
  document.getElementById('sam_name').value=nm;
  document.getElementById('sam_root').value=String(rec.root||60);
  setSamStatus('Loaded '+nm+' ('+buf.duration.toFixed(2)+'s)');
  document.getElementById('sam_save').disabled=false;
}
function initSamplerBus(){
  if(!audioCtx) return;
  try{ if(samplerBus.out && samplerBus.out.context !== audioCtx) samplerBus={out:null,filter:null}; }catch(e){}
  if(samplerBus.out) return;
  const out=audioCtx.createGain(); out.gain.value=parseFloat(document.getElementById('sam_gain').value||'0.9');
  const filter=audioCtx.createBiquadFilter(); filter.type='lowpass'; filter.frequency.value=parseFloat(document.getElementById('sam_cut').value||'10000'); filter.Q.value=parseFloat(document.getElementById('sam_q').value||'0')*20;
  out.connect(filter).connect(mixNode);
  samplerBus={out,filter};
}
function setSamStatus(t){ const el=document.getElementById('sam_status'); if(el) el.textContent=t||''; }
function bindSamplerPanel(){
  const panel=document.getElementById('samplerPanel');
  const toggle=document.getElementById('samplerToggle');
  toggle.onclick=()=>{ const open=panel.classList.toggle('open'); toggle.setAttribute('aria-expanded',open?'true':'false'); if(open){ ensureAudio().then(initSamplerBus); } };
  loadSamplerLib(); refreshSamplerList();
  const list=document.getElementById('sam_list');
  list.onchange=()=>{ const nm=list.value; if(nm){ samplerLoadByName(nm); } refreshSamplerList(nm); };
  document.getElementById('sam_fromGranular').onclick=async()=>{
    if(!currentTakeBuffer){ setSamStatus('No granular take'); return; } await ensureAudio(); initSamplerBus();
    samplerCurrent={ name:'Granular '+new Date().toLocaleTimeString(), buffer:currentTakeBuffer, root:parseInt(document.getElementById('sam_root').value||'60')|0 };
    document.getElementById('sam_name').value=samplerCurrent.name; document.getElementById('sam_save').disabled=false; setSamStatus('Loaded from granular');
  };
  document.getElementById('sam_import').onclick=()=>document.getElementById('sam_file').click();
  document.getElementById('sam_file').onchange=async(e)=>{
    const f=e.target.files?.[0]; if(!f) return;
    const arr=await f.arrayBuffer(); await ensureAudio(); initSamplerBus();
    const ab=await audioCtx.decodeAudioData(arr.slice(0));
    samplerCurrent={ name:f.name.replace(/\.[^/.]+$/,''), buffer:ab, root:parseInt(document.getElementById('sam_root').value||'60')|0 };
    document.getElementById('sam_name').value=samplerCurrent.name; document.getElementById('sam_save').disabled=false;
    refreshSamplerList(); setSamStatus('Imported '+samplerCurrent.name); e.target.value='';
  };
  document.getElementById('sam_save').onclick=()=>{
    if(!samplerCurrent.buffer) return; const nm=(document.getElementById('sam_name').value||'Sample').trim(); const root=parseInt(document.getElementById('sam_root').value||'60')|0;
    const wav=encodeWAVFromBuffer(samplerCurrent.buffer); const b64=u8ToB64(new Uint8Array(wav));
    samplerLib[nm]={ wavB64:b64, sampleRate:samplerCurrent.buffer.sampleRate, root }; saveSamplerLib(); refreshSamplerList(nm); setSamStatus('Saved "'+nm+'"');
  };
  document.getElementById('sam_delete').onclick=()=>{ const nm=list.value; if(!nm) return; delete samplerLib[nm]; saveSamplerLib(); refreshSamplerList(); setSamStatus('Deleted '+nm); };
  document.getElementById('sam_export').onclick=()=>{
    const nm=list.value; const rec=samplerLib[nm]; if(!rec) return;
    const bin=atob(rec.wavB64); const u8=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) u8[i]=bin.charCodeAt(i);
    const blob=new Blob([u8.buffer],{type:'audio/wav'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=(nm||'sample')+'.wav'; a.click(); setTimeout(()=>URL.revokeObjectURL(url),1000);
  };
  ['sam_gain','sam_cut','sam_q'].forEach(id=> document.getElementById(id)?.addEventListener('input', ()=>{
    if(!audioCtx) return; initSamplerBus();
    if(id==='sam_gain') samplerBus.out.gain.value=parseFloat(document.getElementById('sam_gain').value||'0.9');
    if(id==='sam_cut')  samplerBus.filter.frequency.value=Math.max(60,parseFloat(document.getElementById('sam_cut').value||'10000'));
    if(id==='sam_q')    samplerBus.filter.Q.value=Math.max(0,Math.min(20,parseFloat(document.getElementById('sam_q').value||'0')*20));
  }));
}
function samplerEnv(){ const clamp01=x=>Math.max(0,Math.min(1,x)); return { a:Math.max(.001,parseFloat(document.getElementById('sam_a').value||'0.005')), d:Math.max(.001,parseFloat(document.getElementById('sam_d').value||'0.08')), s:clamp01(parseFloat(document.getElementById('sam_s').value||'0.8')), r:Math.max(.001,parseFloat(document.getElementById('sam_r').value||'0.2')) }; }
function samplerMode(){ const sel=document.getElementById('sam_mode'); return sel? sel.value : 'off'; }
function samplerNoteOn(m,vel=0.9){
  if(!samplerCurrent.buffer || samplerMode()==='off') return; initSamplerBus();
  const buf=samplerCurrent.buffer; const root=parseInt(document.getElementById('sam_root').value||String(samplerCurrent.root||60))|0;
  const cents=parseFloat(document.getElementById('sam_tune').value||'0')||0; const semi=(m-root)+(cents/100);
  const rate=Math.pow(2,semi/12);
  const startPct=Math.max(0,Math.min(.99,parseFloat(document.getElementById('sam_start').value||'0')/100));
  const endPct=Math.max(startPct+.005,Math.min(1,parseFloat(document.getElementById('sam_end').value||'100')/100));
  const start=startPct*buf.duration; const dur=Math.max(.01,(endPct-startPct)*buf.duration);
  const src=audioCtx.createBufferSource(); src.buffer=buf; src.playbackRate.value=rate; src.loop=!!document.getElementById('sam_loop').checked; if(src.loop){ src.loopStart=start; src.loopEnd=start+dur; }
  const g=audioCtx.createGain(); g.gain.value=1e-5;
  const e=samplerEnv(); const t=audioCtx.currentTime; const peak=.8*vel*parseFloat(document.getElementById('sam_gain').value||'0.9');
  g.gain.setValueAtTime(1e-5,t); g.gain.linearRampToValueAtTime(peak,t+e.a); g.gain.linearRampToValueAtTime(peak*e.s,t+e.a+e.d);
  src.connect(g).connect(samplerBus.out);
  const key=Math.round(m*2)/2; samplerVoices.set(key,{src,g,e});
  try{ src.start(t,start,dur); }catch(e){}
}
function samplerNoteOff(m){
  const key=Math.round(m*2)/2; const v=samplerVoices.get(key); if(!v) return;
  const t=audioCtx.currentTime; const stopAt=t+v.e.r+.02;
  v.g.gain.cancelScheduledValues(t); v.g.gain.setValueAtTime(v.g.gain.value,t); v.g.gain.linearRampToValueAtTime(1e-5,stopAt);
  try{ v.src.stop(stopAt+.01); }catch(e){} setTimeout(()=>samplerVoices.delete(key),Math.max(10,(stopAt-audioCtx.currentTime)*1000));
}
function killSamplerAll(){ for(const [k,v] of samplerVoices.entries()){ try{ v.src.stop(0); }catch(e){} } samplerVoices.clear(); }

/* ===== Routing ===== */
function routeNoteOn(m,amp){ ensureAudio().then(()=>{ const mode=samplerMode(); if(mode==='sampler'||mode==='both') samplerNoteOn(m,amp); if(mode!=='sampler') synth?.noteOn(m,amp); }); }
function routeNoteOff(m){ try{ const mode=samplerMode(); if(mode==='sampler'||mode==='both') samplerNoteOff(m); if(mode!=='sampler') synth?.noteOff(m); }catch(e){} }

/* ===== Header & main ===== */
function measureTopbar(){
  const tb=document.getElementById('topbar');
  const h=tb ? tb.getBoundingClientRect().height : 60;
  document.documentElement.style.setProperty('--tb', Math.round(h)+'px');
}
function bindHeader(){
  measureTopbar();
  window.addEventListener('resize', measureTopbar);
  document.getElementById('startBtn').onclick=()=>ensureAudio();
  document.getElementById('resetBtn').onclick=()=>hardResetAudio();
  document.getElementById('midiBtn').onclick=()=>ensureAudio().then(connectMIDI);
  const st=document.getElementById('synthToggle'), sp=document.getElementById('synthPanel'); st.onclick=()=>{ const o=sp.classList.toggle('open'); st.setAttribute('aria-expanded',o?'true':'false'); };
  const gt=document.getElementById('granularToggle'), gp=document.getElementById('granularPanel'); gt.onclick=()=>{ const o=gp.classList.toggle('open'); gt.setAttribute('aria-expanded',o?'true':'false'); };
  const sat=document.getElementById('samplerToggle'), sap=document.getElementById('samplerPanel'); sat.onclick=()=>{ const o=sap.classList.toggle('open'); sat.setAttribute('aria-expanded',o?'true':'false'); if(o){ ensureAudio().then(initSamplerBus);} };
  
const ct=document.getElementById('customToggle'), cp=document.getElementById('customPanel');
if(ct && cp){
  ct.onclick=()=>{
    const o=cp.classList.toggle('open');
    ct.setAttribute('aria-expanded', o?'true':'false');
    if(o){
      document.querySelectorAll('.synth-panel').forEach(p=>{ if(p!==cp) p.classList.remove('open'); });
    }
  };
}
  const rec=document.getElementById('recBtn'); rec.onclick=()=>{ ensureAudio().then(()=>{ if(!mediaRecorder||mediaRecorder.state!=='recording') startTopRecording(); else stopTopRecording(); }); };

  const ml=document.getElementById('midiLearnBtn');
  ml.onclick=()=>{ if(ml.disabled) return; midiLearn=!midiLearn; learnTarget=null; if(midiLearn) ml.classList.add('midi-learn-on'); else ml.classList.remove('midi-learn-on'); document.getElementById('midiState').textContent = midiLearn ? 'Click a control, then move a CC' : 'MIDI map off'; };
}
function bindMain(){
  const rd=document.getElementById('octReadout');
  document.getElementById('octUp').onclick=()=>{ octaveOffset=clamp(octaveOffset+1,-2,2); rd.textContent=String(octaveOffset); buildKeypad(); };
  document.getElementById('octDown').onclick=()=>{ octaveOffset=clamp(octaveOffset-1,-2,2); rd.textContent=String(octaveOffset); buildKeypad(); };
  buildKeypad(); bindKeyboard(); bindBendAndMicro();
  [
   'shape','subShape','detune','subDetune','mode','cutoff','resonance','a','d','s','r','drive','mix','subLevel','subOctave','noiseColor',
   'fx_rev_room','fx_rev_decay','fx_rev_predelay','fx_rev_damp','fx_rev_mix',
   'fx_ch_rate','fx_ch_depth','fx_ch_voices','fx_ch_width','fx_ch_mix',
   'fx_dist_type','fx_dist_drive','fx_dist_tone','fx_dist_mix',
   'fx_comp_thr','fx_comp_ratio','fx_comp_att','fx_comp_rel','fx_comp_makeup',
   'fx_bc_bits','fx_bc_rate','fx_bc_mix',
   'fx_rm_freq','fx_rm_wave','fx_rm_depth','fx_rm_mix'
  ].forEach(id=> document.getElementById(id)?.addEventListener('input',pushParams));
  attachLearnClicks();
}
function main(){ loadPresetStore(); loadTakes(); bindHeader(); bindMain(); initPresets(); bindGranularPanel(); bindSamplerPanel(); loadMidiMap(); }
document.addEventListener('DOMContentLoaded', main);

/* ==== Low Latency Mode (robust toggle, desktop + mobile) ==== */
(() => {
  if (window.__LL_FINAL_PATCH__) return; window.__LL_FINAL_PATCH__ = true;

  let LOW_LATENCY = false;
  let _lastToggleAt = 0;

  function reflectButton(on){
    const el = document.getElementById('llToggleOverlay');
    if(!el) return;
    el.classList.toggle('ll-on', on);
    el.setAttribute('aria-pressed', on ? 'true' : 'false');
    el.setAttribute('aria-checked', on ? 'true' : 'false');
  }

  function applyLowLatencyTweaks(on){
    LOW_LATENCY = !!on;
    reflectButton(LOW_LATENCY);

    try{ if (typeof ai!=='undefined' && ai && ai.tap) ai.tap.fftSize = on ? 512 : 2048; }catch(e){}
    try{ if (window.rec && window.rec.dest && !window.rec.active){ try{ window.rec.dest.disconnect(); }catch(e){} } }catch(e){}
    try{
      if (window.comp){
        window._compAttackDefault = window._compAttackDefault ?? comp.attack;
        window._compReleaseDefault = window._compReleaseDefault ?? comp.release;
        comp.attack = on ? 0.001 : window._compAttackDefault;
        comp.release = on ? 0.06  : window._compReleaseDefault;
      }
    }catch(e){}
    try{
      const chRate=document.getElementById('fx_ch_rate');
      const chDepth=document.getElementById('fx_ch_depth');
      if(on){
        if(chDepth){ const v=Math.min(parseFloat(chDepth.value)||6,6); if(v!=parseFloat(chDepth.value||0)){ chDepth.value=String(v); chDepth.dispatchEvent(new Event('input',{bubbles:true})); } }
        if(chRate){ const v=Math.min(parseFloat(chRate.value)||2,2); if(v!=parseFloat(chRate.value||0)){ chRate.value=String(v); chRate.dispatchEvent(new Event('input',{bubbles:true})); } }
      }
    }catch(e){}
    try{ window._bcLazy = on; }catch(e){}

    if (window.DEBUG_LL) console.log('[LL] state =', LOW_LATENCY);
  }

  function bindLL(){
    const btn = document.getElementById('llToggleOverlay');
    if(!btn) return;
    const onPointerUp = (e) => {
      const now = performance.now();
      if (now - _lastToggleAt < 150) return; // debounce
      _lastToggleAt = now;
      e.preventDefault();
      e.stopPropagation();
      applyLowLatencyTweaks(!LOW_LATENCY);
    };
    const clone = btn.cloneNode(true);
    btn.parentNode.replaceChild(clone, btn);
    clone.addEventListener('pointerup', onPointerUp, {passive:false, capture:true});
    clone.addEventListener('click', onPointerUp, {passive:false, capture:true});
    clone.addEventListener('keydown', (ev)=>{ ev.stopPropagation(); }, {capture:true});
  }

  const _ensure = window.ensureAudio;
  if(typeof _ensure === 'function'){
    window.ensureAudio = function(){
      return _ensure().then(()=>{ bindLL(); });
    }
  }

  document.addEventListener('DOMContentLoaded', bindLL, {once:true});
  window.toggleLL = (on)=> applyLowLatencyTweaks(on==null ? !LOW_LATENCY : !!on);
})();
</script>


<script>
(function(){
  let vocCtx={ inited:false, bands:[], modStream:null, modSrc:null, modPre:null, sibHP:null, sibGain:null, envLPs:[], carBPFs:[], modBPFs:[], vcaGains:[], wet:null, dry:null, out:null, sum:null, carIn:null, modGate:null, modGain:null, carrierSel:'off' };
  function hzForBand(i,N,lo,hi,semi){ const f=lo*Math.pow(hi/lo,i/(N-1)); return f*Math.pow(2,(semi||0)/12); }

  async function ensureMic(){ if(vocCtx.modSrc) return true; try{ const ms=await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:false,noiseSuppression:false,autoGainControl:false},video:false}); vocCtx.modStream=ms; await ensureAudio(); const a=audioCtx; vocCtx.modSrc=a.createMediaStreamSource(ms); vocCtx.modGain=a.createGain(); vocCtx.modGain.gain.value=parseFloat(document.getElementById('voc_mod_gain').value||1); vocCtx.modPre=a.createBiquadFilter(); vocCtx.modPre.type='highpass'; vocCtx.modPre.frequency.value=90; vocCtx.modGate=a.createDynamicsCompressor(); vocCtx.modGate.threshold.value=parseFloat(document.getElementById('voc_gate').value||-70); vocCtx.modGate.ratio.value=20; vocCtx.modGate.knee.value=0; vocCtx.modGate.attack.value=0.005; vocCtx.modGate.release.value=0.25; vocCtx.modSrc.connect(vocCtx.modGain).connect(vocCtx.modPre).connect(vocCtx.modGate); return true; }catch(e){ const s=document.getElementById('voc_status'); if(s) s.textContent='Mic permission denied'; return false; } }

  function destroyBands(){ vocCtx.bands.forEach(b=>{ try{ b.modBPF.disconnect(); b.carBPF.disconnect(); b.envRect?.disconnect(); b.envLP.disconnect(); b.vca.disconnect(); }catch(e){} }); vocCtx.bands=[]; try{ vocCtx.sum?.disconnect(); }catch(e){} }

  function rebuildVocoder(){ if(!window.audioCtx) return; const a=audioCtx; destroyBands(); if(!vocCtx.wet){ vocCtx.wet=a.createGain(); } if(!vocCtx.dry){ vocCtx.dry=a.createGain(); } if(!vocCtx.out){ vocCtx.out=a.createGain(); } if(!vocCtx.sum){ vocCtx.sum=a.createGain(); vocCtx.sum.gain.value=1; }
    const N=parseInt(document.getElementById('voc_bands').value||12,10), lo=parseFloat(document.getElementById('voc_lo').value||200), hi=parseFloat(document.getElementById('voc_hi').value||5000), Q=parseFloat(document.getElementById('voc_q').value||2.0), sh=parseFloat(document.getElementById('voc_shift').value||0), att=Math.max(0.0005,(parseFloat(document.getElementById('voc_att').value||12))/1000), rel=Math.max(0.005,(parseFloat(document.getElementById('voc_rel').value||160))/1000);
    vocCtx.wet.gain.value=parseFloat(document.getElementById('voc_mix').value||0); vocCtx.dry.gain.value=1-vocCtx.wet.gain.value; vocCtx.out.gain.value=parseFloat(document.getElementById('voc_out').value||1);
    if(!vocCtx.sibHP){ vocCtx.sibHP=a.createBiquadFilter(); vocCtx.sibHP.type='highpass'; vocCtx.sibHP.frequency.value=5000; } if(!vocCtx.sibGain){ vocCtx.sibGain=a.createGain(); } vocCtx.sibGain.gain.value=parseFloat(document.getElementById('voc_sib').value||0.15);
    for(let i=0;i<N;i++){ const fc=hzForBand(i,N,lo,hi,sh); const modBPF=a.createBiquadFilter(); modBPF.type='bandpass'; modBPF.Q.value=Q; modBPF.frequency.value=fc; const carBPF=a.createBiquadFilter(); carBPF.type='bandpass'; carBPF.Q.value=Q; carBPF.frequency.value=fc; const rect=a.createWaveShaper(); const n=2048,curve=new Float32Array(n); for(let j=0;j<n;j++){ const x=j/(n-1)*2-1; curve[j]=Math.abs(x);} rect.curve=curve; rect.oversample='2x'; const envLP=a.createBiquadFilter(); envLP.type='lowpass'; envLP.frequency.value=1/(2*Math.PI*att)*0.25; const vca=a.createGain(); vca.gain.value=0; vocCtx.modGate.connect(modBPF).connect(rect).connect(envLP); envLP.connect(vca.gain); vocCtx.carIn.connect(carBPF).connect(vca).connect(vocCtx.sum); vocCtx.bands.push({modBPF,carBPF,envRect:rect,envLP,vca}); }
    vocCtx.modGate.connect(vocCtx.sibHP).connect(vocCtx.sibGain).connect(vocCtx.sum);
    try{ vocCtx.wet.disconnect(); vocCtx.dry.disconnect(); vocCtx.out.disconnect(); }catch(e){}
    vocCtx.sum.connect(vocCtx.wet).connect(vocCtx.out).connect(mixNode);
  }

  function waitForSynthBusAndWire(maxMs=4000){
    const t0=performance.now();
    (function tick(){
      const bus=window._stagsynth_synthBus;
      if(bus && vocCtx?.carIn){ try{ vocCtx.carIn.disconnect(); }catch(e){} bus.connect(vocCtx.carIn); console.log('[voc] carrier wired to synthBus'); return; }
      if(performance.now()-t0<maxMs) requestAnimationFrame(tick);
    })();
  }

  function setCarrier(sel){
    vocCtx.carrierSel=sel; if(!window.audioCtx) return;
    if(!vocCtx.carIn){ vocCtx.carIn=audioCtx.createGain(); vocCtx.carIn.gain.value=1; }
    try{ vocCtx.carIn.disconnect(); }catch(e){}
    const synthBus=window._stagsynth_synthBus;
    const samOut=(typeof samplerBus==='object' && samplerBus.out) ? samplerBus.out : null;
    if(sel==='synth'){ if(synthBus) synthBus.connect(vocCtx.carIn); else waitForSynthBusAndWire(); }
    else if(sel==='sampler'){ if(samOut) samOut.connect(vocCtx.carIn); }
    else if(sel==='both'){ if(synthBus) synthBus.connect(vocCtx.carIn); else waitForSynthBusAndWire(); if(samOut) samOut.connect(vocCtx.carIn); }
  }

  async function enableVocoderIfNeeded(){
    const sel=document.getElementById('voc_carrier').value;
    const needOn=(sel!=='off'); if(!needOn) return;
    await ensureAudio(); const ok=await ensureMic(); if(!ok) return;
    if(!vocCtx.inited){ vocCtx.inited=true; }
    setCarrier(sel); rebuildVocoder();
    const s=document.getElementById('voc_status'); if(s) s.textContent='Vocoder ready';
  }

  // Bind UI
  document.addEventListener('DOMContentLoaded',()=>{
    const btn=document.getElementById('vocoderToggle');
    const panel=document.getElementById('vocoderPanel');
    if(btn && panel){
      btn.onclick=()=>{ const o=panel.classList.toggle('open'); btn.setAttribute('aria-expanded', o?'true':'false'); if(o) enableVocoderIfNeeded(); };
    }
    const id=s=>document.getElementById(s);
    id('voc_carrier')?.addEventListener('change', async ()=>{ await enableVocoderIfNeeded(); setCarrier(vocCtx.carrierSel); });
    ['voc_bands','voc_lo','voc_hi','voc_q','voc_shift','voc_att','voc_rel','voc_sib'].forEach(k=> id(k)?.addEventListener('input', ()=>{ if(vocCtx.carrierSel!=='off'){ rebuildVocoder(); }}));
    id('voc_mix')?.addEventListener('input', ()=>{ const mix=parseFloat(id('voc_mix').value||0); if(vocCtx.wet) vocCtx.wet.gain.value=mix; if(vocCtx.dry) vocCtx.dry.gain.value=1-mix; });
    id('voc_out')?.addEventListener('input', ()=>{ if(vocCtx.out) vocCtx.out.gain.value=parseFloat(id('voc_out').value||1); });
    id('voc_mod_gain')?.addEventListener('input', ()=>{ if(vocCtx.modGain) vocCtx.modGain.gain.value=parseFloat(id('voc_mod_gain').value||1); });
    id('voc_gate')?.addEventListener('input', ()=>{ if(vocCtx.modGate) vocCtx.modGate.threshold.value=parseFloat(id('voc_gate').value||-70); });
    id('voc_att')?.addEventListener('input', ()=>{ if(vocCtx.carrierSel!=='off') rebuildVocoder(); });
    id('voc_rel')?.addEventListener('input', ()=>{ if(vocCtx.carrierSel!=='off') rebuildVocoder(); });
    id('voc_test')?.addEventListener('click', async ()=>{ const ok=await ensureMic(); const s=id('voc_status'); if(s) s.textContent= ok ? 'Mic OK' : 'Mic blocked'; });
  });
})();
</script>



<!-- Vocoder engine -->
<script>
(function(){
  let vocCtx={ inited:false, bands:[], modStream:null, modSrc:null, modPre:null, sibHP:null, sibGain:null, envLPs:[], carBPFs:[], modBPFs:[], vcaGains:[], wet:null, dry:null, out:null, sum:null, carIn:null, modGate:null, modGain:null, carrierSel:'off' };
  function hzForBand(i,N,lo,hi,semi){ const f=lo*Math.pow(hi/lo,i/(N-1)); return f*Math.pow(2,(semi||0)/12); }

  async function ensureMic(){
    if(vocCtx.modSrc) return true;
    try{
      const ms=await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:false,noiseSuppression:false,autoGainControl:false},video:false});
      vocCtx.modStream=ms;
      await ensureAudio();
      const a=audioCtx;
      vocCtx.modSrc=a.createMediaStreamSource(ms);
      vocCtx.modGain=a.createGain(); vocCtx.modGain.gain.value=parseFloat(document.getElementById('voc_mod_gain').value||1);
      vocCtx.modPre=a.createBiquadFilter(); vocCtx.modPre.type='highpass'; vocCtx.modPre.frequency.value=90;
      vocCtx.modGate=a.createDynamicsCompressor();
      vocCtx.modGate.threshold.value=parseFloat(document.getElementById('voc_gate').value||-70);
      vocCtx.modGate.ratio.value=20; vocCtx.modGate.knee.value=0; vocCtx.modGate.attack.value=0.005; vocCtx.modGate.release.value=0.25;
      vocCtx.modSrc.connect(vocCtx.modGain).connect(vocCtx.modPre).connect(vocCtx.modGate);
      return true;
    }catch(e){
      const s=document.getElementById('voc_status'); if(s) s.textContent='Mic permission denied';
      return false;
    }
  }

  function destroyBands(){
    vocCtx.bands.forEach(b=>{ try{ b.modBPF.disconnect(); b.carBPF.disconnect(); b.envRect?.disconnect(); b.envLP.disconnect(); b.vca.disconnect(); }catch(e){} });
    vocCtx.bands=[]; try{ vocCtx.sum?.disconnect(); }catch(e){}
  }

  function rebuildVocoder(){
    if(!window.audioCtx) return;
    const a=audioCtx;
    destroyBands();
    if(!vocCtx.wet){ vocCtx.wet=a.createGain(); }
    if(!vocCtx.dry){ vocCtx.dry=a.createGain(); }
    if(!vocCtx.out){ vocCtx.out=a.createGain(); }
    if(!vocCtx.sum){ vocCtx.sum=a.createGain(); vocCtx.sum.gain.value=1; }

    const N=parseInt(document.getElementById('voc_bands').value||12,10),
          lo=parseFloat(document.getElementById('voc_lo').value||200),
          hi=parseFloat(document.getElementById('voc_hi').value||5000),
          Q=parseFloat(document.getElementById('voc_q').value||2.0),
          sh=parseFloat(document.getElementById('voc_shift').value||0),
          att=Math.max(0.0005,(parseFloat(document.getElementById('voc_att').value||12))/1000),
          rel=Math.max(0.005,(parseFloat(document.getElementById('voc_rel').value||160))/1000);

    vocCtx.wet.gain.value=parseFloat(document.getElementById('voc_mix').value||0);
    vocCtx.dry.gain.value=1-vocCtx.wet.gain.value;
    vocCtx.out.gain.value=parseFloat(document.getElementById('voc_out').value||1);

    if(!vocCtx.sibHP){ vocCtx.sibHP=a.createBiquadFilter(); vocCtx.sibHP.type='highpass'; vocCtx.sibHP.frequency.value=5000; }
    if(!vocCtx.sibGain){ vocCtx.sibGain=a.createGain(); }
    vocCtx.sibGain.gain.value=parseFloat(document.getElementById('voc_sib').value||0.15);

    for(let i=0;i<N;i++){
      const fc=hzForBand(i,N,lo,hi,sh);
      const modBPF=a.createBiquadFilter(); modBPF.type='bandpass'; modBPF.Q.value=Q; modBPF.frequency.value=fc;
      const carBPF=a.createBiquadFilter(); carBPF.type='bandpass'; carBPF.Q.value=Q; carBPF.frequency.value=fc;
      const rect=a.createWaveShaper(); const n=2048,curve=new Float32Array(n); for(let j=0;j<n;j++){ const x=j/(n-1)*2-1; curve[j]=Math.abs(x);} rect.curve=curve; rect.oversample='2x';
      const envLP=a.createBiquadFilter(); envLP.type='lowpass'; envLP.frequency.value=1/(2*Math.PI*att)*0.25;
      const vca=a.createGain(); vca.gain.value=0;
      vocCtx.modGate.connect(modBPF).connect(rect).connect(envLP);
      envLP.connect(vca.gain);
      vocCtx.carIn.connect(carBPF).connect(vca).connect(vocCtx.sum);
      vocCtx.bands.push({modBPF,carBPF,envRect:rect,envLP,vca});
    }
    vocCtx.modGate.connect(vocCtx.sibHP).connect(vocCtx.sibGain).connect(vocCtx.sum);

    try{ vocCtx.wet.disconnect(); vocCtx.dry.disconnect(); vocCtx.out.disconnect(); }catch(e){}
    vocCtx.sum.connect(vocCtx.wet).connect(vocCtx.out).connect(mixNode);
  }

  function waitForSynthBusAndWire(maxMs=4000){
    const t0=performance.now();
    (function tick(){
      const bus=window._stagsynth_synthBus;
      if(bus && vocCtx?.carIn){
        try{ vocCtx.carIn.disconnect(); }catch(e){}
        bus.connect(vocCtx.carIn);
        console.log('[voc] carrier wired to synthBus');
        return;
      }
      if(performance.now()-t0<maxMs) requestAnimationFrame(tick);
    })();
  }

  function setCarrier(sel){
    vocCtx.carrierSel=sel; if(!window.audioCtx) return;
    if(!vocCtx.carIn){ vocCtx.carIn=audioCtx.createGain(); vocCtx.carIn.gain.value=1; }
    try{ vocCtx.carIn.disconnect(); }catch(e){}
    const synthBus=window._stagsynth_synthBus;
    const samOut=(typeof samplerBus==='object' && samplerBus.out) ? samplerBus.out : null;
    if(sel==='synth'){ if(synthBus) synthBus.connect(vocCtx.carIn); else waitForSynthBusAndWire(); }
    else if(sel==='sampler'){ if(samOut) samOut.connect(vocCtx.carIn); }
    else if(sel==='both'){ if(synthBus) synthBus.connect(vocCtx.carIn); else waitForSynthBusAndWire(); if(samOut) samOut.connect(vocCtx.carIn); }
  }

  async function enableVocoderIfNeeded(){
    const sel=document.getElementById('voc_carrier').value;
    const needOn=(sel!=='off'); if(!needOn) return;
    await ensureAudio(); const ok=await ensureMic(); if(!ok) return;
    if(!vocCtx.inited){ vocCtx.inited=true; }
    setCarrier(sel);
    rebuildVocoder();
    const s=document.getElementById('voc_status'); if(s) s.textContent='Vocoder ready';
  }

  // Bind UI
  document.addEventListener('DOMContentLoaded',()=>{
    const btn=document.getElementById('vocoderToggle');
    const panel=document.getElementById('vocoderPanel');
    if(btn && panel){
      btn.onclick=()=>{ const o=panel.classList.toggle('open'); btn.setAttribute('aria-expanded', o?'true':'false'); if(o) enableVocoderIfNeeded(); };
    }
    const id=s=>document.getElementById(s);
    id('voc_carrier')?.addEventListener('change', async ()=>{ await enableVocoderIfNeeded(); setCarrier(vocCtx.carrierSel); });
    ['voc_bands','voc_lo','voc_hi','voc_q','voc_shift','voc_att','voc_rel','voc_sib'].forEach(k=> id(k)?.addEventListener('input', ()=>{ if(vocCtx.carrierSel!=='off'){ rebuildVocoder(); }}));
    id('voc_mix')?.addEventListener('input', ()=>{ const mix=parseFloat(id('voc_mix').value||0); if(vocCtx.wet) vocCtx.wet.gain.value=mix; if(vocCtx.dry) vocCtx.dry.gain.value=1-mix; });
    id('voc_out')?.addEventListener('input', ()=>{ if(vocCtx.out) vocCtx.out.gain.value=parseFloat(id('voc_out').value||1); });
    id('voc_mod_gain')?.addEventListener('input', ()=>{ if(vocCtx.modGain) vocCtx.modGain.gain.value=parseFloat(id('voc_mod_gain').value||1); });
    id('voc_gate')?.addEventListener('input', ()=>{ if(vocCtx.modGate) vocCtx.modGate.threshold.value=parseFloat(id('voc_gate').value||-70); });
    id('voc_att')?.addEventListener('input', ()=>{ if(vocCtx.carrierSel!=='off') rebuildVocoder(); });
    id('voc_rel')?.addEventListener('input', ()=>{ if(vocCtx.carrierSel!=='off') rebuildVocoder(); });
    id('voc_test')?.addEventListener('click', async ()=>{ const ok=await ensureMic(); const s=id('voc_status'); if(s) s.textContent= ok ? 'Mic OK' : 'Mic blocked'; });
  });
})();
</script>
<script>
document.addEventListener('DOMContentLoaded',()=>{
  if(window.audioCtx && audioCtx.audioWorklet){
    const aw=audioCtx.audioWorklet;
    const orig=aw.addModule.bind(aw);
    aw.addModule=async function(url, opts){
      try{ return await orig(url, opts); }
      catch(e){ if(String(e).includes('already registered')){ console.warn('[worklet] duplicate register ignored:', url); return; } throw e; }
    };
  }
});
</script>

<script>
/* ---- Safe pointer-capture: swallow NotFoundError without changing your handlers ---- */
(function(){
  if (!Element.prototype._setPointerCapturePatched) {
    const _orig = Element.prototype.setPointerCapture;
    if (_orig) {
      Element.prototype.setPointerCapture = function(pointerId){
        try { return _orig.call(this, pointerId); }
        catch (e) {
          // Ignore "No active pointer" race (common when mixed mouse/touch/pointer listeners run)
          if (e && (e.name === 'NotFoundError' || String(e).includes('No active pointer'))) return;
          throw e;
        }
      };
    }
    Element.prototype._setPointerCapturePatched = true;
  }
})();
</script>

<script>
/* ========= Vocoder v2 (add-only) ‚Äî uses your existing UI, zero changes elsewhere ========= */
(function(){
  if (window.__VocoderV2Mounted) return; window.__VocoderV2Mounted = true;
  const $ = (id)=>document.getElementById(id);

  let ctx=null, wet=null, out=null, noiseGain=null, noiseGen=null;
  let bands=[], modHP=null, micStream=null, micSrc=null;

  // Tuned defaults (you can keep using your UI to tweak)
  const cfg = { nb:16, lo:160, hi:6000, attMs:12, relMs:120, envGain:3.0, noise:0.0, wet:0.6, out:1.0 };

  // Wait for your audio engine (no changes to your code)
  async function boot(){
    if (!window.ensureAudio) return;
    await ensureAudio();
    ctx = window.audioCtx;
    if (!ctx || !window.mixNode) return;

    if (ctx.state === 'suspended') { try { await ctx.resume(); } catch(e){} }

    if (!wet) {
      // Outputs
      wet = ctx.createGain();   wet.gain.value = parseFloat($('#voc_wet')?.value ?? cfg.wet);
      out = ctx.createGain();   out.gain.value = parseFloat($('#voc_out')?.value ?? cfg.out);
      noiseGain = ctx.createGain(); noiseGain.gain.value = parseFloat($('#voc_noise')?.value ?? cfg.noise);

      // Light noise to recover sibilants
      noiseGen = ctx.createBufferSource();
      const nbuf = ctx.createBuffer(1, ctx.sampleRate*2, ctx.sampleRate);
      const d = nbuf.getChannelData(0); for (let i=0;i<d.length;i++) d[i] = Math.random()*2-1;
      noiseGen.buffer = nbuf; noiseGen.loop = true; try{ noiseGen.start(); }catch(e){}
      noiseGen.connect(noiseGain);

      // Sum ‚Üí your master bus
      wet.connect(out);
      noiseGain.connect(out);
      out.connect(window.mixNode);

      // Build and wire
      readCfg(); rebuildBands(); connectRouting();
    }
  }

  function readCfg(){
    cfg.nb     = parseInt($('#voc_bands')?.value ?? cfg.nb, 10) || cfg.nb;
    cfg.lo     = Math.max(40, parseFloat($('#voc_lo')?.value ?? cfg.lo));
    cfg.hi     = Math.max(cfg.lo+200, parseFloat($('#voc_hi')?.value ?? cfg.hi));
    cfg.attMs  = parseFloat($('#voc_att')?.value ?? cfg.attMs);
    cfg.relMs  = parseFloat($('#voc_rel')?.value ?? cfg.relMs);
    // Keep envGain internal; we bias it so the bands actually open
  }

  function destroyBands(){
    bands.forEach(b=>{
      try{ b.modBP.disconnect(); b.rect.disconnect(); b.envLP.disconnect(); b.envGain.disconnect(); b.carBP.disconnect(); b.mul.disconnect(); }catch(e){}
    });
    bands.length = 0;
  }

  function hz(i,n,lo,hi){ const t = n<=1 ? 0 : i/(n-1); return Math.exp(Math.log(lo) + t*(Math.log(hi)-Math.log(lo))); }

  function rebuildBands(){
    if (!ctx) return;
    destroyBands();

    for(let i=0;i<cfg.nb;i++){
      const f = hz(i, cfg.nb, cfg.lo, cfg.hi);

      // Modulator path: bandpass -> rectify -> lowpass (envelope) -> envGain (crucial!)
      const modBP = ctx.createBiquadFilter(); modBP.type='bandpass'; modBP.frequency.value=f; modBP.Q.value=8;

      const rect = ctx.createWaveShaper();
      const curve = new Float32Array(65536);
      for (let j=0;j<curve.length;j++){ const x=j/32768-1; curve[j]=Math.abs(x); }
      rect.curve = curve;

      const envLP = ctx.createBiquadFilter(); envLP.type='lowpass';
      // Low cutoff gives a smooth envelope; attack/release are applied via coefficient math below
      envLP.frequency.value = 60;

      const envGain = ctx.createGain(); envGain.gain.value = cfg.envGain; // <-- boosts envelope amplitude

      // Carrier path: bandpass
      const carBP = ctx.createBiquadFilter(); carBP.type='bandpass'; carBP.frequency.value=f; carBP.Q.value=8;

      // Multiply (envelope controls car band gain)
      const mul = ctx.createGain(); mul.gain.value = 0;

      // Wire per-band
      modBP.connect(rect).connect(envLP).connect(envGain).connect(mul.gain);
      carBP.connect(mul);
      mul.connect(wet);

      bands.push({modBP, rect, envLP, envGain, carBP, mul});
    }
  }

  async function setMic(on){
    const badge = $('#voc_micStatus');
    if (on){
      try{
        const stream = await navigator.mediaDevices.getUserMedia({
          audio:{ echoCancellation:false, noiseSuppression:false, autoGainControl:false }
        });
        micStream = stream; micSrc = ctx.createMediaStreamSource(stream);
        modHP = ctx.createBiquadFilter(); modHP.type='highpass'; modHP.frequency.value = 120;
        micSrc.connect(modHP);
        if (badge) badge.textContent = 'Mic: on';
      }catch(e){
        if (badge) badge.textContent = 'Mic permission denied';
      }
    }else{
      try{ micStream?.getTracks().forEach(t=>t.stop()); }catch(e){}
      micStream=null; micSrc=null; modHP=null;
      if (badge) badge.textContent = 'Mic: off';
    }
  }

  function pickCarrier(){
    const choice = $('#voc_carrier')?.value || 'synth';
    // Prefer explicit sampler bus if chosen
    if (choice==='sampler' && window.samplerBus?.out) return window.samplerBus.out;

    // If your synth exposes a carrier tap, use it
    try{
      const tap = window.synth?.getVocoderCarrierTap?.();
      if (tap) return tap;
    }catch(e){}

    // Safe fallback: pre-limiter mix (still produces vocoder effect)
    return window.mixNode || null;
  }

  function connectRouting(){
    // Disconnect prior
    bands.forEach(b=>{ try{ b.modBP.disconnect(); }catch(e){} try{ b.carBP.disconnect(); }catch(e){} });

    // Modulator (mic) ‚Üí all mod bands
    if (modHP){ bands.forEach(b=> modHP.connect(b.modBP)); }

    // Carrier ‚Üí all carrier bands
    const car = pickCarrier();
    if (car){ bands.forEach(b=> car.connect(b.carBP)); }

    // Apply current gains
    if (wet)       wet.gain.value       = parseFloat($('#voc_wet')?.value ?? cfg.wet);
    if (out)       out.gain.value       = parseFloat($('#voc_out')?.value ?? cfg.out);
    if (noiseGain) noiseGain.gain.value = parseFloat($('#voc_noise')?.value ?? cfg.noise);

    // Optional: simple envelope ‚Äúfeel‚Äù by tweaking envLP frequency in relation to attack/release
    const att = Math.max(0.001, (parseFloat($('#voc_att')?.value ?? cfg.attMs))/1000);
    const rel = Math.max(0.005, (parseFloat($('#voc_rel')?.value ?? cfg.relMs))/1000);
    const smoothHz = Math.max(20, 1/Math.max(att, rel)); // higher cutoff = faster envelope
    bands.forEach(b=> b.envLP.frequency.value = smoothHz);
  }

  // Bind only your Vocoder controls; avoids touching other UI
  function bindUI(){
    $('#startBtn')?.addEventListener('click', boot);
    $('#resetBtn')?.addEventListener('click', ()=> setTimeout(boot,50));

    $('#voc_enableMic')?.addEventListener('change', async (e)=>{
      await boot();
      await setMic(e.target.checked);
      connectRouting();
    });
    $('#voc_carrier')?.addEventListener('change', connectRouting);
    $('#voc_wet')?.addEventListener('input',   ()=> { if (wet)  wet.gain.value  = parseFloat($('#voc_wet').value||'0'); });
    $('#voc_out')?.addEventListener('input',   ()=> { if (out)  out.gain.value  = parseFloat($('#voc_out').value||'1'); });
    $('#voc_noise')?.addEventListener('input', ()=> { if (noiseGain) noiseGain.gain.value = parseFloat($('#voc_noise').value||'0'); });

    ['voc_bands','voc_lo','voc_hi','voc_att','voc_rel'].forEach(id=>{
      $(id)?.addEventListener('input', ()=>{ readCfg(); rebuildBands(); connectRouting(); });
    });
    $('#voc_rebuild')?.addEventListener('click', ()=>{
      readCfg(); rebuildBands(); connectRouting();
      const s=$('#voc_status'); if(s){ s.textContent='Bands rebuilt'; setTimeout(()=>s.textContent='',1000); }
    });
  }

  // Install listeners immediately; the nodes are created after Start Audio
  bindUI();
})();
</script>



<script>
// ===== Step Sequencer (overlay-style INPUT, reset-safe) =====
(function(){
  let ON=false, PLAY=false, tId=null, step=0;
  const pattern = new Map();   // step -> Set(MIDI)
  let held=[];
  let maxCols=32; let strip=null;
  let __lastMidi=-1, __lastTs=0;

  const $ = (id)=>document.getElementById(id);
  const $$ = (sel,root=document)=>Array.from(root.querySelectorAll(sel));

  function ensureStrip(){
    if(!strip){ strip = $('seqStepsStrip'); }
  // Clear button: wipe pattern and reset step
  (function bindSeqClear(){
    const b=$('seqClearBtn'); if(!b || b.__bound) return; b.__bound=true;
    b.addEventListener('click', (e)=>{ e.stopPropagation(); pattern.clear(); step=0; setPlay(false); renderHighlights(step,false); });
  })();

    if(!strip) return;
    if(strip.childElementCount !== maxCols){
      strip.innerHTML='';
      for(let i=0;i<maxCols;i++){
        const s=document.createElement('div');
        s.className='led'; s.dataset.index=String(i);
        strip.appendChild(s);
      }
    }
  }

  function ui(on){
    const btn = $('seqModeBtn');
    const panel = $('seqControlsInline');
    const stripEl = $('seqStepsStrip');
    if(btn) btn.style.display = on ? 'inline-block' : 'none';
    const clr=$('seqClearBtn'); if(clr) clr.style.display = on ? 'inline-block' : 'none';
    if(panel) panel.style.display = on ? 'grid' : 'none';
    if(stripEl) stripEl.style.display = on ? 'grid' : 'none';
  }

  function len(){ return Math.max(1, +($('seq_steps')?.value||16)); }
  function bpm(){ return +($('seq_bpm')?.value||120); }
  function div(){ return +($('seq_div')?.value||16); }
  function baseSec(){ return (60/bpm())*(4/div()); }
  function gateSec(){ return baseSec()*(Math.max(5, +($('seq_gate')?.value||60))/100); }
  function swing(){ return Math.max(0, +($('seq_swing')?.value||0))/100; }
  function vel(){ return Math.max(.1, +($('seq_vel')?.value||.9)); }
  function tr(){ return +($('seq_trans')?.value||0); }

  function renderHighlights(currentIdx, playing){
    window.ensureStrip && window.ensureStrip(); const sEl=$('seqStepsStrip');
    if(sEl){
      const L=len(); const nodes=$$('.led', sEl);
      nodes.forEach((n,i)=>{
        n.classList.remove('active','play','has');
        if(i<L){
          const set=pattern.get(i);
          if(set && set.size) n.classList.add('has');
          if(i===currentIdx){ n.classList.add(playing?'play':'active'); }
          n.style.visibility='visible';
        } else {
          n.style.visibility='hidden';
        }
      });
    }
    // Keypad partial lights for current step when not playing
    const pad=$('keypad');
    if(pad && !playing){
      const set=pattern.get(currentIdx)||new Set();
      $$('.key', pad).forEach(k=>{
        const m=parseFloat(k.dataset.midi);
        if(set.has(m)) k.classList.add('seq-has'); else k.classList.remove('seq-has');
      });
    }
  }

  function allOff(){ try{ held.forEach(m=> routeNoteOff(m)); }catch(e){} held.length=0; }
  function setOn(v){ ON=!!v; $('seqToggle')?.setAttribute('aria-pressed', String(ON)); ui(ON); if(!ON) setPlay(false); renderHighlights(step, PLAY); }
  function setPlay(v){
    PLAY=!!v;
    const b=$('seqModeBtn');
    if(b){ b.textContent = PLAY ? 'Play (ON)' : 'Input'; b.setAttribute('aria-pressed', String(PLAY)); }
    ui(ON);
    if(PLAY) start(); else { stop(); allOff(); }
    renderHighlights(step, PLAY);
  }

  function stop(){ if(tId){ clearTimeout(tId); tId=null; } }
  function start(){ stop(); tId=setTimeout(tick, 0); }

  function tick(){
    if(!PLAY){ stop(); return; }
    const L = len();
    const s = step % L;
    const notes = Array.from(pattern.get(s)||[]);
    const V = vel(), T = tr();

    held = notes.map(m=> m+T);
    held.forEach(m=> routeNoteOn(m, V));

    // Visual: light currently sounding keys briefly
    const pad=$('keypad');
    if(pad){
      const keys=$$('.key', pad);
      keys.forEach(k=>{
        const m=parseFloat(k.dataset.midi);
        if(held.includes(m)) k.classList.add('seq-play');
      });
      setTimeout(()=>{ keys.forEach(k=> k.classList.remove('seq-play')); }, Math.max(60, gateSec()*1000));
    }
    renderHighlights(s, true);

    setTimeout(()=>{ held.forEach(m=> routeNoteOff(m)); held=[]; }, Math.max(10, gateSec()*1000));

    const base = baseSec(), sw = swing();
    const dly = base + ((s%2===1) ? base*sw : 0);
    step++;
    tId = setTimeout(tick, Math.max(1, dly*1000));
  }

  // INPUT delegation on keypad
  function attachDelegation(){
    const pad = $('keypad'); if(!pad) return;
    if(pad.__seqHooked) return; pad.__seqHooked = true;
    pad.addEventListener('pointerdown', (e)=>{
      const target = e.target.closest('.key'); if(!target) return;
      if(ON && !PLAY){
        e.preventDefault();
        // INPUT mode: no pattern mutation here to avoid double-assignment; let routeNoteOn handle it.
        const t = e.target.closest('.key'); if(t){ t.classList.add('on'); setTimeout(()=>t.classList.remove('on'),80); }
        return;
}
    }, true);
  }

  // Click LED to jump step (when not playing)
  
function attachStripClick(){
  window.ensureStrip && window.ensureStrip();
  const sEl = $('seqStepsStrip');
  if(!sEl || sEl.__seqHooked) return;
  sEl.__seqHooked = true;

  // State for mobile double-tap + click suppression
  let lastTapIdx = -1, lastTapT = 0;
  let suppressClickUntil = 0;

  // Desktop: double-click clears step
  sEl.addEventListener('dblclick', (e)=>{
    const d = e.target.closest('.led'); if(!d) return;
    const i = +(d.dataset.index);
    if(!(i < len())) return;
    e.preventDefault(); e.stopPropagation();
    pattern.delete(i);
    // keep selection on this step for continued editing
    setPlay(false);
    step = i;
    renderHighlights(step, false);
    suppressClickUntil = performance.now() + 350; // prevent following single-click
  }, true);

  // Mobile: double-tap (two pointerdowns within 300ms on same LED) clears step
  sEl.addEventListener('pointerdown', (e)=>{
    const d = e.target.closest('.led'); if(!d) return;
    const i = +(d.dataset.index);
    if(!(i < len())) return;
    const now = performance.now();
    if (i === lastTapIdx && (now - lastTapT) < 300){
      e.preventDefault(); e.stopPropagation();
      pattern.delete(i);
      setPlay(false);
      step = i;
      renderHighlights(step, false);
      lastTapIdx = -1; lastTapT = 0;
      suppressClickUntil = now + 350;
      return;
    }
    lastTapIdx = i; lastTapT = now;
  }, true);

  // Single click: select step for editing (unless suppressed by a double action)
  sEl.addEventListener('click', (e)=>{
    const d = e.target.closest('.led'); if(!d) return;
    const i = +(d.dataset.index);
    if(!(i < len())) return;
    if (performance.now() < suppressClickUntil){
      e.preventDefault(); e.stopPropagation();
      return;
    }
    // select step for input, stop playback
    setPlay(false);
    step = i;
    renderHighlights(step, false);
  }, true);
}



  // Reset-safe hooks
  window.addEventListener('rebuild:keypad', ()=>{ attachDelegation(); renderHighlights(step, PLAY); });
  window.addEventListener('audio:ready', ()=>{ attachDelegation(); attachStripClick(); renderHighlights(step, PLAY); if(PLAY) start(); });

  $('seqToggle')?.addEventListener('click', ()=> setOn(!ON));
  $('seqModeBtn')?.addEventListener('click', ()=> setPlay(!PLAY));
  $('seq_clear')?.addEventListener('click', ()=>{ try{ pattern.clear(); }catch(e){} try{ step = 0; }catch(e){} try{ setPlay(false); }catch(e){} try{ renderHighlights(step,false); }catch(e){} });// initial
  attachDelegation(); attachStripClick(); renderHighlights(step,false);
  // --- MIDI-aware: intercept global routeNoteOn while in INPUT mode ---
  if (!window.__seq_origRouteNoteOn && typeof window.routeNoteOn === 'function'){
    window.__seq_origRouteNoteOn = window.routeNoteOn;
    window.routeNoteOn = function(midi, velocity=1){
      if(ON && !PLAY){
        const now = performance.now();
        if(midi===__lastMidi && (now-__lastTs)<160){ return; } // debounce duplicate taps
        __lastMidi = midi; __lastTs = now;

        const L = len();
        const s = step % L;
        let set = pattern.get(s); if(!set){ set=new Set(); pattern.set(s,set); }
        // single-note per step
        set.clear(); set.add(midi);

        // brief audition for feedback
        try{
          let did=false;
          if(window.synth && typeof window.synth.noteOn==='function' && typeof window.synth.noteOff==='function'){
            window.synth.noteOn(midi, Math.max(0.2, Math.min(1, velocity||1)));
            setTimeout(()=>{ try{ window.synth.noteOff(midi); }catch(e){} }, 150);
            did=true;
          }
          if(!did){
            const ac = window.audioCtx || window.a || window._stagsynth_synthCtx;
            if(ac){
              const osc = ac.createOscillator();
              const g = ac.createGain();
              const f = 440 * Math.pow(2, (midi-69)/12);
              osc.frequency.value = f;
              g.gain.value = 0.08;
              const t0 = ac.currentTime;
              g.gain.setValueAtTime(0.0, t0);
              g.gain.linearRampToValueAtTime(0.08, t0 + 0.005);
              g.gain.linearRampToValueAtTime(0.0,  t0 + 0.14);
              osc.connect(g).connect(window.mixNode||ac.destination);
              osc.start(t0);
              osc.stop(t0 + 0.16);
            }
          }
        }catch(e){}

        // advance one step for quick entry and update highlights
        step = (s+1) % L;
        renderHighlights(step, false);
        return; // swallow original
      }
      // normal behavior
      return window.__seq_origRouteNoteOn.apply(this, arguments);
    };
  }

  // Live update steps without Reset Audio (internal)
  function bindStepsLive(){
    const el = $('seq_steps'); if(!el || el.__bound) return; el.__bound = true;
    el.addEventListener('input', ()=>{
      maxCols = Math.max(1, +el.value || 16);
      window.ensureStrip && window.ensureStrip();
      try{ if (window.renderHighlights) renderHighlights(step % maxCols, PLAY); }catch(e){}
    });
  }
  function __rebindSeqUI(){ try{ bindStepsLive(); }catch(e){} }
  if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', __rebindSeqUI); } else { __rebindSeqUI(); }
  window.addEventListener('audio:ready', __rebindSeqUI);
  window.addEventListener('rebuild:keypad', __rebindSeqUI);

})();

  // Live update steps without Reset Audio
  (function bindStepsLive(){
    const el = $('seq_steps'); if(!el || el.__bound) return; el.__bound = true;
    el.addEventListener('input', ()=>{
      maxCols = Math.max(1, +el.value || 16);
      window.ensureStrip && window.ensureStrip();
      renderHighlights(step % maxCols, PLAY);
    });
  })();

  function __rebindSeqUI(){ try{ bindStepsLive(); }catch(e){} try{ /* keep clear bound */ }catch(e){} }
  if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', __rebindSeqUI); } else { __rebindSeqUI(); }
  window.addEventListener('audio:ready', __rebindSeqUI);
  window.addEventListener('rebuild:keypad', __rebindSeqUI);
</script>

<script>
(function(){
  function placeStrip(){
    const strip = document.getElementById('seqStepsStrip');
    const pad = document.getElementById('keypad');
    if(!strip || !pad) return;
    const parent = pad.parentElement || document.body;
    // If strip is not already immediately before keypad, move it
    if (strip.nextElementSibling !== pad){
      try{ parent.insertBefore(strip, pad); }catch(e){}
    }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', placeStrip);
  }else{
    placeStrip();
  }
  window.addEventListener('rebuild:keypad', placeStrip);
  window.addEventListener('audio:ready', placeStrip);
})();
</script>


<script>
function updateSeqGridForSteps(){
  try{
    const strip = document.getElementById('seqStepsStrip');
    const el = document.getElementById('seq_steps');
    if(!strip || !el) return;
    const steps = Math.max(1, +el.value || 16);
    const isMobile = window.matchMedia && window.matchMedia('(max-width: 540px)').matches;
    const cols = isMobile ? Math.min(12, Math.max(6, steps)) : steps;
    const rowh = isMobile ? 34 : 22;
    strip.style.setProperty('--seq-cols', String(cols));
    strip.style.setProperty('--seq-rowh', rowh + 'px');
  }catch(e){}
}
document.addEventListener('DOMContentLoaded', ()=>{
  const el = document.getElementById('seq_steps');
  if(el && !el.__gridBound){
    el.__gridBound = true;
    const fn = ()=>{ try{ if(window.ensureStrip) window.ensureStrip(); }catch(e){}; updateSeqGridForSteps(); };
    el.addEventListener('input', fn);
    el.addEventListener('change', fn);
  }
  updateSeqGridForSteps();
}, {once:true});
</script>

<!-- Custom/Wavetable Panel -->
<div id="customPanel" class="synth-panel" role="region" aria-label="Custom Waveforms">
  <div class="section">
    <h4>Custom / Wavetable Editor</h4>
    <div class="row" style="gap:14px;flex-wrap:wrap">
      <div style="flex:1;min-width:300px">
        <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px">
          <label>Tool
            <select id="wt_tool">
              <option value="draw" selected>Draw</option>
              <option value="erase">Erase</option>
              <option value="smooth">Smooth</option>
              <option value="normalize">Normalize</option>
              <option value="zero">Zero DC</option>
              <option value="invert">Invert</option>
            </select>
          </label>
          <label>Brush <input type="range" id="wt_brush" min="1" max="40" step="1" value="6"/></label>
          <button id="wt_clear" class="pill">Clear</button>
        </div>
        <canvas id="wt_canvas" width="768" height="240" style="width:100%;border:1px solid #333;border-radius:8px;background:#111"<canvas id="wt_canvas" width="768" height="240" style="touch-action:none; width:100%;border:1px solid #333;border-radius:8px;background:#111"></canvas>
        <div style="display:flex;gap:8px;align-items:center;margin-top:8px;flex-wrap:wrap">
          <button id="wt_add_frame" class="pill">Add as Frame</button>
          <button id="wt_replace_frame" class="pill">Replace Current</button>
          <button id="wt_delete_frame" class="pill">Delete Current</button>
          <label> Insert In-betweens
            <input type="number" id="wt_inbet" min="0" max="256" step="1" value="0" style="width:64px"/>
          </label>
          <label style="display:block;margin-top:6px"> Morph
            <select id="wt_morph">
              <option value="none">None</option>
              <option value="xfade" selected>Crossfade</option>
            </select>
          </label></div>
      </div>

      <div style="flex:1;min-width:280px">
        <div style="display:flex;gap:8px;align-items:center;margin-bottom:6px;flex-wrap:wrap">
          <input type="file" id="wt_import_png" accept="image/png" />
          <button id="wt_load_png" class="pill">Import PNG</button>
        </div>

<div id="wt_import_export_row" style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;margin-top:10px">
  <label style="display:inline-flex;align-items:center;gap:6px">Name
    <input id="wt_import_name" type="text" placeholder="Imported WT" style="width:200px"/>
  </label>
  <button id="wt_import_export" class="pill">Export to Oscs</button>
</div>


<div style="display:flex;gap:8px;align-items:center;margin-top:10px">
          <input id="wt_name" placeholder="Wave name" style="flex:1"/>
          <button id="wt_export" class="pill">Export to Oscs</button>
        </div>

        <div style="display:flex;gap:10px;align-items:center;margin:8px 0">
           <label>Frame <input id="wt_frame_idx" type="range" min="0" max="0" step="1" value="0" style="width:160px"/></label>
          <span id="wt_frame_readout" class="badge">0/0</span>
        </div>
        <div id="wt_frames" style="display:flex;gap:6px;overflow:auto;padding:6px;border:1px dashed #333;border-radius:8px;min-height:60px"></div>
        
        </div>
    </div>
  </div>
</div>


<script>
(()=>{
  let __wtPreview = null;
  async function __ensureAC(){
    try{
      if(window.ensureAudio) { await ensureAudio(); return window.audioCtx; }
      return window.audioCtx || new (window.AudioContext||window.webkitAudioContext)();
    }catch(e){ return null; }
  }
  function __buildPW(ac, frame){
    const N = frame.length; const TWO_PI = Math.PI*2; const MAX_HARM = 128;
    const real = new Float32Array(MAX_HARM+1), imag = new Float32Array(MAX_HARM+1);
    for(let k=1;k<=MAX_HARM;k++){
      let a=0,b=0;
      for(let n=0;n<N;n++){ const phi=TWO_PI*k*n/N, x=frame[n]; a += x*Math.cos(phi); b += x*Math.sin(phi); }
      real[k] = (2/N)*a; imag[k] = -(2/N)*b;
    }
    return ac.createPeriodicWave(real, imag, {disableNormalization:true});
  }
  async function __startPreview(getFrame){
    const ac = await __ensureAC(); if(!ac) return;
    const g = ac.createGain(); g.gain.value = 0.18; g.connect(ac.destination);
    const o = ac.createOscillator();
    const fr = getFrame(); if(fr){ try{ o.setPeriodicWave(__buildPW(ac, fr)); }catch(e){} }
    o.connect(g);
    try{ o.start(); }catch(e){}
    __wtPreview = {ac,o,g,getFrame};
  }
  function __stopPreview(){
    const P = __wtPreview; __wtPreview = null;
    if(!P) return;
    try{ P.o.stop(); }catch(e){} try{ P.o.disconnect(); }catch(e){} try{ P.g.disconnect(); }catch(e){}
  }
  function __updatePreview(){
    const P = __wtPreview; if(!P) return;
    const fr = P.getFrame(); if(!fr) return;
    try{ P.o.setPeriodicWave(__buildPW(P.ac, fr)); }catch(e){}
  }
  document.addEventListener('DOMContentLoaded', ()=>{
    const chk = document.getElementById('wt_preview_chk');
    const slider = document.getElementById('wt_frame_idx');
    if(chk){
      chk.addEventListener('change', ()=>{
        if(chk.checked){
          __startPreview(()=> (window.__WT_CURRENT_FRAME || null));
        }else{
          __stopPreview();
        }
      });
    }
    if(slider){
      slider.addEventListener('input', ()=>{ __updatePreview(); });
    }
  }, {once:true});
})();
</script>


<script>
(function(){
  try{
    const cvs = document.getElementById('wt_canvas');
    if(cvs && !cvs.__wtBound){
      cvs.__wtBound = true;
      cvs.style.touchAction = 'none';
      cvs.addEventListener('pointerdown', function(e){
        try{ cvs.setPointerCapture && cvs.setPointerCapture(e.pointerId); }catch(_){}
      }, {passive:false});
    }
    const file = document.getElementById('wt_import_png');
    const btn  = document.getElementById('wt_load_png');
    const defaultMode = 'plot';
window.__WT_loadBitmap = async function(file){
      if (window.createImageBitmap){
        try{ return await createImageBitmap(file); }catch(e){}
      }
      return await new Promise((resolve, reject)=>{
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = ()=>{ resolve(img); URL.revokeObjectURL(url); };
        img.onerror = (err)=>{ reject(err); URL.revokeObjectURL(url); };
        img.src = url;
      });
    };
    function triggerImport(){
      const f = file && file.files && file.files[0];
      if(!f) return;
      try{
        if (typeof importPNG === 'function'){
          importPNG(f, 'plot');
        } else if (window.__WT_EDITOR_IMPORT){
          window.__WT_EDITOR_IMPORT(f, 'plot');
        }
      }catch(e){ console.warn('[WT] import failed', e); }
    }
    if(file && !file.__wtBound){
      file.__wtBound = true;
      file.addEventListener('change', triggerImport);
    }
    if(btn && !btn.__wtBound){
      btn.__wtBound = true;
      btn.addEventListener('click', ()=>{ if(!(file && file.files && file.files[0])){ try{ file.click(); }catch(e){} } else { try{ triggerImport(); }catch(e){} } });
    }
  }catch(e){ console.warn('[WT] enhancement setup error', e); }
})();
</script>


<script>
// ===== Custom / Wavetable Editor (injected) =====
(function(){
  const TWO_PI = Math.PI*2;
  const N = 2048;
  const MAX_HARM = 128;
  const LIB_KEY = 'stagsynth_customwaves_v1';
  let LIB = { };
  try{ LIB = JSON.parse(localStorage.getItem(LIB_KEY)||'{}'); }catch{ LIB={}; }

  // UI refs
  const cvs = document.getElementById('wt_canvas');
  const ctx = cvs ? cvs.getContext('2d', { desynchronized:true }) : null;
  const toolSel = document.getElementById('wt_tool');
  const brushR = document.getElementById('wt_brush');
  const clearB = document.getElementById('wt_clear');
  const addB = document.getElementById('wt_add_frame');
  const repB = document.getElementById('wt_replace_frame');
  const delB = document.getElementById('wt_delete_frame');
  const morphSel = document.getElementById('wt_morph');
  const inbetN = document.getElementById('wt_inbet');
  const framesDiv = document.getElementById('wt_frames');
  const frameSlider = document.getElementById('wt_frame_idx');
  const frameReadout = document.getElementById('wt_frame_readout');
  const nameF = document.getElementById('wt_name');
  const exportB = document.getElementById('wt_export');
  const auditionB = document.getElementById('wt_audition');

  if(!cvs || !ctx) return;

  let tool = toolSel ? toolSel.value : 'draw';
  let brush = brushR ? parseInt(brushR.value||'6',10) : 6;
  let drawing = false;
  let current = new Float32Array(N);
  let frames = [];
  let frameIdx = 0;

  function saveLib(){ try{ localStorage.setItem(LIB_KEY, JSON.stringify(LIB)); }catch(e){} }
  function zeroDC(arr){ let s=0; for(const v of arr) s+=v; const dc=s/arr.length; for(let i=0;i<arr.length;i++) arr[i]-=dc; }
  function normalize(arr){ let m=1e-12; for(const v of arr) m=Math.max(m,Math.abs(v)); if(m>0) for(let i=0;i<arr.length;i++) arr[i]/=m; }
  function smoothOne(arr, passes=1){ for(let p=0;p<passes;p++){ for(let i=1;i<arr.length-1;i++) arr[i]=(arr[i-1]+arr[i]+arr[i+1])/3; } }

  function drawGrid(){
    ctx.clearRect(0,0,cvs.width,cvs.height);
    ctx.fillStyle='#111'; ctx.fillRect(0,0,cvs.width,cvs.height);
    // midline
    ctx.strokeStyle='#333'; ctx.beginPath();
    ctx.moveTo(0, cvs.height/2); ctx.lineTo(cvs.width, cvs.height/2); ctx.stroke();
    // waveform
    ctx.strokeStyle='#7cf'; ctx.lineWidth=2; ctx.beginPath();
    for(let i=0;i<N;i++){ const x=i*(cvs.width/(N-1)); const y=(0.5-current[i]*0.5)*cvs.height; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);}
    ctx.stroke();
    window.__WT_CURRENT_FRAME = current;
  }

  function toIndex(x){ return Math.max(0, Math.min(N-1, Math.round(x*(N-1)/cvs.clientWidth))); }
  function yToVal(y){ const rel=y/cvs.clientHeight; return (0.5-rel)*2; }

  function handleDraw(e){
    const r=cvs.getBoundingClientRect();
    const cx = (e.clientX!=null? e.clientX : (e.touches && e.touches[0] && e.touches[0].clientX)) || 0;
    const cy = (e.clientY!=null? e.clientY : (e.touches && e.touches[0] && e.touches[0].clientY)) || 0;
    const x=cx - r.left, y=cy - r.top;
    const i=toIndex(x), val=yToVal(y);
    const half=Math.max(1, Math.floor(brush/2));
    for(let k=-half;k<=half;k++){ const idx=Math.max(0,Math.min(N-1,i+k)); if(tool==='draw') current[idx]=val; else if(tool==='erase') current[idx]=0; }
    if(tool==='smooth') smoothOne(current,1);
    if(tool==='normalize') normalize(current);
    if(tool==='zero') zeroDC(current);
    if(tool==='invert'){ for(let j=0;j<N;j++) current[j]=-current[j]; tool='draw'; if(toolSel) toolSel.value='draw'; }
    drawGrid();
  }

  cvs.style.touchAction='none';
  cvs.onpointerdown = (e)=>{ drawing=true; try{ cvs.setPointerCapture(e.pointerId); }catch(e){} handleDraw(e); };
  cvs.onpointermove = (e)=>{ if(drawing) handleDraw(e); };
  cvs.onpointerup = ()=>{ drawing=false; };
  cvs.onpointerleave = ()=>{ drawing=false; };
  // Extra safety: ensure canvas is interactable and fall back to mouse/touch if Pointer Events are quirky
  try{ cvs.style.pointerEvents = 'auto'; cvs.style.userSelect = 'none'; }catch(e){}
  cvs.oncontextmenu = (e)=>{ e.preventDefault(); };

  // Mouse fallback
  const __startDraw = (e)=>{ drawing=true; handleDraw(e); };
  const __moveDraw = (e)=>{ if(drawing) handleDraw(e); };
  const __endDraw  = ()=>{ drawing=false; };

  cvs.addEventListener('mousedown', __startDraw);
  cvs.addEventListener('mousemove', __moveDraw);
  cvs.addEventListener('mouseup', __endDraw);
  cvs.addEventListener('mouseleave', __endDraw);

  // Touch fallback
  const __opt = { passive:false };
  cvs.addEventListener('touchstart', (e)=>{ e.preventDefault(); __startDraw(e); }, __opt);
  cvs.addEventListener('touchmove',  (e)=>{ e.preventDefault(); __moveDraw(e); }, __opt);
  cvs.addEventListener('touchend',   (e)=>{ e.preventDefault(); __endDraw(e); }, __opt);
  cvs.addEventListener('touchcancel',(e)=>{ e.preventDefault(); __endDraw(e); }, __opt);


  if(toolSel) toolSel.onchange = ()=> tool = toolSel.value;
  if(brushR) brushR.oninput = ()=> brush = parseInt(brushR.value,10);
  if(clearB) clearB.onclick = ()=>{ current.fill(0); drawGrid(); };

  function updateFrameReadout(){ frameReadout && (frameReadout.textContent = frames.length ? (frameIdx+1)+'/'+frames.length : '0/0'); }
  function refreshThumbs(){
    if(!framesDiv) return;
    framesDiv.innerHTML='';
    frames.forEach((fr, idx)=>{
      const d=document.createElement('div'); d.className='thumb'+(idx===frameIdx?' active':'');
      const c=document.createElement('canvas'); c.width=56; c.height=40; d.appendChild(c);
      const cx=c.getContext('2d');
      cx.fillStyle='#151515'; cx.fillRect(0,0,56,40);
      cx.strokeStyle='#6f8'; cx.lineWidth=1; cx.beginPath();
      for(let i=0;i<N;i++){ const x=i*(56/(N-1)); const y=(0.5-fr[i]*0.5)*40; if(i===0) cx.moveTo(x,y); else cx.lineTo(x,y);}
      cx.stroke();
      d.onclick=()=>{ frameIdx=idx; current.set(frames[frameIdx]); drawGrid(); if(frameSlider) frameSlider.value=String(frameIdx); updateFrameReadout(); refreshThumbs(); };
      framesDiv.appendChild(d);
    });
    if(frameSlider){ frameSlider.max = Math.max(0, frames.length-1); frameSlider.value = Math.max(0, Math.min(frames.length-1, frameIdx)); }
    updateFrameReadout();
  }

  if(frameSlider) frameSlider.oninput=()=>{ frameIdx = Math.max(0, Math.min(frames.length-1, parseInt(frameSlider.value||'0'))); if(frames[frameIdx]) current.set(frames[frameIdx]); drawGrid(); };

  if(addB) addB.onclick = ()=>{ const fr=new Float32Array(current); zeroDC(fr); normalize(fr); frames.push(fr); frameIdx=frames.length-1; refreshThumbs(); };
  if(repB) repB.onclick = ()=>{ if(!frames.length) return; const fr=new Float32Array(current); zeroDC(fr); normalize(fr); frames[frameIdx]=fr; refreshThumbs(); };
  if(delB) delB.onclick = ()=>{ if(!frames.length) return; frames.splice(frameIdx,1); frameIdx=Math.max(0,frameIdx-1); if(frames[frameIdx]) current.set(frames[frameIdx]); drawGrid(); refreshThumbs(); };

  if(morphSel && inbetN){
    const genB = document.getElementById('wt_gen_morph');
    if(genB) genB.onclick = ()=>{ if(frames.length<2) return; const out=[]; for(let i=0;i<frames.length-1;i++){ const a=frames[i], b=frames[i+1]; out.push(a); const steps=Math.max(0, Math.min(256, parseInt(inbetN.value||'0'))); for(let s=1;s<=steps;s++){ const t=s/(steps+1); const fr=new Float32Array(N); for(let k=0;k<N;k++) fr[k]=a[k]*(1-t)+b[k]*t; zeroDC(fr); normalize(fr); out.push(fr); } } out.push(frames[frames.length-1]); __wt_setImportPreview(out && out[0]);;
  }

  
  // ---- Import Preview helpers ----
  function __wt_drawImportPreview(arr){
    try{
      const c = document.getElementById('wt_import_preview_c'); if(!c) return;
      const cx = c.getContext('2d');
      const W = c.width, H = c.height;
      cx.clearRect(0,0,W,H);
      cx.fillStyle = '#111'; cx.fillRect(0,0,W,H);
      // axes
      cx.strokeStyle = '#303030'; cx.lineWidth = 1;
      cx.beginPath(); cx.moveTo(0, H/2); cx.lineTo(W, H/2); cx.stroke();
      // waveform
      if(!arr || !arr.length) return;
      cx.beginPath();
      cx.strokeStyle = '#6ff'; cx.lineWidth = 2;
      for(let i=0;i<arr.length;i++){
        const x = (i/(arr.length-1))*W;
        const y = (0.5 - arr[i]*0.5)*H;
        if(i===0) cx.moveTo(x,y); else cx.lineTo(x,y);
      }
      cx.stroke();
    }catch(e){ console.warn('[WT] preview draw error', e); }
  }
  function __wt_setImportPreview(samples){
    try{
      if(!samples || !samples.length){ window.__WT_IMPORT_PREVIEW = null; __wt_drawImportPreview(null); return; }
      // Sanitize ‚Üí Float32Array[2048]
      const N = 2048;
      let a = Float32Array.from(samples);
      // DC remove
      let s=0; for(let i=0;i<a.length;i++) s+=a[i]; const dc = s/a.length;
      for(let i=0;i<a.length;i++) a[i]-=dc;
      // normalize
      let peak=1e-9; for(let i=0;i<a.length;i++){ const mv=Math.abs(a[i]); if(mv>peak) peak=mv; }
      if(peak>0){ const k=0.95/peak; for(let i=0;i<a.length;i++) a[i]=Math.max(-0.95, Math.min(0.95, a[i]*k)); }
      // resample to 2048 if needed
      if(a.length!==N){
        const out=new Float32Array(N);
        for(let i=0;i<N;i++){ const t=i*(a.length-1)/(N-1); const i0=t|0, i1=Math.min(a.length-1,i0+1); const f=t-i0; out[i]=a[i0]*(1-f)+a[i1]*f; }
        a = out;
      }
      window.__WT_IMPORT_PREVIEW = a;
      __wt_drawImportPreview(a);
      const st = document.getElementById('wt_import_status'); if(st) st.textContent = 'Ready ‚Äî click Export to Oscillators to save.';
    }catch(e){ console.warn('[WT] set preview error', e); }
  }
  // Export preview ‚Üí Oscillator menu (32 identical frames)
  (function(){
    const btn = document.getElementById('wt_import_export');
    if(btn && !btn.__wtBound){
      btn.__wtBound = true;
      btn.addEventListener('click', ()=>{
        try{
          const a = window.__WT_IMPORT_PREVIEW;
          if(!a || !a.length){ alert('Nothing to export yet. Import a PNG/WAV/CSV first.'); return; }
          const frames = []; for(let i=0;i<32;i++) frames.push(Float32Array.from(a));
          let nm = (document.getElementById('wt_import_name')?.value||'').trim();
          if(!nm) nm = 'Imported ' + (new Date().toLocaleTimeString());
          CustomWT.save(nm, frames);
          CustomWT.refreshMenus(nm);
          alert('Exported to Synth as "'+nm+'" (find under Custom shapes).');
        }catch(e){ console.warn('[WT] import export error', e); alert('Export failed. See console.'); }
      });
    }
  })();
async function loadBitmap(file){
    if(window.createImageBitmap){ try{ return await createImageBitmap(file); }catch(e){} }
    return await new Promise((resolve,reject)=>{ const url=URL.createObjectURL(file); const img=new Image(); img.onload=()=>{ resolve(img); URL.revokeObjectURL(url); }; img.onerror=(err)=>{ reject(err); URL.revokeObjectURL(url); }; img.src=url; });
  }

  async function importPNG(file, mode){
    const bmp = await loadBitmap(file);
    const tmp = document.createElement('canvas');
    tmp.width = bmp.width; tmp.height = bmp.height;
    const cx = tmp.getContext('2d'); cx.drawImage(bmp,0,0);
    const data = cx.getImageData(0,0,tmp.width,tmp.height).data;

    if(mode==='serum'){ // rows => frames
      const rows = tmp.height, cols = tmp.width;
      const resCols = N;
      const out=[];
      for(let r=0;r<rows;r++){ const fr=new Float32Array(N); for(let k=0;k<resCols;k++){ const sx=Math.floor(k*(cols/resCols)); const idx=(r*cols+sx)*4; const gray=(data[idx]+data[idx+1]+data[idx+2])/3; fr[k] = (gray/255)*2-1; } 


  async function importPlotPNG(file){
    try{
      const bmp = await loadBitmap(file);
      const cxTmp = document.createElement('canvas').getContext('2d');
      cxTmp.canvas.width = bmp.width; cxTmp.canvas.height = bmp.height;
      cxTmp.drawImage(bmp,0,0);
      const {width:W,height:H} = cxTmp.canvas;
      const data = cxTmp.getImageData(0,0,W,H).data;
      const resCols = 2048;
      const arr = new Float32Array(resCols);
      // target matplotlib default blue ~ #1f77b4
      const tr = 0x1f, tg = 0x77, tb = 0xb4;
      const border = Math.floor(H*0.06);
      for(let k=0;k<resCols;k++){
        const sx = Math.floor(k*(W/resCols));
        let bestY = -1, bestScore = 1e9;
        for(let y=border;y<H-border;y++){
          const idx = (y*W + sx)*4;
          const r=data[idx], g=data[idx+1], b=data[idx+2], a=data[idx+3];
          if(a<10) continue;
          // ignore almost-white background & black axis/grid
          const lum = 0.2126*r + 0.7152*g + 0.0722*b;
          if(lum>250) continue; // too white
          // distance to blue line; penalize near-gray/black
          const dr=r-tr, dg=g-tg, db=b-tb;
          const colorDist = (dr*dr + dg*dg + db*db);
          const sat = Math.max(r,g,b) - Math.min(r,g,b);
          const score = colorDist - 2.0*sat; // prefer saturated bluish pixels
          if(score<bestScore){ bestScore=score; bestY=y; }
        }
        if(bestY<0) bestY = Math.floor(H/2);
        arr[k] = ( (H/2 - bestY) / (H/2) );
      }
      // light smoothing
      for(let i=1;i<resCols-1;i++){ arr[i] = (arr[i-1]+arr[i]+arr[i+1])/3; }
      __wt_setImportPreview(arr);
    }catch(e){ console.warn('[WT] importPlotPNG error', e); alert('Plot PNG import failed.'); }
  }

async function importWAV(file){
    try{
      const ab = await file.arrayBuffer();
      const AC = window.audioCtx || window.audioContext || window.webkitAudioContext || null;
      const ac = AC && AC.sampleRate ? AC : new (window.AudioContext||window.webkitAudioContext)();
      const buf = await ac.decodeAudioData(ab.slice(0));
      const len = buf.length;
      // mixdown to mono
      let x = new Float32Array(len);
      const ch0 = buf.getChannelData(0);
      if(buf.numberOfChannels > 1){
        const ch1 = buf.getChannelData(1);
        for(let i=0;i<len;i++){ x[i] = 0.5*(ch0[i] + ch1[i]); }
      }else{
        x.set(ch0);
      }
      // sanitize, remove DC, normalize
      for(let i=0;i<x.length;i++){ const v = x[i]; x[i] = Number.isFinite(v) ? Math.max(-1, Math.min(1, v)) : 0; }
      x = normalize(dcRemove(x));
      const TARGET = N * 32; // 2048 * 32
      // resample to 32 frames worth of samples
      const y = (x.length === TARGET) ? x : resample1D(x, TARGET);
      // slice into frames
      const out = [];
      for(let i=0;i<32;i++){
        const s = i*N;
        const fr = y.slice(s, s+N);
        out.push(normalize(dcRemove(fr)));
      }
      // update editor state
      __wt_setImportPreview(out && out[0]);; try{ __wt_setImportPreview(frames && frames[0]); }catch(e){} alert('WAV imported. Non-2048/32 sizes were auto-resampled and normalized.');
    }catch(e){
      console.warn('[WT] importWAV error', e);
      throw e;
    }
  }
zeroDC(fr); normalize(fr); out.push(fr); }
      __wt_setImportPreview(out && out[0]);; }catch(e){}
    } else { // line-scan: darkest path per column
      const cols=tmp.width, rows=tmp.height, resCols=N;
      const arr=new Float32Array(N);
      for(let k=0;k<resCols;k++){ const sx=Math.floor(k*(cols/resCols)); let bestY=0, best=1e9; for(let y=0;y<rows;y++){ const idx=(y*cols+sx)*4; const gray=(data[idx]+data[idx+1]+data[idx+2])/3; if(gray<best){ best=gray; bestY=y; } } arr[k] = (((rows-1-bestY)/(rows-1))*2)-1; }
      zeroDC(arr); normalize(arr); current.set(arr); drawGrid();
    }
  }

  if(auditionB) auditionB.onclick = ()=>{ try{ const ac=window.audioCtx || new (window.AudioContext||window.webkitAudioContext)(); const g=ac.createGain(); g.gain.value=0.2; g.connect(ac.destination); const o=ac.createOscillator(); const fr = frames[frameIdx] || current;
    const real=new Float32Array(MAX_HARM+1), imag=new Float32Array(MAX_HARM+1);
    for(let k=1;k<=MAX_HARM;k++){ let a=0,b=0; for(let n=0;n<N;n++){ const phi=TWO_PI*k*n/N, x=fr[n]; a+=x*Math.cos(phi); b+=x*Math.sin(phi); } real[k]=(2/N)*a; imag[k]=-(2/N)*b; }
    const pw = ac.createPeriodicWave(real, imag, {disableNormalization:true});
    o.setPeriodicWave(pw); o.connect(g); o.start(); setTimeout(()=>{ try{o.stop()}catch(e){} }, 400);
  }catch(e){ console.warn(e); } };

  // Export and menu refresh
  function refreshMenus(){
    const groupLabel='Custom/Wavetables';
    ['shape','subShape'].forEach(id=>{ const sel=document.getElementById(id); if(!sel) return; sel.querySelectorAll('optgroup[data-custom="1"]').forEach(g=>g.remove()); const og=document.createElement('optgroup'); og.setAttribute('data-custom','1'); og.label=groupLabel; Object.keys(LIB).sort().forEach(name=>{ const opt=document.createElement('option'); opt.value='custom:'+name; opt.textContent=name + (LIB[name].frames.length>1?' (WT)':''); og.appendChild(opt); }); sel.appendChild(og); });
  }
  if(exportB) exportB.onclick = ()=>{ const name=(nameF && nameF.value || 'CustomWave').trim(); if(!name) return; const list = frames.length?frames:[new Float32Array(current)]; const cooked=list.map(fr=>{ const arr=new Float32Array(fr); zeroDC(arr); normalize(arr); return arr; }); LIB[name]={frames:cooked, ts:Date.now()}; saveLib(); refreshMenus(); if(nameF) nameF.value=''; };

  // Public helpers
  window.CustomWaves = {
    get(n){ return LIB[n]; },
    names(){ return Object.keys(LIB); },
    makePeriodicWave(ac, name, idx=0){ const item=LIB[name]; if(!item) return null; const fr=item.frames[Math.max(0, Math.min(item.frames.length-1, idx))]; if(!fr) return null;
      const real=new Float32Array(MAX_HARM+1), imag=new Float32Array(MAX_HARM+1);
      for(let k=1;k<=MAX_HARM;k++){ let a=0,b=0; for(let n=0;n<N;n++){ const phi=TWO_PI*k*n/N, x=fr[n]; a+=x*Math.cos(phi); b+=x*Math.sin(phi); } real[k]=(2/N)*a; imag[k]=-(2/N)*b; }
      return ac.createPeriodicWave(real, imag, {disableNormalization:true});
    }
  };

  // Initial draw and menu refresh
  current.fill(0); drawGrid(); refreshMenus();

  // expose import function to other helpers
  window.__WT_EDITOR_IMPORT = importPNG;
})();
</script>


<script>
/* ========================= Custom/Wavetable ‚Äî AudioWorklet Morphing Oscillator =========================
   - Phase-continuous, 32 frames x 2048 samples
   - Multi-resolution mipmaps per frame (downsampled by 2 with [0.25,0.5,0.25] LPF)
   - Editor preview uses same engine
   - CC1 (Mod Wheel) -> Morph [0..1] with ~3.5ms smoothing
   - CSV (2048x32) + PNG import (existing) with resample/normalize/DC removal/clamp
   - Global library, newest-first; rename/delete; menus updated under "Custom/Wavetables"
   Non-goals: touching sequencer/AI/FX/presets/theme/orientation/voice mgmt.
*/
(function(){
  if (window.__WT_V2_INSTALLED__) return; window.__WT_V2_INSTALLED__ = true;

  const WT_KEY = 'stagsynth_wt_lib_v2';
  const LEGACY_KEYS = ['stagsynth_wt_lib_v1','stagsynth_wt_lib']; // if present, we'll import
  const MAX_FRAMES = 32, FRAME_SIZE = 2048;

  // ---- Utils ----
  const clamp=(v,min,max)=>v<min?min:v>max?max:v;
  function dcRemove(arr){
    let sum=0; for(let i=0;i<arr.length;i++) sum+=arr[i];
    const mean=sum/arr.length; const out=new Float32Array(arr.length);
    for(let i=0;i<arr.length;i++) out[i]=arr[i]-mean;
    return out;
  }
  function normalize(arr){
    let peak=0; for(let i=0;i<arr.length;i++){ const a=Math.abs(arr[i]); if(a>peak) peak=a; }
    if(peak<1e-9) return arr.slice();
    const k = 0.95/peak; const out=new Float32Array(arr.length);
    for(let i=0;i<arr.length;i++) out[i]=clamp(arr[i]*k,-0.95,0.95);
    return out;
  }
  function resample1D(src, newN){
    const out=new Float32Array(newN);
    const N=src.length;
    for(let i=0;i<newN;i++){
      const t = i*(N-1)/(newN-1);
      const i0 = Math.floor(t), i1 = Math.min(N-1, i0+1);
      const f = t - i0;
      out[i] = src[i0]*(1-f) + src[i1]*f;
    }
    return out;
  }
  function makeMipmaps(frame){
    // successive half-band low-pass then decimate by 2 using 0.25/0.5/0.25 FIR
    const levels=[];
    let cur = frame;
    while(cur.length >= 64){
      levels.push(cur);
      const n = cur.length;
      const tmp = new Float32Array(n);
      // LPF
      tmp[0] = 0.75*cur[0] + 0.25*cur[1];
      for(let i=1;i<n-1;i++) tmp[i] = 0.25*cur[i-1] + 0.5*cur[i] + 0.25*cur[i+1];
      tmp[n-1] = 0.75*cur[n-1] + 0.25*cur[n-2];
      // decimate by 2
      const half = new Float32Array(Math.floor(n/2));
      for(let i=0;i<half.length;i++) half[i]=tmp[i*2];
      cur = half;
    }
    if(levels[levels.length-1] !== cur) levels.push(cur);
    return levels; // array of Float32Array (2048,1024,512,...)
  }
  function ensureAudio(){ return window.ensureAudio ? window.ensureAudio() : Promise.resolve(); }
  function nowAC(){ try{ return (window.audioCtx||{}).currentTime||0; }catch{ return 0; } }

  // ---- Library ----
  function loadLib(){
    // Try v2 first
    let lib={};
    try{ const raw=localStorage.getItem(WT_KEY); if(raw) lib=JSON.parse(raw)||{}; }catch(e){}
    // Import legacy once
    if(Object.keys(lib).length===0){
      for(const k of LEGACY_KEYS){
        try{
          const raw=localStorage.getItem(k);
          if(raw){
            const old=JSON.parse(raw)||{};
            // old format may be {name:{frames:[arrays]}} or similar
            for(const nm in old){
              if(!lib[nm] && old[nm]?.frames){
                lib[nm]={ frames: old[nm].frames.map(f=>Array.from(f)), ts: Date.now() };
              }
            }
            break;
          }
        }catch(e){}
      }
      try{ if(Object.keys(lib).length>0) localStorage.setItem(WT_KEY, JSON.stringify(lib)); }catch(e){}
    }
    return lib;
  }
  function saveLib(lib){ try{ localStorage.setItem(WT_KEY, JSON.stringify(lib)); }catch(e){} }
  function listNamesNewestFirst(lib){ return Object.keys(lib).sort((a,b)=>(lib[b]?.ts||0)-(lib[a]?.ts||0)); }

  // ---- Worklet ----
  const WORKLET_NAME = 'morph-wavetable';
  const WORKLET_URL = URL.createObjectURL(new Blob([
`class MorphWTProcessor extends AudioWorkletProcessor{
  static get parameterDescriptors(){ return [
    { name:'frequency', defaultValue:440, minValue:0, maxValue:24000, automationRate:'a-rate' },
    { name:'morph',     defaultValue:0,   minValue:0, maxValue:1,     automationRate:'a-rate' },
    { name:'gain',      defaultValue:1,   minValue:0, maxValue:2,     automationRate:'k-rate' }
  ]; }
  constructor(){
    super();
    this.frames = []; // array of mip arrays per frame: [ [Float32Array(lenL0), Float32Array(lenL1), ...], ... ]
    this.levelLens = []; // e.g., [2048,1024,512,...]
    this.phase = 0;
    this.sampleRate_ = sampleRate;
    this.lastFreq = 440;
    this.port.onmessage = (ev)=>{
      const d = ev.data||{};
      if(d.type==='tables'){
        this.frames = d.frames||[];
        this.levelLens = d.levelLens||[];
        this.phase = 0;
      }
    };
  }
  pickLevel(freq){
    // choose table length so that ~ >= 1 sample per period segment; heuristic: targetLen ~ sr/freq
    const target = this.sampleRate_/Math.max(1e-6,freq);
    let bestIdx = 0, bestLen = this.levelLens[0]||2048;
    for(let i=0;i<this.levelLens.length;i++){
      const L=this.levelLens[i];
      if(Math.abs(L-target) < Math.abs(bestLen-target)){ bestLen=L; bestIdx=i; }
      if(L<target){ bestIdx=i; break; }
    }
    return bestIdx;
  }
  process(inputs, outputs, parameters){
    const out=outputs[0]; const ch=out[0]; if(!ch) return true;
    if(this.frames.length===0) { for(let i=0;i<ch.length;i++) ch[i]=0; return true; }

    const freq = parameters.frequency;
    const morph = parameters.morph;
    const gain = parameters.gain[0]||1;

    const numFrames = this.frames.length;
    const lvlLens = this.levelLens;

    let phase=this.phase;
    const sr=this.sampleRate_;

    for(let i=0;i<ch.length;i++){
      const f = (freq.length>1)?freq[i]:freq[0];
      const m = clamp((morph.length>1)?morph[i]:morph[0],0,1);
      const idx = m*(numFrames-1);
      const i0 = Math.max(0, Math.min(numFrames-1, Math.floor(idx)));
      const i1 = Math.min(numFrames-1, i0+1);
      const frac = idx - i0;

      const lvlIdx = this.pickLevel(f);
      const table0 = this.frames[i0][lvlIdx];
      const table1 = this.frames[i1][lvlIdx];
      const L = table0.length|0;

      // phase increment in table samples
      const inc = f * L / sr;

      // sample both frames with linear interp
      const p0 = phase % L;
      const j = p0|0, t = p0 - j, j1=(j+1)%L;
      const a0 = table0[j]*(1-t) + table0[j1]*t;
      const a1 = table1[j]*(1-t) + table1[j1]*t;
      const s = (a0*(1-frac) + a1*frac) * gain;

      ch[i]=s;

      phase += inc;
      if(phase >= L) phase -= L;
    }
    this.phase = phase;
    return true;
  }
}
registerProcessor('${WORKLET_NAME}', MorphWTProcessor);`
  ],{type:'application/javascript'}));

  async function ensureWorklet(){
    await ensureAudio();
    const ac = window.audioCtx;
    if(!ac) throw new Error('Audio not ready');
    if(!ac.audioWorklet) throw new Error('AudioWorklet unavailable');
    try{ await ac.audioWorklet.addModule(WORKLET_URL); }catch(e){
      if(!String(e).includes('already registered')) throw e;
    }
    return ac;
  }

  // Build node from frames (Float32Array[] of length MAX_FRAMES; will resample if needed)
  function framesToMip(framesIn){
    // sanitize to 32 frames of 2048 samples
    let frames = framesIn.map(f=>{
      const a = Float32Array.from(f);
      const d = dcRemove(a);
      const n = normalize(d);
      const res = (n.length===FRAME_SIZE)?n:resample1D(n, FRAME_SIZE);
      return res;
    });
    if(frames.length>MAX_FRAMES) frames = frames.slice(0,MAX_FRAMES);
    while(frames.length<MAX_FRAMES) frames.push(frames[frames.length-1]);
    // mipmaps
    const mips = frames.map(makeMipmaps);
    // collect level lengths
    const levelLens = [];
    mips[0].forEach(level=> levelLens.push(level.length));
    return { mips, levelLens };
  }

  function makeNodeFromFrames(ac, freq, frames){
    const { mips, levelLens } = framesToMip(frames);
    const node = new AudioWorkletNode(ac, WORKLET_NAME, { numberOfOutputs:1, outputChannelCount:[1] });
    // pack for transfer: we need an array of arrays of Float32Array. We can send as-is; structured clone will handle TypedArrays.
    node.port.postMessage({ type:'tables', frames:mips, levelLens });
    const freqParam = node.parameters.get('frequency');
    const morphParam = node.parameters.get('morph');
    const gainParam = node.parameters.get('gain');
    if(freqParam) freqParam.value = freq||440;
    if(morphParam) morphParam.value = window.__WT_MORPH__ ?? 0;
    if(gainParam) gainParam.value = 1.0;
    // Provide Oscillator-like proxy so existing voice code keeps working
    const proxy = {
      __node: node,
      connect: (...a)=>node.connect(...a),
      disconnect: (...a)=>{ try{ node.disconnect(...a) }catch(e){} },
      start: ()=>{}, // envelope handles gating; we keep oscillator running
      stop: (when)=>{ /* allow graceful GC */ setTimeout(()=>{ try{ node.disconnect(); }catch(e){} }, 1000); },
      get frequency(){ return { get value(){ return freqParam?.value ?? 0; }, set value(v){ try{ freqParam?.setTargetAtTime(v, ac.currentTime, 0.003); }catch{ if(freqParam) freqParam.value=v; } } } }
    };
    // Register to receive morph updates
    try{ window.CustomWT && window.CustomWT._register(proxy, morphParam, ac); }catch(e){}
    return proxy;
  }

  // ---- Global CustomWT API ----
  const CustomWT = {
    _lib: loadLib(),
    _morph: 0,
    _nodes: new Set(),
    _register(proxy, morphParam, ac){ this._nodes.add({proxy, morphParam, ac}); },
    _unregister(proxy){ for(const rec of Array.from(this._nodes)){ if(rec.proxy===proxy) this._nodes.delete(rec); } },
    getMorph(){ return this._morph; },
    setMorph(v){
      v = clamp(v,0,1);
      this._morph = v;
      const t = nowAC();
      for(const rec of this._nodes){
        try{ rec.morphParam?.setTargetAtTime(v, rec.ac.currentTime, 0.0035); }catch(e){}
      }
      // reflect UI frame slider if present
      const fr = document.getElementById('wt_frame_idx'); const rd=document.getElementById('wt_frame_readout');
      try{
        if(fr && fr.max){ const N=parseInt(fr.max||'0')+1; const idx=Math.round(v*(N-1)); fr.value=String(idx); fr.dispatchEvent(new Event('input',{bubbles:true})); if(rd) rd.textContent=(idx+1)+'/'+N; }
      }catch(e){}
    },
    list(){ return listNamesNewestFirst(this._lib); },
    get(name){ return this._lib[name]; },
    save(name, frames){
      const nm = String(name||'Custom WT').trim() || 'Custom WT';
      this._lib[nm] = { frames: frames.map(f=>Array.from(f)), ts: Date.now() };
      saveLib(this._lib);
      this.refreshMenus(nm);
    },
    rename(oldName, newName){
      if(!this._lib[oldName]) return;
      const rec=this._lib[oldName];
      delete this._lib[oldName];
      this._lib[newName]={...rec, ts: Date.now()};
      saveLib(this._lib);
      this.refreshMenus(newName);
    },
    delete(name){
      delete this._lib[name]; saveLib(this._lib); this.refreshMenus();
    },
    refreshMenus(sel){
      const groups = Array.from(document.querySelectorAll('optgroup[data-custom="1"]'));
      groups.forEach(g=>{ g.innerHTML=''; });
      const names = this.list();
      names.forEach(nm=>{
        const o=document.createElement('option'); o.value='custom:'+nm; o.textContent=nm;
        groups.forEach(g=>g.appendChild(o.cloneNode(true)));
      });
      if(sel){
        const sels = [document.getElementById('shape'), document.getElementById('subShape')];
        sels.forEach(s=>{ if(!s) return; const idx = Array.from(s.options).findIndex(o=>o.value==='custom:'+sel); if(idx>=0) s.selectedIndex = idx; });
      }
    },
    makeNode(ac, freq, nameOrFrames){
      if(Array.isArray(nameOrFrames)){ return makeNodeFromFrames(ac, freq, nameOrFrames); }
      const rec = this._lib[nameOrFrames]; if(!rec || !rec.frames) return null;
      const frames = rec.frames.map(a=>Float32Array.from(a));
      return makeNodeFromFrames(ac, freq, frames);
    }
  };
  window.CustomWT = CustomWT;

  // ---- Hook into synth voice creation via oscFactory ----
  (function(){
    const prevFactory = window.oscFactory;
    window.oscFactory = function(ac, freq, type, params){
      if(typeof type==='string' && type.startsWith('custom:')){
        const nm = type.slice(7);
        const node = CustomWT.makeNode(ac, freq||440, nm);
        if(!node){ console.warn('[WT] Unknown wavetable', nm); return ac.createOscillator(); }
        return node;
      }
      // fallback to previous factory or default OscillatorNode
      if(typeof prevFactory === 'function') return prevFactory(ac, freq, type, params);
      const o = ac.createOscillator(); o.type = (type||'sawtooth'); o.frequency.value = freq||440; return o;
    };
  })();

  // ---- Map CC1 ‚Üí morph ----
  (function(){
    const _onMIDI = window.onMIDI;
    window.onMIDI = function(ev){
      try{
        const [st,d1,d2]=ev.data||[]; const cmd=st&0xF0;
        if(cmd===0xB0 && (d1|0)===1){ // Mod wheel
          const norm = (d2|0)/127;
          CustomWT.setMorph(norm);
        }
      }catch(e){}
      try{ return _onMIDI?.call(this, ev); }catch(e){}
    };
  })();

  // ---- Editor: rewire preview to use same engine, add CSV + rename/delete UI and clearer button states ----
  function enhanceUI(){
    const panel=document.getElementById('customPanel'); if(!panel) return;

    // Button states & focus/active
    const style=document.createElement('style');
    style.textContent = `
      #customPanel .pill{position:relative; color:#eee}
      #customPanel .pill:hover{box-shadow:0 0 0 3px rgba(255,255,255,.08) inset}
      #customPanel .pill:active{transform:translateY(1px); opacity:.95}
      #customPanel .pill:focus-visible{outline:2px solid #ffd34d}
      #customPanel .pill[disabled]{opacity:.45; cursor:not-allowed}
      #customPanel input[type="file"]::file-selector-button{ color:#eee; background:#202020; border:1px solid #444; border-radius:8px; padding:6px 10px }
      #customPanel .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
      #wt_list{display:flex; gap:6px; flex-wrap:wrap; margin-top:8px}
      #wt_list .tag{background:#1a1212; border:1px solid #3a2323; padding:4px 8px; border-radius:999px; display:flex; gap:6px; align-items:center}
      #wt_list .tag button{ background:transparent; border:0; color:#ffb84d; cursor:pointer; padding:2px 4px; border-radius:6px }
      #wt_list .tag button:hover{ background:#332018 }
    
#wt_import_png, #wt_import_csv, #wt_import_wav { display:none !important; }
#wt_list { display:none !important; }

#customPanel #wt_preview_chk, #customPanel label:has(#wt_preview_chk), #customPanel #wt_gen_morph { display:none !important; }


#customPanel pre, #customPanel code { display:none !important; }
#customPanel .debug, #customPanel [data-debug] { display:none !important; }

.app pre, .app code {display:none !important;}`;
    document.head.appendChild(style);

    // CSV controls
    const pngRow = panel.querySelector('#wt_import_png')?.parentElement;
    if(pngRow){
// WAV controls
    if(pngRow){
      const wavInp = document.createElement('input'); wavInp.type='file'; wavInp.id='wt_import_wav'; wavInp.accept='.wav,audio/wav,audio/x-wav';
      const wavBtn = document.createElement('button'); wavBtn.id='wt_load_wav'; wavBtn.className='pill'; wavBtn.textContent='Import WAV';
      pngRow.appendChild(wavInp); pngRow.appendChild(wavBtn);
    }

      const csvInp = document.createElement('input'); csvInp.type='file'; csvInp.id='wt_import_csv'; csvInp.accept='.csv,text/csv';
      const csvBtn = document.createElement('button'); csvBtn.id='wt_load_csv'; csvBtn.className='pill'; csvBtn.textContent='Import CSV';
      pngRow.appendChild(csvInp); pngRow.appendChild(csvBtn);

    // Import Preview panel (separate from Draw/Frames)
    let prevWrap = document.getElementById('wt_import_preview');
    if(!prevWrap){
      prevWrap = document.createElement('div');
      prevWrap.id = 'wt_import_preview';
      prevWrap.style.cssText = 'margin-top:10px;padding:8px;border:1px dashed #333;border-radius:8px;background:#0b0b0b';
      prevWrap.innerHTML = `
        <canvas id="wt_import_preview_c" width="560" height="120" style="width:100%;max-width:640px;height:140px;background:#151515;border-radius:8px"></canvas>
        <div id="wt_import_status" style="margin-top:6px;color:#9aa">Waiting for import‚Ä¶</div>
`;
      pngRow.parentElement.insertBefore(prevWrap, pngRow.parentElement.firstChild);

    // Reorder: place Draw Export + Name and Import Preview above import buttons
    try{
      const drawExportBtn = document.getElementById('wt_export');
      const drawName = document.getElementById('wt_name');
      const row = document.getElementById('wt_import_png')?.parentElement;
      if(row && drawExportBtn){
        const wrapTop = document.createElement('div');
        wrapTop.style.cssText='display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin:6px 0';
        if(drawName && drawName.parentElement) wrapTop.appendChild(drawName.parentElement);
        wrapTop.appendChild(drawExportBtn);
        row.parentElement.insertBefore(wrapTop, row);
      }
      const importPrev = document.getElementById('wt_import_preview');
      if(importPrev){
        const row = document.getElementById('wt_import_png')?.parentElement;
        if(row) row.parentElement.insertBefore(importPrev, row);
      }
    }catch(e){}

    }

    }

    // Library chips + rename/delete
    let listDiv = document.getElementById('wt_list');
    if(!listDiv){ listDiv = document.createElement('div'); listDiv.id='wt_list'; panel.appendChild(listDiv); }
    function refreshList(){
      const names = CustomWT.list(); listDiv.innerHTML='';
      names.forEach(nm=>{
        const tag = document.createElement('span'); tag.className='tag'; tag.innerHTML = `<strong>${nm}</strong>`;
        const rn = document.createElement('button'); rn.textContent='rename'; rn.title='Rename';
        const del= document.createElement('button'); del.textContent='delete'; del.title='Delete';
        rn.onclick=()=>{
          const nw = prompt('Rename wavetable', nm)||''.trim();
          if(nw && nw!==nm){ CustomWT.rename(nm, nw); refreshList(); }
        };
        del.onclick=()=>{ if(confirm('Delete "'+nm+'"?')){ CustomWT.delete(nm); refreshList(); } };
        tag.appendChild(rn); tag.appendChild(del); listDiv.appendChild(tag);
      });
    }
    CustomWT.refreshMenus(); refreshList();

    // Preview: replace original listeners
    function getCurrentFrames(){
      try{
        // Reconstruct frames from thumbnails list #wt_frames (each thumb has canvas with 2048 samples stored in dataset? if not, fallback to internal buffer)
        const thumbs = Array.from(document.querySelectorAll('#wt_frames .thumb canvas'));
        if(thumbs.length>0 && thumbs[0].dataset && thumbs[0].dataset.samples){
          return thumbs.map(c=>Float32Array.from(JSON.parse(c.dataset.samples||'[]')));
        }
      }catch(e){}
      // fallback: if there is a builder API exposed on window (e.g., LIB_FRAMES)
      return (window.__WT_EDIT_FRAMES__||[]).map(f=>Float32Array.from(f));
    }
    function setPreviewOn(on){
      window.__WT_PREVIEW_NODE__ && (function(){
        try{ window.__WT_PREVIEW_NODE__.disconnect(); }catch(e){};
        window.__WT_PREVIEW_NODE__ = null;
      })();
      const chk=document.getElementById('wt_preview_chk');
      if(on){
        ensureWorklet().then(()=>{
          const ac=window.audioCtx;
          const frames=getCurrentFrames();
          if(!frames || frames.length===0){ if(chk) chk.checked=false; return; }
          const node = CustomWT.makeNode(ac, 220, frames);
          const g = ac.createGain(); g.gain.value = 0.2; node.connect(g); g.connect(ac.destination);
          window.__WT_PREVIEW_NODE__ = node;
        });
      }
    }
    const chk = document.getElementById('wt_preview_chk');
    if(chk){
      const repl = chk.cloneNode(true); chk.replaceWith(repl);
      repl.addEventListener('change', ()=> setPreviewOn(repl.checked));
    }
    const frameSlider=document.getElementById('wt_frame_idx');
    if(frameSlider){
      const repl=frameSlider.cloneNode(true); frameSlider.replaceWith(repl);
      repl.addEventListener('input', (e)=>{
        const N=parseInt(repl.max||'0')+1;
        const idx=parseInt(repl.value||'0')|0;
        CustomWT.setMorph(N>1 ? idx/(N-1) : 0);
      });
    }

    // Import CSV handler (expects 2048x32, no header; will resample/normalize if different)
    const csvBtn=document.getElementById('wt_load_csv');
    const csvInp=document.getElementById('wt_import_csv');
    if(csvBtn && csvInp){
      csvBtn.addEventListener('click', ()=> csvInp.click());
      csvInp.addEventListener('change', async (e)=>{ const f=e.target.files?.[0]; if(!f) return; try{ await importCSVGeneric(f); }catch(err){ console.warn('[WT] CSV import failed', err); alert('CSV import failed.'); } }, {passive:true});
    }

    
// Wire WAV button (safe)
    const wavBtn=document.getElementById('wt_load_wav');
    const wavInp=document.getElementById('wt_import_wav');
    if(wavBtn && wavInp){
      wavBtn.addEventListener('click', ()=> wavInp.click());
      wavInp.addEventListener('change', async (e)=>{
        const f=e.target.files?.[0]; if(!f) return;
        try{ await importWAV(f); }catch(err){ console.warn('[WT] WAV import failed', err); alert('WAV import failed. See console.'); }
      }, {passive:true});
    }
// Export button: ensure we capture current frames (from existing editor) and save with prompt
    const exportBtn = document.getElementById('wt_export');
    if(exportBtn){
      const repl = exportBtn.cloneNode(true); exportBtn.replaceWith(repl);
      repl.addEventListener('click', ()=>{
        // Try to read editor-owned frames; fall back to thumbs canvases
        let frames = (window.__WT_EDIT_FRAMES__||[]).map(f=>Float32Array.from(f));
        if(frames.length===0){
          try{
            const thumbs = Array.from(document.querySelectorAll('#wt_frames .thumb canvas'));
            if(thumbs.length>0 && thumbs[0].dataset && thumbs[0].dataset.samples){
              frames = thumbs.map(c=>Float32Array.from(JSON.parse(c.dataset.samples||'[]')));
            }
          }catch(e){}
        }
        if(frames.length===0){ alert('No frames to export'); return; }
        frames = frames.map(f=> normalize(dcRemove( (f.length===FRAME_SIZE)?f:resample1D(f,FRAME_SIZE) )) );
        while(frames.length<MAX_FRAMES) frames.push(frames[frames.length-1].slice());
        let nm = (document.getElementById('wt_name')?.value||'').trim();
        if(!nm){ nm = prompt('Name for wavetable','Custom '+new Date().toLocaleTimeString())||'Custom WT'; }
        CustomWT.save(nm, frames);
        CustomWT.refreshMenus(nm);
        alert('Exported to Synth as "'+nm+'". Find it under Custom/Wavetables.');
        refreshList();
      });
    }
  }

  // Apply UI enhancements once DOM is ready
  document.addEventListener('DOMContentLoaded', ()=>{
    try{ enhanceUI(); }catch(e){ console.warn('[WT] UI enhance failed', e); }
    // ensure menus reflect existing library
    try{ CustomWT.refreshMenus(); }catch(e){}
  });

})(); // end IIFE
</script>


<script>
document.addEventListener('DOMContentLoaded', ()=>{
  const panel=document.getElementById('customPanel');
  if(!panel) return;
  const ac = window.audioCtx;
  const hasAW = !!((ac && ac.audioWorklet) || (window.AudioWorkletNode));
  /* AW notice removed */
});
</script>


<script>
/* ========= Sequencer Step Strip Visibility Fix (isolated, no core edits) ========= */
(function(){
  try{
    function ensureStripContainer(){
      var strip = document.getElementById('seqStepsStrip');
      var keypad = document.getElementById('keypad');
      if(!strip){
        strip = document.createElement('div');
        strip.id = 'seqStepsStrip';
        strip.style.display = 'none';
        // place before keypad if possible
        if(keypad && keypad.parentElement){
          keypad.parentElement.insertBefore(strip, keypad);
        }else{
          (document.body || document.documentElement).prepend(strip);
        }
      }
      return strip;
    }

    function buildGrid(strip, steps){
      steps = Math.max(1, Math.min(32, steps|0 || 16));
      if(strip.childElementCount !== steps){
        strip.innerHTML = '';
        for(var i=0;i<steps;i++){
          var led = document.createElement('div');
          led.className = 'led';
          led.dataset.index = String(i);
          strip.appendChild(led);
        }
      }
      // basic CSS grid safety if app CSS failed to apply
      strip.style.display = 'grid';
      strip.style.gridTemplateColumns = 'repeat(' + steps + ', 1fr)';
      strip.style.gap = strip.style.gap || '5px';
    }

    function currentSteps(){
      var el = document.getElementById('seq_steps');
      var v = el ? parseInt(el.value||'16',10) : 16;
      return (isFinite(v) ? v : 16);
    }

    function refresh(){
      var strip = ensureStripContainer();
      var on = (document.getElementById('seqToggle')?.getAttribute('aria-pressed') === 'true');
      if(on){
        strip.style.display = 'grid';
        buildGrid(strip, currentSteps());
      }else{
        strip.style.display = 'none';
      }
      try{ if(window.updateSeqGridForSteps) window.updateSeqGridForSteps(); }catch(e){}
      try{ if(window.renderHighlights) window.renderHighlights(0,false); }catch(e){}
    }

    document.addEventListener('DOMContentLoaded', function(){
      ensureStripContainer();
      refresh();

      // Hook the Sequencer toggle safely
      var t = document.getElementById('seqToggle');
      if(t && !t.__wtSeqFix){
        t.__wtSeqFix = true;
        t.addEventListener('click', function(){ setTimeout(refresh, 0); }, {passive:true});
      }

      // React to step count changes
      var steps = document.getElementById('seq_steps');
      if(steps && !steps.__wtSeqFix){
        steps.__wtSeqFix = true;
        steps.addEventListener('input', function(){ setTimeout(refresh, 0); }, {passive:true});
        steps.addEventListener('change', function(){ setTimeout(refresh, 0); }, {passive:true});
      }

      // Also listen to custom events your app already emits
      window.addEventListener('audio:ready', refresh);
      window.addEventListener('rebuild:keypad', refresh);
    });
  }catch(e){
    console.warn('[SeqFix] Failed to install strip fixer:', e);
  }
})();
</script>


<script>
/* === Tiny patch: ensure original Clear button binding is installed === */
(function(){
  function ensureOriginalClearBinding(){
    try{ if (window.ensureStrip) window.ensureStrip(); }catch(e){}
  }
  document.addEventListener('DOMContentLoaded', ensureOriginalClearBinding);
  window.addEventListener('audio:ready', ensureOriginalClearBinding);
  window.addEventListener('rebuild:keypad', ensureOriginalClearBinding);
})();
</script>


<script>
/* === Sequencer Clear button bridge: forwards visible #seqClearBtn to original #seq_clear === */
(function(){
  function install(){
    var vis = document.getElementById('seqClearBtn');
    var orig = document.getElementById('seq_clear');
    if(!vis || !orig || vis.__clearBridge) return;
    vis.__clearBridge = true;
    vis.addEventListener('click', function(ev){
      try{ ev.preventDefault(); ev.stopPropagation(); }catch(e){}
      try{ orig.click(); }catch(e){}
    }, {passive:false});
  }
  document.addEventListener('DOMContentLoaded', install);
  window.addEventListener('audio:ready', install);
  window.addEventListener('rebuild:keypad', install);
})();
</script>


<script>
// === Group Frame slider + Frames pane with Draw ===
(function(){
  try{
    const cvs = document.getElementById('wt_canvas');
    const panel = document.getElementById('customPanel');
    const frames = document.getElementById('wt_frames');
    const slider = document.getElementById('wt_frame_idx');
    const readout = document.getElementById('wt_frame_readout');
    const sliderWrap = slider ? slider.parentElement : null;
    if(cvs && panel && (frames || sliderWrap)){
      // Build a compact group
      const grp = document.createElement('div');
      grp.id = 'wt_draw_frames_group';
      grp.style.cssText = 'margin-top:8px;display:grid;grid-template-columns:1fr;gap:8px;align-items:start';
      // slider row
      if(sliderWrap){
        const row = document.createElement('div');
        row.style.cssText='display:flex;align-items:center;gap:10px;flex-wrap:wrap';
        row.appendChild(sliderWrap);
        if(readout) row.appendChild(readout);
        grp.appendChild(row);
      }
      // frames pane
      if(frames) grp.appendChild(frames);
      // insert right after the canvas container
      const cvWrap = cvs.parentElement;
      if(cvWrap && cvWrap.parentElement){
        cvWrap.parentElement.insertBefore(grp, cvWrap.nextSibling);
      }else{
        panel.insertBefore(grp, panel.firstChild);
      }
    }
  }catch(e){ console.warn('[WT] reorder frames group error', e); }
})();
</script>


<script>
(function(){
  try{
    const panel = document.getElementById('customPanel');
    if(!panel) return;
    // Hide library name chips & any helper notes
    const list = document.getElementById('wt_list');
    if(list) list.style.display='none';
    // Remove small paragraphs that mention routing into oscillators
    panel.querySelectorAll('div, p, small, span').forEach(el=>{
      const t = (el.textContent||'').toLowerCase();
      if(t && t.length<260 && /routing|oscillator menu|shape dropdown|flows into/i.test(t)){
        el.remove();
      }
    });
  }catch(e){}
})();
</script>


<script>
(function(){
  try{
    const a = document.getElementById('wt_export'); if (a) a.textContent = 'Export to Oscs';
    const b = document.getElementById('wt_import_export'); if (b) b.textContent = 'Export to Oscs';
  }catch(e){}
})();
</script>


<script>
(function(){
  try{
    const pngInp = document.getElementById('wt_import_png');
    const csvInp = document.getElementById('wt_import_csv');
    const wavInp = document.getElementById('wt_import_wav');
    const nameF = document.getElementById('wt_import_name');
    const expB = document.getElementById('wt_import_export');
    if(!pngInp || !expB || !nameF) return;
    const row = pngInp.parentElement; // the row that also holds the PNG/CSV/WAV buttons
    if(!row || !row.parentElement) return;
    // Build a new row after the import buttons row
    let outRow = document.getElementById('wt_import_export_row');
    if(!outRow){
      outRow = document.createElement('div');
      outRow.id = 'wt_import_export_row';
      outRow.style.cssText = 'display:flex;align-items:center;gap:10px;flex-wrap:wrap;margin-top:8px';
      row.parentElement.insertBefore(outRow, row.nextSibling);
    }
    // Move the Name field's whole label (if wrapped), else move the input
    const nameWrap = nameF.parentElement && nameF.parentElement.tagName.toLowerCase()==='label' ? nameF.parentElement : nameF;
    if (nameWrap && nameWrap.parentElement) outRow.appendChild(nameWrap);
    outRow.appendChild(expB);
  }catch(e){ console.warn('[WT] move import export row failed', e); }
})();
</script>

<script>
async function importCSVGeneric(file){
    const txt = await file.text();
    const lines = txt.trim().split(/\r?\n/).filter(Boolean);
    const rows = lines.map(line => line.split(/[,;\s]+/).map(Number).filter(v=>Number.isFinite(v))).filter(r=>r.length>0);
    if(rows.length===0){ alert('CSV contained no numeric data.'); return; }
    // Choose the column with the largest variance (assume that is the waveform column)
    const cols = Math.max(...rows.map(r=>r.length));
    const series = [];
    for(let c=0;c<cols;c++){
      const col=[];
      for(const r of rows){ if(r.length>c) col.push(r[c]); }
      if(col.length>0) series.push(col);
    }
    let bestIdx = 0, bestVar = -1;
    for(let i=0;i<series.length;i++){
      const a=series[i]; let s=0; for(const v of a) s+=v; const mu=s/a.length;
      let v=0; for(const x of a){ const d=x-mu; v+=d*d; } v/=a.length;
      if(v>bestVar){ bestVar=v; bestIdx=i; }
    }
    let y = Float32Array.from(series[bestIdx] || series[0]);
    // Resample to 2048
    const N = 2048;
    if(y.length!==N){
      const out = new Float32Array(N);
      for(let i=0;i<N;i++){ const t=i*(y.length-1)/(N-1); const i0=t|0, i1=Math.min(y.length-1,i0+1); const f=t-i0; out[i]=y[i0]*(1-f)+y[i1]*f; }
      y = out;
    }
    // DC remove + normalize
    let s=0; for(let i=0;i<y.length;i++) s+=y[i]; const dc=s/y.length; for(let i=0;i<y.length;i++) y[i]-=dc;
    let peak=1e-9; for(let i=0;i<y.length;i++){ const a=Math.abs(y[i]); if(a>peak) peak=a; }
    const k = peak>0 ? 0.95/peak : 1; for(let i=0;i<y.length;i++) y[i]=Math.max(-0.95, Math.min(0.95, y[i]*k));
    // Update preview; do not auto-save
    __wt_setImportPreview(y);
    const st = document.getElementById('wt_import_status'); if(st) st.textContent = 'CSV parsed ‚Äî review preview then Export.';
  }
</script>

<!-- WT Overlay: styles -->
<style id="wt_overlay_css">
:root{
  --wt-bg:#0b0e12; --wt-fg:#e8eef7; --wt-sub:#a9b7c6; --wt-accent:#5cc8ff;
  --wt-panel:#131923; --wt-line:#223142; --wt-chip:#0f141b; --wt-ok:#3ddc97; --wt-warn:#ffca3a; --wt-err:#ff595e;
}
.wt-hidden{display:none}
.wt-overlay{position:fixed;inset:0;display:none;z-index:999999}
.wt-overlay[aria-hidden="false"]{display:block}
.wt-mask{position:absolute;inset:0;background:rgba(0,0,0,.5);backdrop-filter:saturate(0.8) blur(1.5px)}
.wt-panel{position:absolute;right:0;top:0;bottom:0;width:min(100%,1000px);background:var(--wt-panel);border-left:1px solid var(--wt-line);box-shadow:-8px 0 24px rgba(0,0,0,.35);display:flex;flex-direction:column;color:var(--wt-fg);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
.wt-head{display:flex;align-items:center;gap:8px;justify-content:space-between;padding:12px 14px;border-bottom:1px solid var(--wt-line);background:#0f1620}
.wt-title{font-size:13px;letter-spacing:.25px}
.wt-body{padding:14px;overflow:auto}
.wt-pill{padding:8px 12px;border-radius:999px;border:1px solid var(--wt-line);background:var(--wt-chip);color:var(--wt-fg);cursor:pointer}
.wt-pill[aria-pressed="true"]{background:#0b1922;border-color:#203545;box-shadow:0 0 0 1px #1f3b52 inset;color:#bfeaff}
.wt-bar{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.wt-tag{font-size:12px;color:#8ea1b3;padding:2px 8px;border:1px solid var(--wt-line);border-radius:999px;background:#0e141b}
.wt-status{font-size:13px;color:#b2c7da}
.wt-status.ok{color:var(--wt-ok)} .wt-status.warn{color:var(--wt-warn)} .wt-status.err{color:var(--wt-err)}
.wt-input{background:#0b0f14;border:1px solid var(--wt-line);border-radius:8px;color:#e8eef7;padding:8px 10px}
.wt-radio{display:inline-flex;gap:6px;align-items:center;padding:4px 8px;border:1px solid var(--wt-line);border-radius:999px;background:#0b0f14}
.wt-tiny{font-size:12px;color:#9cb2c6}
canvas.wt-main{width:100%;height:280px;border-radius:8px;background:#0b0f14;border:1px solid var(--wt-line);touch-action:none}
canvas.wt-thumb{width:96px;height:48px;border-radius:6px;background:#0b0f14;border:1px solid var(--wt-line);cursor:pointer}
.wt-thumbs{display:flex;flex-wrap:wrap;gap:8px;max-height:200px;overflow:auto;padding:8px;border:1px dashed var(--wt-line);border-radius:8px;background:#0b0f14}
.wt-thumbs .wt-thumb[data-active="true"]{outline:2px solid var(--wt-accent);}
.wt-grid2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
.wt-fab{position:fixed;right:16px;bottom:16px;z-index:999998;background:#0f141b;border:1px solid var(--wt-line);color:#cfe8ff;border-radius:999px;padding:10px 12px;font-weight:700;letter-spacing:.3px;cursor:pointer}
</style>

<!-- WT Overlay: markup -->
<div class="wt-overlay" id="wt_overlay" aria-hidden="true">
  <div class="wt-mask" id="wt_mask"></div>
  <div class="wt-panel" role="dialog" aria-modal="true" aria-labelledby="wt_title">
    <div class="wt-head">
      <div class="wt-bar">
        <strong id="wt_title" class="wt-title">Custom / Wavetable Editor <span class="wt-tag">WT v4.0</span></strong>
        <span id="wt_import_status" class="wt-status">Ready</span>
      </div>
      <div class="wt-bar">
        <button id="wt_close" class="wt-pill">Close</button>
      </div>
    </div>

    <div class="wt-body">
      <div class="wt-bar" style="margin-bottom:8px">
        <strong>Tool</strong>
        <button class="wt-pill" id="t_pencil" aria-pressed="true">Pencil</button>
        <button class="wt-pill" id="t_line">Line</button>
        <button class="wt-pill" id="t_erase">Erase</button>
        <button class="wt-pill" id="t_smooth">Smooth</button>
        <button class="wt-pill" id="t_invert">Invert</button>
        <button class="wt-pill" id="t_zero">Zero DC</button>
        <button class="wt-pill" id="t_norm">Normalize</button>
        <button class="wt-pill" id="t_loop">Make Seamless</button>
        <button class="wt-pill" id="t_clear">Clear</button>
      </div>

      <div class="wt-bar" style="margin-bottom:10px">
        <label>Brush</label>
        <input id="brush" type="range" min="1" max="64" value="8">
        <label>Grid</label>
        <select id="grid">
          <option value="0">Off</option>
          <option>4</option><option>8</option><option>16</option><option selected>32</option><option>64</option>
        </select>
        <label><input type="checkbox" id="snap" checked> Snap</label>
        <label><input type="checkbox" id="sym"> Symmetry</label>
      </div>

      <canvas id="wt_canvas" class="wt-main" width="1024" height="512"></canvas>

      <div class="wt-bar" style="margin-top:8px">
        <span class="wt-radio">
          <label><input type="radio" name="aud" value="periodic" checked> Periodic</label>
          <label><input type="radio" name="aud" value="freerun"> Free‚Äërun</label>
        </span>
        <button class="wt-pill" id="audition">Audition</button>
        <label>Freq</label>
        <input id="aud_freq" type="range" min="30" max="1200" step="1" value="220">
        <span class="wt-tag" id="pitch_ref">Free‚Äërun reference: 220 Hz</span>
        <button class="wt-pill" id="export">Export to Oscs</button>
        <input class="wt-input" id="export_name" placeholder="Name for export‚Ä¶" style="min-width:220px">
      </div>
      <div class="wt-tiny">Free‚Äërun (WAV/CSV) follows the frequency slider via playbackRate; Periodic uses true oscillator frequency for single‚Äëcycle audition.</div>

      <div class="wt-grid2" style="margin-top:14px">
        <div>
          <label class="wt-tiny">Import CSV / WAV</label>
          <input class="wt-input" type="file" id="imp_file" accept=".csv,.wav">
          <div class="wt-bar" style="margin-top:8px">
            <button class="wt-pill" id="add_frame">Add as Frame</button>
            <button class="wt-pill" id="replace_frame">Replace Frame</button>
            <button class="wt-pill" id="del_frame">Delete Frame</button>
          </div>
          <div class="wt-bar" style="margin-top:8px">
            <label>Frame</label>
            <input id="frame_idx" type="range" min="0" max="31" step="1" value="0">
            <span id="frame_label" class="wt-tag">0 / 32</span>
          </div>
        </div>
        <div>
          <label class="wt-tiny">Import Preview</label>
          <canvas id="wt_import_preview_c" width="512" height="128" style="width:100%;height:128px;border-radius:8px;background:#0b0f14;border:1px solid var(--wt-line)"></canvas>
          <div class="wt-bar" style="margin-top:8px">
            <button class="wt-pill" id="use_preview">Use as Current</button>
          </div>
        </div>
      </div>

      <div style="margin-top:12px">
        <div class="wt-tiny">Frames <span class="wt-tag">max 32</span></div>
        <div id="thumbs" class="wt-thumbs"></div>
      </div>

    </div>
  </div>
</div>
<button id="wt_fab" class="wt-fab" title="Open Custom/Wavetable">WT</button>

<!-- WT Overlay: script -->
<script>
(function(){
'use strict';
/* ===== Collapsible behavior (safe global API) ===== */
const overlay = document.getElementById('wt_overlay');
const mask = document.getElementById('wt_mask');
const closeBtn = document.getElementById('wt_close');
const fab = document.getElementById('wt_fab');
function openPanel(){ overlay.setAttribute('aria-hidden','false'); }
function closePanel(){ overlay.setAttribute('aria-hidden','true'); }
closeBtn.addEventListener('click', closePanel);
mask.addEventListener('click', closePanel);
document.addEventListener('keydown',e=>{ if(e.key==='Escape' && overlay.getAttribute('aria-hidden')==='false'){ closePanel(); }});
fab.addEventListener('click', openPanel);

// Try to bind to an existing "Custom/Wavetable" button in your UI:
function autoBindOpener(){
  const candidates = Array.from(document.querySelectorAll('button,[role="button"],.btn,.menu-item,a'))
    .filter(el=>{
      const t = (el.textContent||'').toLowerCase();
      return t.includes('custom') && t.includes('wavetable');
    });
  candidates.forEach(el=>{
    if(!el.dataset.wtBound){
      el.dataset.wtBound = "1";
      el.addEventListener('click', ()=> openPanel());
    }
  });
}
autoBindOpener();
setTimeout(autoBindOpener, 1000); // in case your UI renders async

// Expose public API
window.__WT_openPanel = openPanel;

/* ===== Wavetable core (no PNG) ===== */
const N = 2048, MAX_FRAMES = 32;
let frames=[new Float32Array(N).fill(0)], current=0;

// Free‚Äërun buffers
let AUD_FULL=null, AUD_SR=null, AUD_ABUF=null;

const clamp1=(x)=>Math.max(-1,Math.min(1,x));
const lerp=(a,b,t)=>a+(b-a)*t;
function normalize(buf){ let m=0; for(let i=0;i<buf.length;i++){ const v=Math.abs(buf[i]); if(v>m) m=v; } if(m>0){ const k=1/m; for(let i=0;i<buf.length;i++) buf[i]*=k; } return buf; }
function dcRemove(buf){ let mu=0; for(let i=0;i<buf.length;i++) mu+=buf[i]; mu/=buf.length; for(let i=0;i<buf.length;i++) buf[i]-=mu; return buf; }
function resample1D(a, newLen){ const out=new Float32Array(newLen); if(a.length===newLen){ out.set(a); return out; } for(let i=0;i<newLen;i++){ const t=i*(a.length-1)/(newLen-1); const i0=Math.floor(t), i1=Math.min(a.length-1,i0+1); const f=t-i0; out[i]=(1-f)*a[i0]+f*a[i1]; } return out; }

function drawWaveToCanvas(ctx, buf, color='#bfeaff', bgGrid=true){
  const W=ctx.canvas.width, H=ctx.canvas.height;
  ctx.clearRect(0,0,W,H); ctx.fillStyle='#0b0f14'; ctx.fillRect(0,0,W,H);
  if(bgGrid){
    ctx.strokeStyle='#15202a'; ctx.lineWidth=1; ctx.beginPath();
    ctx.moveTo(0,H*0.5); ctx.lineTo(W,H*0.5);
    const gridDiv=parseInt(document.getElementById('grid').value||'0',10);
    if(gridDiv>0){ for(let i=1;i<gridDiv;i++){ const x=(i/gridDiv)*W; ctx.moveTo(x,0); ctx.lineTo(x,H); } }
    ctx.stroke();
  }
  ctx.strokeStyle=color; ctx.lineWidth=2; ctx.beginPath();
  for(let i=0;i<buf.length;i++){ const x=(i/(buf.length-1))*W; const y=(0.5-0.5*buf[i])*H; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
  ctx.stroke();
}
function makeThumb(buf){ const c=document.createElement('canvas'); c.width=256; c.height=128; c.className='wt-thumb'; drawWaveToCanvas(c.getContext('2d'), resample1D(buf,512), '#8fd0ff', true); return c; }
function refreshThumbs(){ const cont=document.getElementById('thumbs'); cont.innerHTML=''; frames.forEach((fr,idx)=>{ const t=makeThumb(fr); t.dataset.index=String(idx); t.dataset.active=(idx===current)?'true':'false'; t.addEventListener('click',()=>{ safeCommit(); current=idx; ensureFrame(current); editorBuf.set(frames[current]); paintEditor(); refreshThumbs(); updateFrameLabel(); }); cont.appendChild(t); }); }
function updateFrameLabel(){ document.getElementById('frame_label').textContent=`${current} / ${MAX_FRAMES}`; }

/* ===== Editor ===== */
const cvs=document.getElementById('wt_canvas'), ctx=cvs.getContext('2d');
const editorBuf=new Float32Array(N); editorBuf.set(frames[current]);
let dragging=false, tool='pencil', lastPos=null, lineStart=null;

function canvasToIndexAndValue(ev){ const rect=cvs.getBoundingClientRect(); const px=(ev.clientX-rect.left)*(cvs.width/rect.width); const py=(ev.clientY-rect.top)*(cvs.height/rect.height); const ix=Math.max(0,Math.min(N-1,Math.round(px/cvs.width*(N-1)))); const v=clamp1((0.5-py/cvs.height)*2); return {ix,v}; }
function applyPencil(ix,v){ const brush=Math.max(1,Math.floor(parseInt(document.getElementById('brush').value,10))); const sym=document.getElementById('sym').checked; const half=Math.floor(brush/2); for(let o=-half;o<=half;o++){ const j=Math.max(0,Math.min(N-1,ix+o)); editorBuf[j]=v; if(sym){ const jm=(N-1)-j; editorBuf[jm]=-v; } } }
function applyErase(ix){ const brush=Math.max(1,Math.floor(parseInt(document.getElementById('brush').value,10))); const sym=document.getElementById('sym').checked; const half=Math.floor(brush/2); for(let o=-half;o<=half;o++){ const j=Math.max(0,Math.min(N-1,ix+o)); editorBuf[j]=0; if(sym){ const jm=(N-1)-j; editorBuf[jm]=0; } } }
function applyLine(ix0,v0,ix1,v1){ const snap=document.getElementById('snap').checked, grid=parseInt(document.getElementById('grid').value||'0',10); if(snap&&grid>0){ const step=Math.round((N-1)/grid); ix0=Math.round(ix0/step)*step; ix1=Math.round(ix1/step)*step; } if(ix1<ix0){ let t=ix0; ix0=ix1; ix1=t; t=v0; v0=v1; v1=t; } const len=Math.max(1,ix1-ix0); for(let k=0;k<=len;k++){ const ix=ix0+k, t=k/len, v=lerp(v0,v1,t); editorBuf[ix]=v; } }
function paintEditor(){ drawWaveToCanvas(ctx, editorBuf, '#bfeaff', true); }

cvs.addEventListener('pointerdown',e=>{ dragging=true; lastPos=canvasToIndexAndValue(e); if(tool==='line'){ lineStart=lastPos; } else if(tool==='pencil'){ applyPencil(lastPos.ix,lastPos.v); paintEditor(); } else if(tool==='erase'){ applyErase(lastPos.ix); paintEditor(); } if(cvs.setPointerCapture&&e.pointerId!==undefined){ try{ cvs.setPointerCapture(e.pointerId);}catch(_){}}});
cvs.addEventListener('pointermove',e=>{ if(!dragging) return; const cur=canvasToIndexAndValue(e); if(tool==='pencil'){ const ix0=Math.min(lastPos.ix,cur.ix), ix1=Math.max(lastPos.ix,cur.ix), len=Math.max(1,ix1-ix0); for(let k=0;k<=len;k++){ const ix=ix0+k, t=(len? k/len:0), v=lerp(lastPos.v,cur.v,t); applyPencil(ix,v); } lastPos=cur; paintEditor(); } else if(tool==='erase'){ const ix0=Math.min(lastPos.ix,cur.ix), ix1=Math.max(lastPos.ix,cur.ix); for(let ix=ix0; ix<=ix1; ix++) applyErase(ix); lastPos=cur; paintEditor(); } else if(tool==='line'){ paintEditor(); const tctx=ctx; tctx.save(); tctx.globalAlpha=0.65; tctx.strokeStyle='#89bde6'; tctx.lineWidth=2; tctx.beginPath(); const x0=(lineStart.ix/(N-1))*cvs.width, y0=(0.5-0.5*lineStart.v)*cvs.height; const x1=(cur.ix/(N-1))*cvs.width, y1=(0.5-0.5*cur.v)*cvs.height; tctx.moveTo(x0,y0); tctx.lineTo(x1,y1); tctx.stroke(); tctx.restore(); } });
['pointerup','pointercancel','pointerleave'].forEach(ev=>cvs.addEventListener(ev, e=>{ if(!dragging) return; if(tool==='line' && lineStart){ const cur=canvasToIndexAndValue(e); applyLine(lineStart.ix,lineStart.v,cur.ix,cur.v); paintEditor(); } dragging=false; lastPos=null; lineStart=null; }));

const t_pencil=document.getElementById('t_pencil'), t_line=document.getElementById('t_line'), t_erase=document.getElementById('t_erase');
const t_smooth=document.getElementById('t_smooth'), t_invert=document.getElementById('t_invert'), t_zero=document.getElementById('t_zero');
const t_norm=document.getElementById('t_norm'), t_loop=document.getElementById('t_loop'), t_clear=document.getElementById('t_clear');
function setTool(id){ tool=id; [t_pencil,t_line,t_erase,t_smooth,t_invert,t_zero,t_norm,t_loop,t_clear].forEach(el=>{ if(el) el.setAttribute('aria-pressed', String(el.id==='t_'+id)); }); }
t_pencil.addEventListener('click',()=>setTool('pencil')); t_line.addEventListener('click',()=>setTool('line')); t_erase.addEventListener('click',()=>setTool('erase'));
t_smooth.addEventListener('click',()=>{ const tmp=new Float32Array(editorBuf); for(let p=0;p<2;p++){ for(let i=1;i<N-1;i++){ tmp[i]=(editorBuf[i-1]+editorBuf[i]+editorBuf[i+1])/3; } tmp[0]=(editorBuf[0]+editorBuf[1])*0.5; tmp[N-1]=(editorBuf[N-2]+editorBuf[N-1])*0.5; editorBuf.set(tmp); } paintEditor(); });
t_invert.addEventListener('click',()=>{ for(let i=0;i<N;i++) editorBuf[i]=-editorBuf[i]; paintEditor(); });
t_zero.addEventListener('click',()=>{ dcRemove(editorBuf); paintEditor(); });
t_norm.addEventListener('click',()=>{ normalize(editorBuf); paintEditor(); });
t_loop.addEventListener('click',()=>{ const xfade=48; for(let i=0;i<xfade;i++){ const a=editorBuf[N-xfade+i], b=editorBuf[i]; const t=i/(xfade-1); const wa=Math.cos(0.5*Math.PI*t), wb=Math.sin(0.5*Math.PI*t); const v=wa*a+wb*b; editorBuf[i]=v; editorBuf[N-xfade+i]=v; } dcRemove(editorBuf); paintEditor(); });
t_clear.addEventListener('click',()=>{ editorBuf.fill(0); paintEditor(); });
document.getElementById('grid').addEventListener('change',()=>paintEditor());

/* ===== Frame ops ===== */
const addB=document.getElementById('add_frame'), repB=document.getElementById('replace_frame'), delB=document.getElementById('del_frame'), frameIdx=document.getElementById('frame_idx');
function ensureFrame(i){ if(i<0||i>=MAX_FRAMES) return; if(!frames[i]) frames[i]=new Float32Array(N); }
function safeCommit(){ if(current<0||current>=MAX_FRAMES) return; ensureFrame(current); frames[current].set(editorBuf); }
addB.addEventListener('click',()=>{ if(frames.length>=MAX_FRAMES){ flashStatus('Frame limit reached','warn'); return; } safeCommit(); const copy=new Float32Array(editorBuf); frames.splice(current+1,0,copy); current++; editorBuf.set(copy); frameIdx.value=String(current); refreshThumbs(); updateFrameLabel(); paintEditor(); });
repB.addEventListener('click',()=>{ safeCommit(); refreshThumbs(); paintEditor(); flashStatus('Frame replaced','ok'); });
delB.addEventListener('click',()=>{ if(frames.length<=1){ frames[0].fill(0); editorBuf.fill(0); paintEditor(); refreshThumbs(); return; } frames.splice(current,1); current=Math.max(0, Math.min(current, frames.length-1)); ensureFrame(current); editorBuf.set(frames[current]); frameIdx.value=String(current); refreshThumbs(); updateFrameLabel(); paintEditor(); });
frameIdx.addEventListener('input',()=>{ const idx=Math.max(0, Math.min(MAX_FRAMES-1, parseInt(frameIdx.value,10)||0)); safeCommit(); current=idx; ensureFrame(current); editorBuf.set(frames[current]); updateFrameLabel(); refreshThumbs(); paintEditor(); });

/* ===== Import (CSV/WAV only) ===== */
const st=document.getElementById('wt_import_status');
function flashStatus(msg, cls=''){ st.className='wt-status '+cls; st.textContent=msg; clearTimeout(flashStatus._t); flashStatus._t=setTimeout(()=>{ st.className='wt-status'; st.textContent='Ready'; }, 2500); }

const impF=document.getElementById('imp_file'), usePrev=document.getElementById('use_preview');
const prevC=document.getElementById('wt_import_preview_c'), prevCtx=prevC.getContext('2d');
let IMPORT_PREVIEW=null;
function __wt_setImportPreview(buf){ if(buf){ drawWaveToCanvas(prevCtx, resample1D(buf,1024), '#7fe0a6', true); flashStatus('Preview ready','ok'); } else { prevCtx.clearRect(0,0,prevC.width, prevC.height); } }
usePrev.addEventListener('click',()=>{ editorBuf.set(IMPORT_PREVIEW || editorBuf); paintEditor(); });

impF.addEventListener('change', async ()=>{
  const f=impF.files && impF.files[0]; if(!f) return;
  const name=(f.name||'').toLowerCase(); AUD_FULL=null; AUD_SR=null; AUD_ABUF=null;
  try{
    if(name.endsWith('.csv')){
      const txt=await f.text();
      let srGuess=44100, ys=[], lines=txt.trim().split(/\r?\n/);
      if(lines[0].includes('t') && lines[0].includes(',')){
        let times=[], vals=[]; for(let i=1;i<lines.length;i++){ const p=lines[i].split(','); if(p.length>=2){ const t=parseFloat(p[0]), v=parseFloat(p[1]); if(Number.isFinite(t)&&Number.isFinite(v)){ times.push(t); vals.push(v); } } }
        if(times.length>2){ const dts=[]; for(let i=1;i<times.length;i++) dts.push(times[i]-times[i-1]); dts.sort((a,b)=>a-b); const med=dts[Math.floor(dts.length/2)]; if(med>0) srGuess=Math.round(1/med); }
        ys=vals;
      }else{ ys = txt.split(/[, \t\r\n]+/).map(Number).filter(Number.isFinite); }
      AUD_FULL=new Float32Array(ys); AUD_SR=srGuess;
      IMPORT_PREVIEW=resample1D(AUD_FULL,N); dcRemove(IMPORT_PREVIEW); normalize(IMPORT_PREVIEW); __wt_setImportPreview(IMPORT_PREVIEW);
      document.querySelector('input[name="aud"][value="freerun"]').checked=true;
      flashStatus(`CSV imported, sr‚âà${srGuess} Hz; Free‚Äërun selected`,'ok');
    }else if(name.endsWith('.wav')){
      const ac=new (window.AudioContext||window.webkitAudioContext)();
      const arr=new Uint8Array(await f.arrayBuffer());
      const ab=await ac.decodeAudioData(arr.buffer.slice(arr.byteOffset, arr.byteOffset+arr.byteLength));
      AUD_ABUF=ab; AUD_SR=ab.sampleRate; AUD_FULL=new Float32Array(ab.getChannelData(0));
      IMPORT_PREVIEW=resample1D(AUD_FULL,N); dcRemove(IMPORT_PREVIEW); normalize(IMPORT_PREVIEW); __wt_setImportPreview(IMPORT_PREVIEW);
      document.querySelector('input[name="aud"][value="freerun"]').checked=true;
      flashStatus(`WAV imported, ${AUD_SR} Hz; Free‚Äërun selected`,'ok');
    }else{
      flashStatus('Unsupported file type','err');
    }
  }catch(e){ console.warn('Import error',e); flashStatus('Import failed: '+(e && e.message || e),'err'); }
  finally{ impF.value=''; }
});

/* ===== Audition (pitch-follow Free‚Äërun; FFT Periodic) ===== */
const auditionB=document.getElementById('audition'), audFreq=document.getElementById('aud_freq');
const pitchRefEl=document.getElementById('pitch_ref');
let __audCtx=null, __audSrc=null, __audGain=null, __audMode=null, __audRefHz=220;
async function ensureCtx(){ if(!__audCtx){ __audCtx=new (window.AudioContext||window.webkitAudioContext)(); } if(__audCtx.state==='suspended'){ try{ await __audCtx.resume(); }catch(e){} } return __audCtx; }
function stopAudition(){ try{ if(__audSrc){ __audSrc.stop(); __audSrc.disconnect(); } if(__audGain){ __audGain.disconnect(); } }catch(e){} __audSrc=null; __audGain=null; __audMode=null; }
function WT_fftToPeriodicWave(ac, wave, f0){ const nyq=ac.sampleRate*0.5, kmax=Math.max(1,Math.min(Math.floor(nyq/Math.max(1e-3,f0)), Math.floor(N/2)-1)); const real=new Float32Array(kmax+1), imag=new Float32Array(kmax+1); for(let k=1;k<=kmax;k++){ let a=0,b=0; for(let n=0;n<N;n++){ const phi=2*Math.PI*k*n/N, x=wave[n]; a+=x*Math.cos(phi); b-=x*Math.sin(phi); } real[k]=(2/N)*a; imag[k]=(2/N)*b; } return ac.createPeriodicWave(real,imag,{disableNormalization:true}); }
function computeRMS(y){ let s=0; for(let i=0;i<y.length;i++) s+=y[i]*y[i]; return Math.sqrt(s/Math.max(1,y.length)); }

auditionB.addEventListener('click', async ()=>{
  stopAudition();
  try{
    const ac = await ensureCtx();
    const mode = document.querySelector('input[name="aud"]:checked').value;
    const f0 = parseFloat(audFreq.value)||220;

    if(mode==='freerun' && (AUD_ABUF || (AUD_FULL && AUD_FULL.length>0))){
      const src=ac.createBufferSource();
      if(AUD_ABUF){ src.buffer=AUD_ABUF; } else { const ab=ac.createBuffer(1, AUD_FULL.length, Math.max(8000,Math.min(192000, AUD_SR||44100))); ab.copyToChannel(AUD_FULL,0); src.buffer=ab; }
      const g=ac.createGain();
      const L=Math.min(src.buffer.length, Math.floor(src.buffer.sampleRate*1.0)); const tmp=new Float32Array(L); src.buffer.copyFromChannel(tmp,0,0); const rms=computeRMS(tmp); const target=0.22; g.gain.setValueAtTime(Math.min(4,Math.max(0.05,target/Math.max(1e-6,rms))), ac.currentTime);
      __audRefHz = 220; src.playbackRate.value = f0 / __audRefHz; pitchRefEl.textContent = `Free‚Äërun reference: ${__audRefHz} Hz`;
      src.connect(g).connect(ac.destination); __audSrc=src; __audGain=g; __audMode='freerun';
      src.start(ac.currentTime+0.01);
      const dur=Math.min(2.5, src.buffer.duration / Math.max(1e-6, src.playbackRate.value)); setTimeout(()=>{ stopAudition(); }, dur*1000+60);
    }else{
      const cyc=new Float32Array(editorBuf);
      const xfade=48; for(let i=0;i<xfade;i++){ const a=cyc[N-xfade+i], b=cyc[i]; const t=i/(xfade-1); const wa=Math.cos(0.5*Math.PI*t), wb=Math.sin(0.5*Math.PI*t); const v=wa*a+wb*b; cyc[i]=v; cyc[N-xfade+i]=v; }
      const o=ac.createOscillator(); o.setPeriodicWave(WT_fftToPeriodicWave(ac,cyc,f0)); o.frequency.value=f0;
      const g=ac.createGain(); g.gain.value=0.18; o.connect(g).connect(ac.destination);
      __audSrc=o; __audGain=g; __audMode='periodic';
      o.start(); setTimeout(()=>{ stopAudition(); }, 1200);
    }
  }catch(e){ console.warn(e); }
});
audFreq.addEventListener('input', ()=>{
  const f0 = parseFloat(audFreq.value)||220;
  if(!__audCtx || !__audSrc) return;
  try{
    if(__audMode==='freerun' && __audSrc.playbackRate){
      __audSrc.playbackRate.setValueAtTime(f0/(__audRefHz||220), __audCtx.currentTime);
    }else if(__audMode==='periodic' && __audSrc.frequency){
      __audSrc.frequency.setValueAtTime(f0, __audCtx.currentTime);
    }
  }catch(e){}
});

/* ===== Export ===== */
document.getElementById('export').addEventListener('click', ()=>{
  safeCommit();
  const name=(document.getElementById('export_name').value||'Custom WT').trim();
  const outFrames=[];
  for(let i=0;i<Math.min(frames.length,MAX_FRAMES); i++){ if(!frames[i]) continue; outFrames.push(new Float32Array(frames[i])); }
  window.dispatchEvent(new CustomEvent('wt:export',{detail:{name,frames:outFrames}}));
  flashStatus('Exported "'+name+'" (event wt:export)','ok');
  console.log('[WT] Exported:', name, outFrames);
});

/* ===== Public API ===== */
window.__WT_getFrames = ()=> frames.map(f=> new Float32Array(f));
window.__WT_setFrames = (arr)=>{
  if(!Array.isArray(arr)||!arr.length) return;
  frames = arr.slice(0,MAX_FRAMES).map(x=>{ const f=new Float32Array(N); if(x&&x.length){ f.set(resample1D(Float32Array.from(x),N)); } return dcRemove(normalize(f)); });
  current=0; editorBuf.set(frames[0]); frameIdx.value=String(current); refreshThumbs(); updateFrameLabel(); paintEditor();
};
window.__WT_exportToOscs = (name)=>{ document.getElementById('export_name').value=name||'Custom WT'; document.getElementById('export').click(); };

/* ===== Init ===== */
refreshThumbs(); updateFrameLabel(); paintEditor();

})(); // end IIFE
</script>

</body>



</html>