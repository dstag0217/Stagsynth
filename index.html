<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>StagSynth ‚Äî FINAL FX Fix</title>
<link rel="icon" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><circle cx="32" cy="32" r="30" fill="none" stroke="%23ff2727" stroke-width="6"/><text x="32" y="42" text-anchor="middle" font-size="32" fill="%23ff2727">ü¶â</text></svg>' />
<style>
/* ===== Theme ===== */
:root{
  --bg1:#2b0000; --bg2:#060004;
  --panel:#0e0a0a; --panel2:#1a1212;
  --border:#3a2323; --fg:#f7e9e9; --dim:#c99a9a;
  --accent:#ff2727; --green:#25ff85; --warn:#ff844a;
  --chevron1:#0b0b0b; --chevron2:#1c1c1c;
  --tb: 60px;
}
*{box-sizing:border-box}
html,body{margin:0;height:100%;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}

/* Mobile feel */
body, .app, .keypad-wrap, .keypad, .key {-webkit-user-select:none; user-select:none; -webkit-touch-callout:none}
.key { touch-action:none; }
* { -webkit-tap-highlight-color: transparent; }
input, select, textarea { -webkit-user-select:text; user-select:text }

/* ===== Topbar ===== */
.topbar{
  display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap;
  padding:10px 12px;position:sticky;top:0;z-index:50;background:
  radial-gradient(1200px 220px at 50% -60px, #5d0a0a55, transparent 70%),
  linear-gradient(180deg,rgba(43,0,0,.95),rgba(6,0,4,.65) 85%,transparent);
  border-bottom:1px solid rgba(255,255,255,.06)
}
h1{margin:0;font-weight:900;font-size:18px;letter-spacing:.08em}
.tb-row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.synth-btn{
  background:
    linear-gradient(180deg,rgba(255,255,255,.04),transparent),
    linear-gradient(180deg,var(--panel),var(--panel2));
  border:1px solid var(--border);color:var(--fg);
  padding:8px 12px;border-radius:999px;cursor:pointer;
  box-shadow:0 1px 0 rgba(255,255,255,.06) inset,0 8px 20px rgba(0,0,0,.25);
  transition:box-shadow .15s ease, transform .05s ease, opacity .15s ease;
  font-size:14px; line-height:1; min-height:34px;
}
.synth-btn:hover{box-shadow:0 1px 0 rgba(255,255,255,.06) inset,0 8px 20px rgba(0,0,0,.25),0 0 0 3px rgba(255,39,39,.12)}
.synth-btn:active{transform:translateY(1px)}
.synth-btn[disabled]{opacity:.45;cursor:not-allowed}
.pill{padding:6px 10px;border-radius:999px;border:1px solid var(--border);background:linear-gradient(180deg,var(--panel),var(--panel2));display:inline-flex;align-items:center}
.pill.dim{opacity:.6}
.badge{font-size:12px;opacity:.9;margin-left:8px}
.warn{color:var(--warn)}
@media (max-width: 430px){
  h1{font-size:14px}
  .tb-row{gap:6px}
  .synth-btn{padding:6px 9px;font-size:12px;min-height:30px}
  .pill{padding:5px 8px}
}
#recDot{display:inline-block;width:10px;height:10px;border-radius:50%;background:#ff2727;margin-right:6px;box-shadow:0 0 8px rgba(255,39,39,.6)}
@keyframes pulse{0%{transform:scale(1)}50%{transform:scale(1.2)}100%{transform:scale(1)}}
.pill.recording{background:linear-gradient(180deg,#3b0a0a,#1a0b0b);border-color:#6b1f1f;box-shadow:0 0 0 2px rgba(255,39,39,.18) inset,0 0 18px rgba(255,39,39,.22);opacity:1}
.pill.recording #recDot{animation:pulse 0.9s infinite}

/* App & keypad */
.app{max-width:1000px;margin:0 auto;padding:12px 12px 96px}
.keypad-wrap{border:1px solid var(--border);border-radius:14px;padding:10px;background:
  repeating-linear-gradient(135deg,var(--chevron1) 0 14px,var(--chevron2) 14px 28px),
  linear-gradient(180deg,var(--panel),#0a0507);max-height:72vh;overflow:auto;box-shadow:inset 0 0 0 1px rgba(255,255,255,.03)}
.keypad{display:grid;grid-template-columns:repeat(4,1fr);grid-auto-rows:minmax(56px,1fr);gap:8px;user-select:none}
.key{background:
  radial-gradient(100px 60px at 30% 30%,#311414,#140708),
  linear-gradient(180deg,#0f090a,#0c0507);
  border:1px solid var(--border);border-radius:12px;min-height:56px;display:flex;align-items:center;justify-content:center;box-shadow:inset 0 1px 0 rgba(255,255,255,.04)}
.key.on{outline:2px solid var(--accent);box-shadow:0 0 18px rgba(255,39,39,.35),inset 0 1px 0 rgba(255,255,255,.04)}
.controls{display:flex;gap:10px;align-items:center;justify-content:space-between;margin-bottom:10px;flex-wrap:wrap}
.readout{width:40px;height:40px;display:grid;place-items:center;border:1px solid var(--border);border-radius:10px;background:#0b0a0b;box-shadow:inset 0 1px 0 rgba(255,255,255,.04)}
.wheel{width:64px;height:64px;border-radius:999px;border:2px solid var(--border);background:radial-gradient(circle at 30% 30%, #3a1212, #0b0a0b);position:relative;box-shadow:inset 0 0 10px #0006;touch-action:none;cursor:grab}
.wheel .center{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:2px;height:84%;background:#3a2323;opacity:.85}
.wheel .marker{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:10px;height:22px;border-radius:4px;background:#ffe9e9;opacity:.95;box-shadow:0 0 10px rgba(255,255,255,.25)}
.owl{width:42px;height:42px;display:grid;place-items:center;border-color:#14532d}
.owl.micro-on{outline:2px solid var(--green);box-shadow:0 0 14px #25ff8570}

/* Panels */
.synth-panel{
  position:fixed; left:0; right:0;
  top:var(--tb); height:calc(100vh - var(--tb));
  transform:translateY(-120%); transition:transform .25s ease;
  background:#0a0507ea;color:var(--fg);z-index:45;padding:12px;backdrop-filter:blur(8px);
  overflow:auto; overscroll-behavior:contain;
  border-bottom:1px solid var(--border); border-top:1px solid rgba(255,255,255,.06);
}
.synth-panel.open{transform:translateY(0)}
.section{display:grid;grid-template-columns:170px 1fr;gap:8px 12px;padding:10px 0;border-top:1px solid var(--border)}
.section h4{grid-column:1 / -1;margin:.25rem 0;opacity:.95;letter-spacing:.04em}
@media (max-width:700px){.section{grid-template-columns:1fr}}
@media (max-width:430px){
  .synth-panel{padding:10px}
  .section{gap:6px 10px; padding:8px 0}
  .section h4{font-size:13px}
  .synth-panel label{font-size:12px}
  .synth-panel input[type="range"]{touch-action:pan-y}
  .synth-panel select, .synth-panel input[type="number"], .synth-panel input[type="text"]{font-size:12px}
}
.footer{position:fixed;bottom:0;left:0;right:0;padding:8px 12px;font-size:12px;opacity:.85;background:linear-gradient(0deg,#2b0000,transparent)}
.midi-learn-on{outline:2px solid var(--accent)}
.kv{display:flex;gap:6px;align-items:center}
.kv small{opacity:.8}
.synth-btn.ll-on{outline:2px solid var(--accent); box-shadow:0 0 10px var(--accent);} 
#llToggleOverlay{position:relative; z-index:12; pointer-events:auto}
</style>
</head>
<body>
<header class="topbar" id="topbar">
  <h1>StagSynth</h1>
  <div class="tb-row">
    <button id="startBtn" class="synth-btn" title="Start or Resume Audio">Start Audio</button>
    <button id="resetBtn" class="synth-btn" title="Reset Audio Engine (close & reinit)">Reset Audio</button>
    <button id="midiBtn" class="synth-btn" title="Connect MIDI (USB/BLE)">ùÑû MIDI</button>
    <button id="midiLearnBtn" class="synth-btn" title="MIDI CC Learn" disabled>MIDI Map</button>
    <button id="synthToggle" class="synth-btn" aria-expanded="false" aria-controls="synthPanel">Synth</button>
    <button id="granularToggle" class="synth-btn" aria-expanded="false" aria-controls="granularPanel">Granular</button>
    <button id="samplerToggle" class="synth-btn" aria-expanded="false" aria-controls="samplerPanel">Sampler</button>
    <button id="vocoderToggle" class="synth-btn" aria-expanded="false" aria-controls="vocoderPanel">Vocoder</button>
    <div style="display:flex;gap:6px;align-items:center">
      <button id="recBtn" class="pill dim" title="Record short take (whole output)">
        <span id="recDot"></span> <span id="recLabel">Record</span>
      </button>
      <span id="recTimer" class="badge" aria-live="polite"></span>
    </div>
  </div>
</header>

<!-- Synth panel -->
<div id="synthPanel" class="synth-panel" role="region" aria-label="Synth controls">
  <div class="section">
    <h4>Oscillators</h4>
    <label>Shape <select id="shape" data-midicc><option>sawtooth</option><option>square</option><option>triangle</option><option>sine</option><option>noise</option></select></label>
    <label>Sub Shape <select id="subShape" data-midicc><option>off</option><option>sine</option><option>square</option><option>triangle</option><option>saw</option><option>noise</option></select></label>
    <label>Detune (cents) <input type="range" id="detune" data-midicc min="-50" max="50" step="1" value="0"/></label>
    <label>Sub Detune (cents) <input type="range" id="subDetune" data-midicc min="-50" max="50" step="1" value="0"/></label>
    <label>Sub Level <input type="range" id="subLevel" data-midicc min="0" max="1" step="0.01" value="0.8"/></label>
    <label>Sub Octave <select id="subOctave" data-midicc><option value="1" selected>1x</option><option value="0.5">¬Ωx</option></select></label>
    <label>Noise Color <select id="noiseColor" data-midicc><option>white</option><option>pink</option></select></label>
  </div>

  <div class="section">
    <h4>Filter</h4>
    <label>Mode <select id="mode" data-midicc><option>lp</option><option>bp</option><option>hp</option></select></label>
    <label>Cutoff <input type="range" id="cutoff" data-midicc min="60" max="12000" step="1" value="1600"/></label>
    <label>Resonance <input type="range" id="resonance" data-midicc min="0" max="1" step="0.01" value="0.2"/></label>
  </div>

  <!-- ===== FULL FX SUITE (all neutral on load) ===== -->
  <div class="section" id="fxSuite">
    <h4>FX Suite</h4>

    <!-- Reverb (neutral = MIX 0) -->
    <label>Reverb Room Size <input type="range" id="fx_rev_room" data-midicc min="0.1" max="1.0" step="0.01" value="0.6"/></label>
    <label>Reverb Decay (s) <input type="range" id="fx_rev_decay" data-midicc min="0.2" max="12" step="0.1" value="3.0"/></label>
    <label>Reverb Pre-delay (ms) <input type="range" id="fx_rev_predelay" data-midicc min="0" max="200" step="1" value="20"/></label>
    <label>Reverb Damping (Hz) <input type="range" id="fx_rev_damp" data-midicc min="1000" max="20000" step="10" value="6000"/></label>
    <label>Reverb Mix <input type="range" id="fx_rev_mix" data-midicc min="0" max="1" step="0.01" value="0.0"/></label>

    <!-- Chorus (neutral = MIX 0) -->
    <label>Chorus Rate (Hz) <input type="range" id="fx_ch_rate" data-midicc min="0.05" max="8" step="0.01" value="1.0"/></label>
    <label>Chorus Depth (ms) <input type="range" id="fx_ch_depth" data-midicc min="0" max="20" step="0.1" value="6"/></label>
    <label>Chorus Voices <input type="number" id="fx_ch_voices" min="1" max="4" step="1" value="2"/></label>
    <label>Stereo Width <input type="range" id="fx_ch_width" data-midicc min="0" max="1" step="0.01" value="0.8"/></label>
    <label>Chorus Mix <input type="range" id="fx_ch_mix" data-midicc min="0" max="1" step="0.01" value="0.0"/></label>

    <!-- Distortion (neutral = MIX 0, Drive 0, Tone 20kHz) -->
    <label>Dist Type
      <select id="fx_dist_type" data-midicc>
        <option value="soft" selected>Soft</option>
        <option value="tanh">Tanh</option>
        <option value="hard">Hard Clip</option>
      </select>
    </label>
    <label>Dist Drive <input type="range" id="fx_dist_drive" data-midicc min="0" max="1" step="0.01" value="0.0"/></label>
    <label>Dist Tone (Hz) <input type="range" id="fx_dist_tone" data-midicc min="1000" max="20000" step="10" value="20000"/></label>
    <label>Dist Mix <input type="range" id="fx_dist_mix" data-midicc min="0" max="1" step="0.01" value="0.0"/></label>

    <!-- Compressor (neutral = ratio 1, makeup 0, threshold 0) -->
    <label>Comp Threshold (dB) <input type="range" id="fx_comp_thr" data-midicc min="-60" max="0" step="1" value="0"/></label>
    <label>Comp Ratio <input type="range" id="fx_comp_ratio" data-midicc min="1" max="20" step="0.1" value="1"/></label>
    <label>Comp Attack (ms) <input type="range" id="fx_comp_att" data-midicc min="0.1" max="200" step="0.1" value="5"/></label>
    <label>Comp Release (ms) <input type="range" id="fx_comp_rel" data-midicc min="10" max="1000" step="1" value="200"/></label>
    <label>Makeup Gain <input type="range" id="fx_comp_makeup" data-midicc min="0" max="12" step="0.1" value="0"/></label>

    <!-- Bitcrusher (neutral = MIX 0) -->
    <label>Bit Depth <input type="range" id="fx_bc_bits" data-midicc min="1" max="24" step="1" value="24"/></label>
    <label>Downsample (Hz) <input type="range" id="fx_bc_rate" data-midicc min="100" max="48000" step="50" value="48000"/></label>
    <label>Bitcrusher Mix <input type="range" id="fx_bc_mix" data-midicc min="0" max="1" step="0.01" value="0.0"/></label>

    <!-- Ring Mod (neutral = MIX 0 and Depth 0) -->
    <label>Ring Carrier Freq (Hz) <input type="range" id="fx_rm_freq" data-midicc min="0.1" max="20000" step="0.1" value="30"/></label>
    <label>Ring Carrier Wave
      <select id="fx_rm_wave" data-midicc>
        <option>sine</option><option>triangle</option><option>square</option><option>sawtooth</option>
      </select>
    </label>
    <label>Ring Depth <input type="range" id="fx_rm_depth" data-midicc min="0" max="1.5" step="0.01" value="0.0"/></label>
    <label>Ring Mix <input type="range" id="fx_rm_mix" data-midicc min="0" max="1" step="0.01" value="0.0"/></label>

    <!-- Original color bus -->
    <label>Drive (Color) <input type="range" id="drive" data-midicc min="0" max="1" step="0.01" value="0.0"/></label>
    <label>Color Mix <input type="range" id="mix" data-midicc min="0" max="1" step="0.01" value="0.0"/></label>
  </div>

  <div class="section">
    <h4>Presets</h4>
    <label>Preset <select id="presetSelect"></select></label>
    <label>Name <input id="presetName" type="text" placeholder="New preset name"/></label>
    <div style="grid-column:1 / -1; display:flex; gap:8px; flex-wrap:wrap; margin-top:6px">
      <button id="savePresetBtn" class="synth-btn">Save</button>
      <button id="loadPresetBtn" class="synth-btn">Load</button>
      <button id="deletePresetBtn" class="synth-btn">Delete</button>
      <button id="exportPresetsBtn" class="synth-btn">Export</button>
      <button id="importPresetsBtn" class="synth-btn">Import</button>
      <input id="importPresetsFile" type="file" accept=".json,application/json" style="display:none"/>
      <button id="shareLinkBtn" class="synth-btn">Copy Share Link</button>
      <span id="presetMsg" class="badge"></span>
    </div>
  </div>
</div>
<!-- Granular panel -->
<div id="granularPanel" class="synth-panel" role="region" aria-label="Granular controls">
  <div class="section">
    <h4>Recordings</h4>
    <div style="grid-column:1/-1;display:flex;gap:8px;flex-wrap:wrap;align-items:center">
      <button id="g_startRec" class="synth-btn">Start Rec</button>
      <button id="g_stopRec" class="synth-btn" disabled>Stop Rec</button>
      <button id="g_saveTake" class="synth-btn" disabled>Save Take</button>
      <button id="g_importFile" class="synth-btn">Import File</button>
      <input id="g_file" type="file" accept="audio/*" style="display:none">
      <button id="g_exportTake" class="synth-btn" disabled>Export Take</button>
    </div>
    <label>Take <select id="g_takeList"></select></label>
    <div style="grid-column:1/-1;display:flex;gap:8px;flex-wrap:wrap">
      <button id="g_deleteTake" class="synth-btn" disabled>Delete</button>
      <span id="g_status" class="badge"></span>
    </div>
  </div>
  <div class="section">
    <h4>Grains</h4>
    <label>Position (%) <input type="range" id="g_pos" data-midicc min="0" max="100" step="0.1" value="0"/></label>
    <label>Scan Rate (pct/s) <input type="range" id="g_scan" data-midicc min="-100" max="100" step="1" value="10"/></label>
    <label>Grain Size (ms) <input type="range" id="g_size" data-midicc min="10" max="500" step="1" value="120"/></label>
    <label>Overlap (ms) <input type="range" id="g_overlap" data-midicc min="0" max="300" step="1" value="60"/></label>
    <label>Density (gr/s) <input type="range" id="g_density" data-midicc min="1" max="80" step="1" value="30"/></label>
    <label>Spray (ms) <input type="range" id="g_spray" data-midicc min="0" max="120" step="1" value="15"/></label>
    <label>Playback Rate <input type="range" id="g_rate" data-midicc min="0.25" max="2" step="0.01" value="1"/></label>
    <label>Gain <input type="range" id="g_gain" data-midicc min="0" max="1.2" step="0.01" value="0.7"/></label>
    <div style="grid-column:1/-1;display:flex;gap:8px;flex-wrap:wrap">
      <label class="pill kv"><input type="checkbox" id="g_loop" data-midicc checked> <small>Loop</small></label>
      <label class="pill kv"><input type="checkbox" id="g_freeze" data-midicc> <small>Freeze Scan</small></label>
      <button id="g_play" class="synth-btn">Play Granular</button>
      <button id="g_stop" class="synth-btn">Stop Granular</button>
    </div>
  </div>
</div>

<!-- Sampler panel -->
<div id="samplerPanel" class="synth-panel" role="region" aria-label="Sampler controls">
  <div class="section"><h4>Library</h4>
    <div style="grid-column:1/-1;display:flex;gap:8px;flex-wrap:wrap;align-items:center">
      <button id="sam_fromGranular" class="synth-btn">Load From Granular</button>
      <button id="sam_import" class="synth-btn">Import File</button>
      <input id="sam_file" type="file" accept="audio/*" style="display:none">
      <button id="sam_export" class="synth-btn" disabled>Export WAV</button>
    </div>
    <label>Sample <select id="sam_list"></select></label>
    <label>Name <input id="sam_name" type="text" placeholder="Sample name"/></label>
    <div style="grid-column:1/-1;display:flex;gap:8px;flex-wrap:wrap">
      <button id="sam_save" class="synth-btn" disabled>Save/Overwrite</button>
      <button id="sam_delete" class="synth-btn" disabled>Delete</button>
      <span id="sam_status" class="badge"></span>
    </div>
  </div>
  <div class="section"><h4>Mapping</h4>
    <label>Instrument Mode 
      <select id="sam_mode" data-midicc>
        <option value="off">Off (use Synth)</option>
        <option value="sampler">Sampler Only</option>
        <option value="both">Both (layer)</option>
      </select>
    </label>
    <label>Root Note (MIDI) <input type="number" id="sam_root" min="0" max="127" step="1" value="60"/></label>
    <label>Tune (cents) <input type="range" id="sam_tune" data-midicc min="-100" max="100" step="1" value="0"/></label>
    <label>Start (%) <input type="range" id="sam_start" data-midicc min="0" max="99" step="0.1" value="0"/></label>
    <label>End (%) <input type="range" id="sam_end" data-midicc min="1" max="100" step="0.1" value="100"/></label>
    <label><input type="checkbox" id="sam_loop" data-midicc/> Loop</label>
  </div>
  <div class="section"><h4>Envelope & Filter</h4>
    <label>A <input type="range" id="sam_a" data-midicc min="0" max="1" step="0.001" value="0.005"/></label>
    <label>D <input type="range" id="sam_d" data-midicc min="0" max="1" step="0.001" value="0.08"/></label>
    <label>S <input type="range" id="sam_s" data-midicc min="0" max="1" step="0.01" value="0.8"/></label>
    <label>R <input type="range" id="sam_r" data-midicc min="0" max="2" step="0.01" value="0.2"/></label>
    <label>Gain <input type="range" id="sam_gain" data-midicc min="0" max="1.5" step="0.01" value="0.9"/></label>
    <label>Cutoff <input type="range" id="sam_cut" data-midicc min="60" max="10000" step="1" value="10000"/></label>
    <label>Resonance <input type="range" id="sam_q" data-midicc min="0" max="1" step="0.01" value="0.0"/></label>
  </div>
</div>


<!-- Vocoder panel (added) -->
<div id="vocoderPanel" class="synth-panel" role="region" aria-label="Vocoder controls">
  <div class="section">
    <h4>Signal</h4>
    <label>Carrier
      <select id="voc_carrier" data-midicc>
        <option value="off" selected>Off</option>
        <option value="synth">Synth</option>
        <option value="sampler">Sampler</option>
        <option value="both">Both</option>
      </select>
    </label>
    <label>Wet/Dry <input type="range" id="voc_mix" data-midicc min="0" max="1" step="0.01" value="0.0"/></label>
    <label>Output Gain <input type="range" id="voc_out" data-midicc min="0" max="2" step="0.01" value="1.0"/></label>
  </div>
  <div class="section">
    <h4>Bands</h4>
    <label>Bands <select id="voc_bands"><option>8</option><option selected>12</option><option>16</option></select></label>
    <label>Low Freq (Hz) <input type="range" id="voc_lo" min="120" max="600" step="1" value="200"/></label>
    <label>High Freq (Hz) <input type="range" id="voc_hi" min="3000" max="12000" step="10" value="5000"/></label>
    <label>Bandwidth (Q) <input type="range" id="voc_q" min="0.5" max="6" step="0.1" value="2.0"/></label>
    <label>Formant Shift (st) <input type="range" id="voc_shift" min="-6" max="6" step="0.1" value="0"/></label>
    <label>Sibilance Mix <input type="range" id="voc_sib" min="0" max="1" step="0.01" value="0.15"/></label>
  </div>
  <div class="section">
    <h4>Modulator (Mic)</h4>
    <label>Mod Gain <input type="range" id="voc_mod_gain" min="0" max="6" step="0.01" value="1.0"/></label>
    <label>Gate (dB) <input type="range" id="voc_gate" min="-90" max="0" step="1" value="-70"/></label>
    <label>Attack (ms) <input type="range" id="voc_att" min="0" max="200" step="1" value="12"/></label>
    <label>Release (ms) <input type="range" id="voc_rel" min="20" max="1000" step="1" value="160"/></label>
    <div style="grid-column:1/-1;display:flex;gap:8px;flex-wrap:wrap;align-items:center">
      <button id="voc_test" class="synth-btn">Test Mic</button>
      <span id="voc_status" class="badge"></span>
    </div>
  </div>
</div>

<main class="app">
  <div class="controls">
    <div style="display:flex;align-items:center;gap:8px">
      <button id="octDown" class="synth-btn" style="width:40px">‚àí</button>
      <div id="octReadout" class="readout">0</div>
      <button id="octUp" class="synth-btn" style="width:40px">+</button>
    </div>
    <div class="wheel" id="bendWheel" title="Pitch Bend">
      <div class="center"></div>
      <div class="marker" id="bendMarker"></div>
    </div>
    <button id="microBtn" class="synth-btn owl" title="Quartertone mode">
      <svg viewBox="0 0 100 100" width="22" height="22"><circle cx="50" cy="50" r="40" fill="none" stroke="#25ff85" stroke-width="8"/><text x="50" y="58" text-anchor="middle" font-size="42" fill="#25ff85">ü¶â</text></svg>
    </button>
<button id="llToggleOverlay" type="button" class="synth-btn" role="switch" aria-checked="false" aria-pressed="false" title="Low Latency Mode">LL</button>
    <span id="midiState" class="badge" aria-live="polite"></span>
  </div>
  <div id="keypadWrap" class="keypad-wrap">
    <div id="keypad" class="keypad" aria-label="Keypad"></div>
  </div>
</main>

<footer class="footer">WebAudio ‚Ä¢ WebMIDI + CC Learn ‚Ä¢ Full Synth ‚Ä¢ FX Suite ‚Ä¢ Granular ‚Ä¢ Sampler</footer>

<script>
/* ===== Utilities ===== */
const clamp=(v,min,max)=>v<min?min:v>max?max:v;
function u8ToB64(u8){ const CHUNK=0x7000; let out=''; for(let i=0;i<u8.length;i+=CHUNK){ const slice=u8.subarray(i,i+CHUNK); out+=String.fromCharCode.apply(null,slice); } return btoa(out); }
function b64EncodeUnicode(str){ try{ return btoa(unescape(encodeURIComponent(str))); }catch{ return btoa(str); } }
function b64DecodeUnicode(str){ try{ return decodeURIComponent(escape(atob(str))); }catch{ return atob(str); } }
const midiToFreq=m=>440*Math.pow(2,(m-69)/12);
function tapToUnlockAudio(){
  try{
    if(!audioCtx) return;
    const b = audioCtx.createBuffer(1, 1, audioCtx.sampleRate);
    const s = audioCtx.createBufferSource(); s.buffer = b; s.connect(audioCtx.destination);
    try{ s.start(0); }catch{} s.disconnect();
  }catch{}
}

/* ===== Core state ===== */
let audioCtx=null; let GRID_W=4; let gridRows=/Android|iPhone|iPad|iPod/i.test(navigator.userAgent)?8:4;
let octaveOffset=0; const BASE_MIDI=60;
let bendSemis=0; let bendRange=2; let microMode=false;

/* ===== Recording bus & shared stores ===== */
let mixNode=null, limiter=null, mediaStreamDest=null, mediaRecorder=null;
let recChunks=[], recStartTs=0, recInter=null; const MAX_REC_S=15;
const TAKES_KEY='stagsynth_takes_v5';
function loadTakes(){ try{ return JSON.parse(localStorage.getItem(TAKES_KEY)||'{}'); }catch{return{}} }
function saveTakes(o){ try{ localStorage.setItem(TAKES_KEY, JSON.stringify(o)); }catch{} }
/* ===== Setup / teardown ===== */
function setupRecordingBus(){
  const a=audioCtx;
  mixNode=a.createGain(); mixNode.gain.value=.95;

  // Safety limiter at the very end
  limiter=a.createDynamicsCompressor();
  limiter.threshold.value=-10; limiter.knee.value=20; limiter.ratio.value=8;
  limiter.attack.value=0.003; limiter.release.value=0.25;

  mixNode.connect(limiter).connect(a.destination);

  // Recorder taps the post-limiter signal so captured audio matches what you hear
  mediaStreamDest=a.createMediaStreamDestination();
  limiter.connect(mediaStreamDest);
}

/* Choose recording mime that works broadly; iOS-friendly first */
function pickBestAudioMime(){
  const prefer=[
    'audio/mp4', 'audio/aac', 'audio/mpeg',
    'audio/ogg;codecs=opus', 'audio/webm;codecs=opus', 'audio/webm'
  ];
  for(const m of prefer){
    try{ if(window.MediaRecorder && MediaRecorder.isTypeSupported(m)) return m; }catch{}
  }
  return '';
}

function startTopRecording(){
  if(!mediaStreamDest) return;
  if(!('MediaRecorder' in window)){
    document.getElementById('recTimer').textContent='Recording not supported on this browser.';
    return;
  }
  if(mediaRecorder && mediaRecorder.state==='recording') return;

  const mime = pickBestAudioMime();
  try{
    mediaRecorder = mime
      ? new MediaRecorder(mediaStreamDest.stream,{ mimeType:mime, audioBitsPerSecond:128000 })
      : new MediaRecorder(mediaStreamDest.stream);
  }catch(err){
    document.getElementById('recTimer').textContent='Recorder init failed.';
    console.warn('MediaRecorder init error', err);
    return;
  }

  recChunks=[];
  const recBtn=document.getElementById('recBtn');
  const recLabel=document.getElementById('recLabel');
  recBtn.classList.remove('dim'); recBtn.classList.add('recording'); recLabel.textContent='Stop';

  mediaRecorder.ondataavailable=(e)=>{ if(e.data && e.data.size>0) recChunks.push(e.data); };
  mediaRecorder.onstop = async ()=>{
    try{
      const blob = new Blob(recChunks, { type: mediaRecorder.mimeType || mime || 'audio/mp4' });
      const arr  = await blob.arrayBuffer();
      await ensureAudio();

      let decoded=null;
      try{ decoded = await audioCtx.decodeAudioData(arr.slice(0)); }catch(decErr){ console.warn('decodeAudioData failed', decErr); }

      if(!decoded){
        const url = URL.createObjectURL(blob);
        const el  = new Audio(); el.src = url; el.crossOrigin='anonymous';
        await el.play().catch(()=>{}); el.pause();
        const dur = Math.max(0.01, isFinite(el.duration) && el.duration>0 ? el.duration : 1.0);
        const off = new OfflineAudioContext(2, Math.ceil((audioCtx.sampleRate||48000) * dur), audioCtx.sampleRate||48000);
        const src = off.createMediaElementSource(el);
        src.connect(off.destination);
        el.currentTime = 0;
        decoded = await off.startRendering();
        URL.revokeObjectURL(url);
      }

      // Stash & auto-load into Granulator
      const wavAB = encodeWAVFromBuffer(decoded);
      const b64   = u8ToB64(new Uint8Array(wavAB));
      const takes = loadTakes();
      const nm    = 'Master '+new Date().toLocaleTimeString();
      takes[nm]   = { wavB64:b64, sampleRate: decoded.sampleRate };
      saveTakes(takes);

      currentTakeBuffer = decoded;
      currentTakeName   = nm;
      enableGranularButtons();
      refreshTakeList();
      setGranularStatus('Added & loaded "'+nm+'" from main Record');
    }catch(e){
      console.warn('decode/auto-add error', e);
      setGranularStatus('Recording finished, but decode failed');
    }

    const recBtn=document.getElementById('recBtn'); const recLabel=document.getElementById('recLabel');
    recBtn.classList.remove('recording'); recBtn.classList.add('dim'); recLabel.textContent='Record';
  };

  mediaRecorder.start(100);
  recStartTs = performance.now();

  recInter = setInterval(()=>{
    const elapsed = ((performance.now()-recStartTs)/1000)|0;
    const left    = Math.max(0, MAX_REC_S - elapsed);
    document.getElementById('recTimer').textContent =
      'REC '+(left/60|0)+':'+String(left%60).padStart(2,'0')+' left / '+MAX_REC_S+'s';
    if (elapsed >= MAX_REC_S) stopTopRecording();
  }, 250);
}

function stopTopRecording(){
  if(mediaRecorder && mediaRecorder.state==='recording'){ try{ mediaRecorder.stop(); }catch{} }
  clearInterval(recInter);
  document.getElementById('recTimer').textContent='';
  const recBtn=document.getElementById('recBtn'); const recLabel=document.getElementById('recLabel');
  recBtn.classList.remove('recording'); recBtn.classList.add('dim'); recLabel.textContent='Record';
}

/* ===== Audio bootstrap / reset ===== */
function ensureAudio(){
  if(audioCtx && audioCtx.state==='suspended'){ audioCtx.resume?.(); }
  if(synth) return Promise.resolve(true);

  audioCtx=new (window.AudioContext||window.webkitAudioContext)({latencyHint:'interactive'});

  // iOS Chrome/Safari unlock
  const unlock = ()=>{ audioCtx.resume?.(); tapToUnlockAudio(); };
  window.addEventListener('touchend', unlock, { once:true, passive:true });
  window.addEventListener('click', unlock, { once:true, passive:true });

  setupRecordingBus();
  synth=makeSynth(audioCtx);
  pushParams();
  return Promise.resolve(true);
}
async function hardResetAudio(){
  try{ stopTopRecording(); }catch{}
  try{ stopGranular(true); }catch{}
  try{ killSamplerAll(); }catch{}
  try{ synth?.killAll?.(); }catch{}
  try{ if(mixNode){ mixNode.disconnect(); } }catch{}
  try{ if(limiter){ limiter.disconnect(); } }catch{}
  try{ if(mediaStreamDest){ mediaStreamDest.disconnect(); } }catch{}
  try{ if(audioCtx){ await audioCtx.close(); } }catch{}
  audioCtx=null; mixNode=null; limiter=null; mediaStreamDest=null; mediaRecorder=null;
  synth=null;

  grainTicker=null; scanTicker=null; grainActive=null; granularOut=null;
  samplerBus={out:null, filter:null};

  await ensureAudio();
}

/* ===== Curves ===== */
function makeDriveCurve(amount=0){
  const k=amount*20; const n=44100; const c=new Float32Array(n);
  for(let i=0;i<n;i++){ const x=i/(n-1)*2-1; c[i]=(1+k)*x/(1+k*Math.abs(x)); }
  return c;
}

/* ===== Bitcrusher Worklet (inline) ===== */
let bitcrusherNode=null, bitcrusherMix=null;
async function initBitcrusherWorklet(ctx){
  if(ctx.audioWorklet && !ctx._bcRegistered && !ctx._bcLoading){
    ctx._bcLoading=true;
    const code = `
      class BitcrusherProcessor extends AudioWorkletProcessor{
        static get parameterDescriptors(){
          return [
            { name:'bits', defaultValue:24, minValue:1, maxValue:24, automationRate:'k-rate' },
            { name:'downRate', defaultValue:48000, minValue:50, maxValue:96000, automationRate:'k-rate' }
          ];
        }
        constructor(){ super(); this._phase=0; this._lastL=0; this._lastR=0; }
        process(inputs, outputs, params){
          const input = inputs[0], output = outputs[0];
          if(!input || !input[0] || !output || !output[0]) return true;
          const inL=input[0], inR=input[1]||input[0], outL=output[0], outR=output[1]||output[0];
          const bits = Math.max(1, Math.min(24, params.bits[0]|0));
          const step = Math.max(1, Math.floor(sampleRate / Math.max(50, params.downRate[0]||48000)));
          const levels = Math.max(2, (1<<Math.min(23,bits)));
          const q = 2/levels;
          for(let i=0;i<outL.length;i++){
            if(this._phase===0){
              const l = Math.max(-1,Math.min(1, Math.round(inL[i]/q)*q));
              const r = Math.max(-1,Math.min(1, Math.round(inR[i]/q)*q));
              this._lastL = l; this._lastR = r;
            }
            outL[i]=this._lastL; outR[i]=this._lastR;
            this._phase = (this._phase+1)%step;
          }
          return true;
        }
      }
      try{ if(!globalThis.__bitcrusherRegistered){ registerProcessor('bitcrusher-processor', BitcrusherProcessor); globalThis.__bitcrusherRegistered=true; } }catch(e){ globalThis.__bitcrusherRegistered=true; }
    `;
    const blob = new Blob([code], {type:'application/javascript'});
    const url  = URL.createObjectURL(blob);
    await ctx.audioWorklet.addModule(url);
    URL.revokeObjectURL(url);
    ctx._bcRegistered = true;
    ctx._bcLoading = false;
  }
}

/* ===== Synth engine with WORKING core Filter + FX Suite (all reactive) ===== */
let synth=null;
function makeSynth(a){
  const voices=new Map();

  /* === ALWAYS-IN-PATH CORE FILTER === */
  const coreFilter = a.createBiquadFilter();
  coreFilter.type='lowpass'; coreFilter.frequency.value=1600; coreFilter.Q.value=0.2;

  /* === Optional COLOR bus (drive + wet/dry) AFTER core filter === */
  const colorDry = a.createGain(); colorDry.gain.value=1.0;
  const colorWet = a.createGain(); colorWet.gain.value=0.0;
  const colorSum = a.createGain();
  const colorFilter = a.createBiquadFilter(); colorFilter.type='lowpass'; colorFilter.frequency.value=1600; colorFilter.Q.value=0.2;
  const colorShaper = a.createWaveShaper(); colorShaper.curve = makeDriveCurve(0);

  // coreFilter ‚Üí (dry‚Üísum) + (filter‚Üíshaper‚Üíwet‚Üísum)
  coreFilter.connect(colorDry).connect(colorSum);
  coreFilter.connect(colorFilter).connect(colorShaper).connect(colorWet).connect(colorSum);

  /* === Ring Mod (AM) with depth + wet/dry MIX (FIXED) === */
  const rmCarrier = a.createOscillator(); rmCarrier.type='sine'; rmCarrier.frequency.value=30;
  const rmDepth   = a.createGain(); rmDepth.gain.value=0.0;
  const ringVCA   = a.createGain(); ringVCA.gain.value=0.0;

  const ringDry = a.createGain(); ringDry.gain.value=1.0;
  const ringWet = a.createGain(); ringWet.gain.value=0.0;
  const ringMix = a.createGain();

  colorSum.connect(ringDry);
  colorSum.connect(ringVCA);
  rmCarrier.connect(rmDepth).connect(ringVCA.gain);

  ringVCA.connect(ringWet);
  ringDry.connect(ringMix);
  ringWet.connect(ringMix);

  /* === Chorus (L/R delays) with MIX === */
  const chIn = a.createGain();
  const chDry = a.createGain(); chDry.gain.value=1.0;
  const chWet = a.createGain(); chWet.gain.value=0.0;
  const chOut = a.createGain();
  const chDelayL = a.createDelay(0.05), chDelayR = a.createDelay(0.05);
  const chLFO1 = a.createOscillator(), chLFO2 = a.createOscillator();
  const chDepthL = a.createGain(), chDepthR = a.createGain();
  chLFO1.type='sine'; chLFO2.type='sine';
  chDepthL.gain.value = 0.006; chDepthR.gain.value = 0.006;

  ringMix.connect(chIn);
  chIn.connect(chDelayL).connect(chWet);
  chIn.connect(chDelayR).connect(chWet);
  chIn.connect(chDry);
  chDry.connect(chOut); chWet.connect(chOut);
  chLFO1.connect(chDepthL).connect(chDelayL.delayTime);
  chLFO2.connect(chDepthR).connect(chDelayR.delayTime);

  /* === Distortion (Drive/Tone/Mix) === */
  const distIn  = a.createGain();
  const distPre = a.createGain();
  const distWS  = a.createWaveShaper();
  const distTone= a.createBiquadFilter(); distTone.type='lowpass'; distTone.frequency.value=20000;
  const distDry = a.createGain(); distDry.gain.value=1.0;
  const distWet = a.createGain(); distWet.gain.value=0.0;
  const distSum = a.createGain();

  chOut.connect(distIn);
  distIn.connect(distDry).connect(distSum);
  distIn.connect(distPre).connect(distWS).connect(distTone).connect(distWet).connect(distSum);

  /* === Bitcrusher (worklet) with MIX === */
  const bcIn  = a.createGain();
  const bcDry = a.createGain(); bcDry.gain.value = 1.0;
  const bcWet = a.createGain(); bcWet.gain.value = 0.0;
  const bcSum = a.createGain();
  distSum.connect(bcIn);
  bcIn.connect(bcDry).connect(bcSum);
  (async ()=>{
    await initBitcrusherWorklet(a);
    const node = new AudioWorkletNode(a, 'bitcrusher-processor', { numberOfInputs:1, numberOfOutputs:1, outputChannelCount:[2] });
    bitcrusherNode = node;
    bitcrusherMix  = { dry: bcDry, wet: bcWet };
    bcIn.connect(node).connect(bcWet);
    bcWet.connect(bcSum);
  })();

  /* === Reverb (predelay ‚Üí convolver ‚Üí damp LPF) with MIX === */
  const revIn = a.createGain(), revOut = a.createGain();
  const revDry = a.createGain(); revDry.gain.value=1.0;
  const revWet = a.createGain(); revWet.gain.value=0.0;
  const revPre = a.createDelay(0.25);
  const revConv = a.createConvolver();
  const revDamp = a.createBiquadFilter(); revDamp.type='lowpass'; revDamp.frequency.value=6000;

  bcSum.connect(revIn);
  revIn.connect(revDry).connect(revOut);
  revIn.connect(revPre).connect(revConv).connect(revDamp).connect(revWet).connect(revOut);

  /* === Compressor + Makeup ‚Üí master limiter === */
  const comp = a.createDynamicsCompressor();
  const makeup = a.createGain(); makeup.gain.value=1.0;
  const synthBus = a.createGain(); synthBus.gain.value=1.0; revOut.connect(comp).connect(makeup).connect(synthBus).connect(mixNode); try{ window._stagsynth_synthBus=synthBus; window._stagsynth_synthCtx=a; }catch{}

  // Start carriers/LFOs
  try{ rmCarrier.start(); chLFO1.start(); chLFO2.start(); }catch{}

  // ===== Params (neutral FX by default) =====
  const params={
    // Core synth filter
    mode:'lp', cutoff:1600, resonance:0.2,

    // Color bus
    drive:0, mix:0,

    // Reverb (predelay in ms in UI)
    fx_rev_room:0.6, fx_rev_decay:3.0, fx_rev_predelay:20, fx_rev_damp:6000, fx_rev_mix:0.0,

    // Chorus (depth in ms in UI)
    fx_ch_rate:1.0, fx_ch_depth:6, fx_ch_voices:2, fx_ch_width:0.8, fx_ch_mix:0.0,

    // Distortion
    fx_dist_type:'soft', fx_dist_drive:0.0, fx_dist_tone:20000, fx_dist_mix:0.0,

    // Compressor (attack/release in ms in UI)
    fx_comp_thr:0, fx_comp_ratio:1, fx_comp_att:5, fx_comp_rel:200, fx_comp_makeup:0,

    // Bitcrusher
    fx_bc_bits:24, fx_bc_rate:48000, fx_bc_mix:0.0,

    // Ring Mod
    fx_rm_freq:30, fx_rm_wave:'sine', fx_rm_depth:0.0, fx_rm_mix:0.0,

    // Osc / env
    shape:'sawtooth', subShape:'off', detune:0, subDetune:0, subLevel:0.8, subOctave:1, noiseColor:'white',
    a:0.01,d:0.08,s:0.6,r:0.15
  };

  // ===== Setters =====
  function applyCoreFilter(){
    coreFilter.type = (params.mode==='hp')?'highpass' : (params.mode==='bp')?'bandpass' : 'lowpass';
    coreFilter.frequency.value = Math.max(40, params.cutoff||1600);
    coreFilter.Q.value = Math.max(0, Math.min(20, (params.resonance||0.2)*20));
    // color prefilter follows core tone so drive coloration tracks
    colorFilter.type = coreFilter.type;
    colorFilter.frequency.value = coreFilter.frequency.value;
    colorFilter.Q.value = coreFilter.Q.value*0.6;
  }
  function setColor(){
    colorShaper.curve = makeDriveCurve(Math.max(0, Math.min(1, params.drive||0)));
    const m = Math.max(0, Math.min(1, params.mix||0));
    colorWet.gain.value = m; colorDry.gain.value = 1 - m;
  }
  function regenImpulse(room=0.6, decay=3.0){
    const dur = Math.max(0.2, decay) * (0.6 + room*0.8);
    const len = Math.ceil(a.sampleRate * Math.min(12, dur));
    const buf = a.createBuffer(2, len, a.sampleRate);
    for(let ch=0; ch<2; ch++){
      const data = buf.getChannelData(ch);
      for(let i=0;i<len;i++){
        const t = i/len;
        const env = Math.pow(1 - t, 2.5);
        data[i] = (Math.random()*2-1) * env;
      }
    }
    return buf;
  }
  function setReverb(){
    const predelaySec = Math.max(0, (params.fx_rev_predelay||20) / 1000); // ms ‚Üí s
    revConv.buffer = regenImpulse(params.fx_rev_room, params.fx_rev_decay);
    revPre.delayTime.value = predelaySec;
    revDamp.frequency.value = params.fx_rev_damp;
    const mix = Math.max(0, Math.min(1, params.fx_rev_mix||0));
    revWet.gain.value = mix; revDry.gain.value = 1 - mix;
  }
  function setChorus(){
    const rate = params.fx_ch_rate;
    const depthSec = Math.max(0, (params.fx_ch_depth||6))/1000; // ms‚Üís
    chDepthL.gain.value = depthSec;
    chDepthR.gain.value = depthSec * (0.5 + params.fx_ch_width*0.5);
    chLFO1.frequency.value = rate;
    chLFO2.frequency.value = rate * (0.9 + params.fx_ch_width*0.2);
    chWet.gain.value = params.fx_ch_mix;
    chDry.gain.value = 1 - params.fx_ch_mix;
  }
  function makeDistCurve(type='soft', drive=0){
    const n = 44100, curve = new Float32Array(n);
    const kSoft = 1e-3 + drive * 40;
    const kTanh = 1 + drive * 10;
    const tHard = 1 - 0.8 * drive;
    for(let i=0;i<n;i++){
      const x = i/(n-1)*2 - 1;
      let y = x;
      if(type==='soft'){
        y = (1+kSoft)*x/(1+kSoft*Math.abs(x));
      }else if(type==='tanh'){
        y = Math.tanh(kTanh * x);
      }else{
        const t = Math.max(0.2, tHard);
        const c = Math.max(-t, Math.min(t, x));
        y = c / t;
      }
      curve[i]=y;
    }
    return curve;
  }
  function setDistortion(){
    const type = params.fx_dist_type||'soft';
    const drv  = Math.max(0, Math.min(1, params.fx_dist_drive||0));
    distWS.curve = makeDistCurve(type, drv);
    distPre.gain.value = 1 + drv * 20;
    distTone.frequency.value = Math.max(1000, Math.min(20000, params.fx_dist_tone||20000));
    const mix = Math.max(0, Math.min(1, params.fx_dist_mix||0));
    distWet.gain.value = mix; distDry.gain.value = 1 - mix;
  }
  function setRing(){
    rmCarrier.type = params.fx_rm_wave||'sine';
    rmCarrier.frequency.value = params.fx_rm_freq||30;
    rmDepth.gain.value = Math.max(0, params.fx_rm_depth||0); // AM depth
    const mix = Math.max(0, Math.min(1, params.fx_rm_mix||0));
    ringWet.gain.value = mix;      // effective now
    ringDry.gain.value = 1 - mix;  // effective now
  }
  function setBitcrusher(){
    const sr = a.sampleRate || 48000;
    const rate = Math.max(50, Math.min(sr, params.fx_bc_rate || sr));
    const bits = Math.max(1, Math.min(24, params.fx_bc_bits || 24));
    if(bitcrusherNode){
      bitcrusherNode.parameters.get('bits')?.setValueAtTime(bits, a.currentTime);
      bitcrusherNode.parameters.get('downRate')?.setValueAtTime(rate, a.currentTime);
    }
    const mix = Math.max(0, Math.min(1, params.fx_bc_mix||0));
    bcWet.gain.value = mix; bcDry.gain.value = 1 - mix;
  }
  function setCompressor(){
    const attSec = Math.max(0.0001, (params.fx_comp_att||5) / 1000);  // ms‚Üís
    const relSec = Math.max(0.001,  (params.fx_comp_rel||200) / 1000);
    comp.threshold.value = params.fx_comp_thr;
    comp.ratio.value     = params.fx_comp_ratio;
    comp.attack.value    = attSec;
    comp.release.value   = relSec;
    makeup.gain.value    = Math.pow(10, (params.fx_comp_makeup||0)/20);
  }

  // Initialize processing graph states
  applyCoreFilter(); setColor(); setReverb(); setChorus(); setDistortion(); setRing(); setCompressor();
  (async()=>{ await initBitcrusherWorklet(a); setBitcrusher(); })();

  // ===== Voice helpers =====
  const shapeMap={saw:'sawtooth',sawtooth:'sawtooth',square:'square',triangle:'triangle',sine:'sine',noise:'noise',off:'off'};
  function noise(color){
    const buffer=a.createBuffer(1, a.sampleRate*2, a.sampleRate);
    const data=buffer.getChannelData(0);
    if(color==='pink'){ let b0=0, AA=0.997; for(let i=0;i<data.length;i++){ const w=Math.random()*2-1; b0=AA*b0+(1-AA)*w; data[i]=b0*1.5; } }
    else { for(let i=0;i<data.length;i++) data[i]=Math.random()*2-1; }
    const src=a.createBufferSource(); src.buffer=buffer; src.loop=true; return src;
  }
  function osc(freq, type){ if(type==='noise') return noise(params.noiseColor||'white'); const o=a.createOscillator(); o.type=type; o.frequency.value=freq; return o; }
  function env(){ const clamp01=(x)=>Math.max(0,Math.min(1,x)); return { a:Math.max(.001,params.a), d:Math.max(.001,params.d), s:clamp01(params.s), r:Math.max(.001,params.r) }; }

  // ===== Public synth API =====
  return{
    _params: {...params},
    set(name,value){
      this._params[name]=value;
      // Core filter
      if(name==='mode'||name==='cutoff'||name==='resonance'){ params[name]=value; applyCoreFilter(); return; }
      // Color drive/mix
      if(name==='drive'||name==='mix'){ params[name]=value; setColor(); return; }
      // FX
      if(name.startsWith('fx_rev_')){ params[name]=value; setReverb(); return; }
      if(name.startsWith('fx_ch_')){ params[name]=value; setChorus(); return; }
      if(name.startsWith('fx_dist_')){ params[name]=value; setDistortion(); return; }
      if(name.startsWith('fx_comp_')){ params[name]=value; setCompressor(); return; }
      if(name.startsWith('fx_bc_')){ params[name]=value; setBitcrusher(); return; }
      if(name.startsWith('fx_rm_')){ params[name]=value; setRing(); return; }
      // Osc / env params
      params[name]=value;
      if(name==='detune'||name==='subDetune'){ this.setBend?.(bendSemis); }
    },
    setBend(semi){
      const ratio=Math.pow(2,(semi||0)/12);
      for(const v of voices.values()){
        const base=v.baseFreq;
        v.main?.forEach(o=>{ if(o.frequency){ o.frequency.value = base * Math.pow(2,((this._params?.detune)||0)/1200) * ratio; } });
        v.sub ?.forEach(o=>{ if(o.frequency){ const b=((this._params?.subOctave||1)===0.5)?(base/2):base; o.frequency.value = b * Math.pow(2,((this._params?.subDetune)||0)/1200) * ratio; } });
      }
    },
    noteOn(m,vel=0.9){
      const key = Math.round(m*2)/2;
      const freq = midiToFreq(m);
      const existing = voices.get(key);
      const e = env(); const t=a.currentTime; const peak=.28*vel;
      if(existing){
        try{
          existing.g.gain.cancelScheduledValues(t); existing.g.gain.setValueAtTime(1e-5,t);
          existing.g.gain.linearRampToValueAtTime(peak,t+e.a);
          existing.g.gain.linearRampToValueAtTime(peak*e.s,t+e.a+e.d);
          existing.e=e; existing.baseFreq=freq;
        }catch{}
        try{ this.setBend?.(bendSemis) }catch{};
        return;
      }
      // Per-voice gain ‚Üí CORE FILTER (global) ‚Üí rest of graph
      const g=a.createGain(); g.gain.value=1e-5; g.connect(coreFilter);

      // Main & sub osc
      const mainType=shapeMap[params.shape]||'sawtooth';
      const subType =shapeMap[params.subShape]||'off';
      const main=(mainType==='noise')?[noise(params.noiseColor||'white')]:[osc(freq*Math.pow(2,(params.detune||0)/1200),mainType)];
      const base=((params.subOctave||1)===0.5)?(freq/2):freq;
      const sub =(subType==='off')?[]:(subType==='noise')?[noise(params.noiseColor||'white')]:[osc(base*Math.pow(2,(params.subDetune||0)/1200),subType)];

      const subG=a.createGain(); subG.gain.value=Math.max(0,Math.min(1,params.subLevel||0)); subG.connect(g);
      main.forEach(nd=>{ nd.connect(g); try{ nd.start() }catch{} });
      sub.forEach (nd=>{ nd.connect(subG); try{ nd.start() }catch{} });

      // ADSR
      g.gain.setValueAtTime(1e-5,t); g.gain.linearRampToValueAtTime(peak,t+e.a); g.gain.linearRampToValueAtTime(peak*e.s,t+e.a+e.d);

      voices.set(key,{g,e,baseFreq:freq,main,sub});
      try{ this.setBend?.(bendSemis) }catch{};
    },
    noteOff(m){
      const key=Math.round(m*2)/2; const v=voices.get(key); if(!v) return;
      const t=a.currentTime, stopAt=t+v.e.r+.02;
      try{
        v.g.gain.cancelScheduledValues(t);
        v.g.gain.setValueAtTime(v.g.gain.value,t);
        v.g.gain.linearRampToValueAtTime(1e-5,stopAt);
        v.main?.forEach(nd=>{ try{ nd.stop(stopAt) }catch{} });
        v.sub ?.forEach(nd=>{ try{ nd.stop(stopAt) }catch{} });
      }catch{}
      setTimeout(()=>voices.delete(key),120);
    },
    killAll(){
      const t=a.currentTime+.01;
      for(const [k,v] of voices.entries()){
        try{
          v.g.gain.cancelScheduledValues(t);
          v.g.gain.setValueAtTime(1e-5,t);
          v.main?.forEach(nd=>{ try{ nd.stop(t+.02) }catch{} });
          v.sub ?.forEach(nd=>{ try{ nd.stop(t+.02) }catch{} });
        }catch{}
      }
      voices.clear();
    }
  };
}

/* ===== Presets ===== */
const PRESET_KEY='stagsynth_presets_v5';
const PRESET_PARAMS=[
  'shape','subShape','detune','subDetune','subLevel','subOctave','noiseColor',
  'mode','cutoff','resonance','a','d','s','r','drive','mix',
  'fx_rev_room','fx_rev_decay','fx_rev_predelay','fx_rev_damp','fx_rev_mix',
  'fx_ch_rate','fx_ch_depth','fx_ch_voices','fx_ch_width','fx_ch_mix',
  'fx_dist_type','fx_dist_drive','fx_dist_tone','fx_dist_mix',
  'fx_comp_thr','fx_comp_ratio','fx_comp_att','fx_comp_rel','fx_comp_makeup',
  'fx_bc_bits','fx_bc_rate','fx_bc_mix',
  'fx_rm_freq','fx_rm_wave','fx_rm_depth','fx_rm_mix'
];
function loadPresetStore(){ try{ return JSON.parse(localStorage.getItem(PRESET_KEY)||'{}'); }catch{return{}} }
function savePresetStore(s){ try{ localStorage.setItem(PRESET_KEY, JSON.stringify(s)); }catch{} }
function readUI(){ const o={}; PRESET_PARAMS.forEach(k=>{ const el=document.getElementById(k); if(el){ o[k]=(el.type==='range'||el.type==='number')?parseFloat(el.value):el.value; } }); return o; }
function applyPreset(p){ if(!p) return; Object.entries(p).forEach(([k,v])=>{ const el=document.getElementById(k); if(!el) return; el.value = (el.type==='range'||el.type==='number')? String(v): v; }); pushParams(); }
function initPresets(){
  const sel=document.getElementById('presetSelect');
  const name=document.getElementById('presetName');
  const saveB=document.getElementById('savePresetBtn');
  const loadB=document.getElementById('loadPresetBtn');
  const delB=document.getElementById('deletePresetBtn');
  const expB=document.getElementById('exportPresetsBtn');
  const impB=document.getElementById('importPresetsBtn');
  const impF=document.getElementById('importPresetsFile');
  const shareB=document.getElementById('shareLinkBtn');
  const msg=document.getElementById('presetMsg');
  let store=loadPresetStore();

  const incoming=(location.hash||'').match(/[#&]presets=([^&]+)/);
  if(incoming){ try{ const obj=JSON.parse(b64DecodeUnicode(incoming[1])); store={...store, ...obj}; savePresetStore(store); history.replaceState(null,'',location.pathname); }catch{} }

  if(Object.keys(store).length===0){ store['Init']=readUI(); savePresetStore(store); }
  function refresh(nm){ const prev=sel.value; sel.innerHTML=''; Object.keys(store).sort().forEach(n=>{ const o=document.createElement('option'); o.value=n; o.textContent=n; sel.appendChild(o); }); sel.value = nm ? nm : (prev || sel.value); }
  refresh('Init');

  saveB.onclick=()=>{ const nm=(name.value||'Preset').trim(); store[nm]=readUI(); savePresetStore(store); refresh(nm); };
  loadB.onclick=()=>{ applyPreset(store[sel.value]); };
  delB.onclick=()=>{ const nm=sel.value; delete store[nm]; savePresetStore(store); refresh(); };
  expB.onclick=()=>{ const blob=new Blob([JSON.stringify(store,null,2)],{type:'application/json'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='stagsynth-presets.json'; a.click(); setTimeout(()=>URL.revokeObjectURL(url),1000); };
  impB.onclick=()=>impF.click();
  impF.onchange=async()=>{ const f=impF.files?.[0]; if(!f) return; try{ const txt=await f.text(); const data=JSON.parse(txt); store={...store,...data}; savePresetStore(store); refresh(); }catch(e){} impF.value='';
  };
  shareB.onclick=async()=>{
    const url=location.origin+location.pathname + '#presets=' + b64EncodeUnicode(JSON.stringify(store));
    try{ await navigator.clipboard.writeText(url); msg.textContent='Link copied'; setTimeout(()=>msg.textContent='',1200); }catch{ prompt('Copy URL', url); }
  };
}

/* ===== Param push (includes FX) ===== */
function pushParams(){
  if(!synth) return;
  [
    'shape','subShape','detune','subDetune','mode','cutoff','resonance','a','d','s','r','drive','mix','subLevel','subOctave','noiseColor',
    'fx_rev_room','fx_rev_decay','fx_rev_predelay','fx_rev_damp','fx_rev_mix',
    'fx_ch_rate','fx_ch_depth','fx_ch_voices','fx_ch_width','fx_ch_mix',
    'fx_dist_type','fx_dist_drive','fx_dist_tone','fx_dist_mix',
    'fx_comp_thr','fx_comp_ratio','fx_comp_att','fx_comp_rel','fx_comp_makeup',
    'fx_bc_bits','fx_bc_rate','fx_bc_mix',
    'fx_rm_freq','fx_rm_wave','fx_rm_depth','fx_rm_mix'
  ].forEach(id=>{
    const el=document.getElementById(id);
    if(!el) return;
    const val=(el.type==='range'||el.type==='number')?parseFloat(el.value):el.value;
    try{synth.set(id,val)}catch{};
  });
}

/* ===== Keypad, micro, bend ===== */
function buildKeypad(){
  const pad=document.getElementById('keypad'); pad.innerHTML=''; pad.style.gridTemplateColumns='repeat('+GRID_W+',1fr)';
  const total=GRID_W*gridRows, step = microMode?0.5:1;
  for(let i=0;i<total;i++){
    const m=BASE_MIDI + i*step + 12*octaveOffset;
    const b=document.createElement('button'); b.className='key'; b.dataset.midi=String(m); b.textContent='';
    b.onpointerdown=(e)=>{ e.preventDefault(); b.setPointerCapture?.(e.pointerId); b.classList.add('on'); routeNoteOn(m,.9); };
    b.onpointerup=()=>{ b.classList.remove('on'); routeNoteOff(m); };
    b.onpointerleave=()=>{ b.classList.remove('on'); routeNoteOff(m); };
    pad.appendChild(b);
  }
}
function bindKeyboard(){
  const map=['a','w','s','e','d','f','t','g','y','h','u','j','k','o','l','p'];
  window.addEventListener('keydown',e=>{ if(e.repeat) return; const idx=map.indexOf(e.key?.toLowerCase?.()); if(idx<0) return; const btn=document.querySelectorAll('.key')[idx]; if(!btn) return; btn.dispatchEvent(new PointerEvent('pointerdown',{bubbles:true})); });
  window.addEventListener('keyup',e=>{ const idx=map.indexOf(e.key?.toLowerCase?.()); if(idx<0) return; const btn=document.querySelectorAll('.key')[idx]; if(!btn) return; btn.dispatchEvent(new PointerEvent('pointerup',{bubbles:true})); });
}
function bindBendAndMicro(){
  const wheel=document.getElementById('bendWheel');
  const marker=document.getElementById('bendMarker');
  let active=false;
  function setBendFromY(y, rect){
    const rel = 1 - (y/rect.height);
    let semi = (rel - 0.5) * (bendRange*2);
    bendSemis = clamp(semi, -bendRange, bendRange);
    const pct = (0.5 - bendSemis/(bendRange*2)) * 100;
    marker.style.top = pct + '%';
    try{ synth?.setBend?.(bendSemis) }catch{}
  }
  function resetWheel(){ bendSemis = 0; try{ synth?.setBend?.(0) }catch{} marker.style.top='50%'; }
  wheel?.addEventListener('pointerdown', (e)=>{ active=true; wheel.setPointerCapture?.(e.pointerId); const r=wheel.getBoundingClientRect(); setBendFromY(e.clientY - r.top, r); });
  wheel?.addEventListener('pointermove', (e)=>{ if(!active) return; const r=wheel.getBoundingClientRect(); setBendFromY(e.clientY - r.top, r); });
  function upHandler(e){ if(!active) return; active=false; wheel.releasePointerCapture?.(e.pointerId); resetWheel(); }
  wheel?.addEventListener('pointerup', upHandler);
  wheel?.addEventListener('pointerleave', upHandler);

  const micro=document.getElementById('microBtn');
  micro?.addEventListener('click', ()=>{
    microMode = !microMode;
    bendRange = microMode ? 4 : 2;
    if(microMode){ micro.classList.add('micro-on'); } else { micro.classList.remove('micro-on'); }
    buildKeypad();
  });
}
/* ===== WebMIDI + CC Learn ===== */
let midiAccess=null; let midiLearn=false, learnTarget=null;
const MIDIMAP_KEY='stagsynth_midi_cc_map_v1'; let midiMapStore={ cc:{} };
function loadMidiMap(){ try{ const raw=localStorage.getItem(MIDIMAP_KEY); if(raw) midiMapStore=JSON.parse(raw)||{cc:{}}; }catch{} }
function saveMidiMap(){ try{ localStorage.setItem(MIDIMAP_KEY, JSON.stringify(midiMapStore)); }catch{} }
function setMidiState(t){ const el=document.getElementById('midiState'); if(el) el.textContent=t||''; }
async function connectMIDI(){
  try{
    const acc=await navigator.requestMIDIAccess({sysex:false}); midiAccess=acc;
    if(acc.inputs && acc.inputs.size>0){
      for(const input of acc.inputs.values()){ input.onmidimessage=onMIDI; }
      acc.onstatechange=(e)=>{
        if(e.port.type==='input'){ e.port.onmidimessage=onMIDI; const any=Array.from(acc.inputs.values()).some(p=>p.state==='connected'); setMidiState(any?'MIDI connected':'No MIDI inputs'); }
      };
      setMidiState('MIDI connected');
      document.getElementById('midiLearnBtn').disabled=false;
    }else{
      setMidiState('No MIDI inputs');
      document.getElementById('midiLearnBtn').disabled=true;
    }
  }catch(e){
    setMidiState('MIDI unavailable');
    document.getElementById('midiLearnBtn').disabled=true;
  }
}
function applyCCToElement(el, value){
  if(!el) return;
  if(el.tagName==='SELECT'){
    const opts=Array.from(el.options);
    const idx=Math.min(opts.length-1, Math.max(0, Math.round(value*(opts.length-1))));
    el.selectedIndex=idx; el.dispatchEvent(new Event('input',{bubbles:true})); pushParams();
  }else if(el.type==='checkbox'){
    el.checked = value >= 0.5; el.dispatchEvent(new Event('input',{bubbles:true}));
  }else{
    const min=parseFloat(el.min||'0'), max=parseFloat(el.max||'1');
    const val=min+(max-min)*value;
    el.value=String(val); el.dispatchEvent(new Event('input',{bubbles:true})); pushParams();
  }
}
let lastSeenCC=0;
function mapMidiNoteToMicro(midiNote){ const n=midiNote-60; return microMode ? (BASE_MIDI+n*0.5+12*octaveOffset) : (BASE_MIDI+n+12*octaveOffset); }
function onMIDI(ev){
  const [st,d1,d2]=ev.data; const cmd=st&0xF0;
  if(cmd===0x90 && d2>0){ const m=mapMidiNoteToMicro(d1); routeNoteOn(m, Math.max(.2,d2/127)); return; }
  if(cmd===0x80 || (cmd===0x90 && d2===0)){ const m=mapMidiNoteToMicro(d1); routeNoteOff(m); return; }
  if(cmd===0xE0){
    const lsb=d1|0, msb=d2|0; const value=(msb<<7)|lsb; const norm=(value-8192)/8192;
    bendSemis = clamp(norm*bendRange, -bendRange, bendRange);
    try{ synth?.setBend?.(bendSemis) }catch{}
    const marker=document.getElementById('bendMarker'); if(marker){ const pct=(0.5 - bendSemis/(bendRange*2))*100; marker.style.top=pct+'%'; }
    return;
  }
  if(cmd===0xB0){
    lastSeenCC=d1|0; const norm=(d2|0)/127;
    if(midiLearn && learnTarget){
      midiMapStore.cc[String(lastSeenCC)] = learnTarget; saveMidiMap();
      const msg=document.getElementById('midiState'); if(msg) msg.textContent='Mapped CC '+lastSeenCC+' ‚Üí '+learnTarget;
      document.querySelectorAll('[data-midicc]').forEach(e=>e.classList.remove('midi-learn-on'));
      learnTarget=null; midiLearn=false; document.getElementById('midiLearnBtn').classList.remove('midi-learn-on'); return;
    }
    const targetId=midiMapStore.cc[String(lastSeenCC)]; if(targetId){ const el=document.getElementById(targetId); applyCCToElement(el, norm); }
  }
}
function attachLearnClicks(){
  document.querySelectorAll('[data-midicc]').forEach(el=>{
    el.addEventListener('click', ()=>{
      if(!midiLearn) return;
      document.querySelectorAll('[data-midicc]').forEach(e=>e.classList.remove('midi-learn-on'));
      learnTarget=el.id; el.classList.add('midi-learn-on');
    });
  });
}

/* ===== Granular ===== */
let currentTakeBuffer=null, currentTakeName='';
let grainTicker=null, scanTicker=null, grainActive=null;
let granularOut=null;
const g={};
function setGranularStatus(t){ const el=document.getElementById('g_status'); if(el) el.textContent=t||''; }
function enableGranularButtons(){ const has=!!currentTakeBuffer; const gl=document.getElementById('g_takeList'); document.getElementById('g_saveTake').disabled=!has; document.getElementById('g_exportTake').disabled=!has; document.getElementById('g_deleteTake').disabled=!gl.value; }
function refreshTakeList(){
  const list=document.getElementById('g_takeList'); if(!list) return;
  const store=loadTakes(); const names=Object.keys(store).sort();
  const prev=list.value; list.innerHTML='';
  names.forEach(n=>{ const o=document.createElement('option'); o.value=n; o.textContent=n; list.appendChild(o); });
  list.value=prev && names.includes(prev) ? prev : (names[0]||'');
  enableGranularButtons();
  const del=document.getElementById('g_deleteTake');
  if(del) del.onclick=()=>{ const nm=list.value; if(!nm) return; const s=loadTakes(); delete s[nm]; saveTakes(s); refreshTakeList(); setGranularStatus('Deleted '+nm); };
}
function encodeWAVFromBuffer(buf){
  const nCh=buf.numberOfChannels, len=buf.length, sr=buf.sampleRate;
  const dataLen=len*nCh*2; const total=dataLen+44;
  const ab=new ArrayBuffer(total), v=new DataView(ab);
  function w(off,str){ for(let i=0;i<str.length;i++) v.setUint8(off+i,str.charCodeAt(i)); }
  w(0,'RIFF'); v.setUint32(4,total-8,true); w(8,'WAVE'); w(12,'fmt '); v.setUint32(16,16,true); v.setUint16(20,1,true); v.setUint16(22,nCh,true); v.setUint32(24,sr,true); v.setUint32(28,sr*2*nCh,true); v.setUint16(32,2*nCh,true); v.setUint16(34,16,true); w(36,'data'); v.setUint32(40,dataLen,true);
  let pos=44; const ch=[]; for(let c=0;c<nCh;c++) ch.push(buf.getChannelData(c));
  for(let i=0;i<len;i++){ for(let c=0;c<nCh;c++){ let s=Math.max(-1,Math.min(1,ch[c][i])); v.setInt16(pos, s<0?s*0x8000:s*0x7FFF, true); pos+=2; } }
  return ab;
}
async function saveCurrentTake(){
  if(!currentTakeBuffer) return;
  const nm=prompt('Take name:', currentTakeName||('Take '+new Date().toLocaleTimeString())); if(!nm) return;
  const wav=encodeWAVFromBuffer(currentTakeBuffer);
  const b64=u8ToB64(new Uint8Array(wav));
  const s=loadTakes(); s[nm]={ wavB64:b64, sampleRate: currentTakeBuffer.sampleRate }; saveTakes(s);
  refreshTakeList(); setGranularStatus('Saved "'+nm+'"');
}
function exportCurrentTake(){
  if(!currentTakeBuffer) return;
  const wav=encodeWAVFromBuffer(currentTakeBuffer); const blob=new Blob([wav],{type:'audio/wav'});
  const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=(currentTakeName||'take')+'.wav'; a.click(); setTimeout(()=>URL.revokeObjectURL(url),1e3);
}
async function loadSelectedTake(){
  const nm=document.getElementById('g_takeList').value; if(!nm) return;
  const s=loadTakes(); const rec=s[nm]; if(!rec) return;
  const bin=atob(rec.wavB64); const u8=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) u8[i]=bin.charCodeAt(i);
  await ensureAudio(); const ab=await audioCtx.decodeAudioData(u8.buffer.slice(0)); currentTakeBuffer=ab; currentTakeName=nm; setGranularStatus('Loaded "'+nm+'" ('+ab.duration.toFixed(2)+'s)'); enableGranularButtons();
}
function startGranular(){
  if(!currentTakeBuffer||!audioCtx){ setGranularStatus('No take'); return; }
  stopGranular(true);
  granularOut=audioCtx.createGain(); granularOut.gain.value=parseFloat(g['g_gain'].value||'0.7');
  granularOut.connect(mixNode);
  grainActive=new Set();
  let posPct=(parseFloat(g['g_pos'].value)||0)/100;
  let last=audioCtx.currentTime; let acc=0;
  const buf=currentTakeBuffer;
  function read(){ return { loop:g['g_loop'].checked, freeze:g['g_freeze'].checked, sizeSec:Math.max(.01,(parseFloat(g['g_size'].value)||120)/1000), density:Math.max(1,(parseFloat(g['g_density'].value)||30)), spray:(parseFloat(g['g_spray'].value)||15)/1000, rate:Math.max(.05,parseFloat(g['g_rate'].value)||1), gain:Math.max(0,parseFloat(g['g_gain'].value)||.7), scan:(parseFloat(g['g_scan'].value)||10)/100 }; }
  function spawn(t,P){
    let start=posPct*buf.duration + (Math.random()*2-1)*P.spray;
    if(P.loop){ while(start<0) start+=buf.duration; while(start>buf.duration) start-=buf.duration; } else { if(start<0||start>=buf.duration) return; }
    const dur=P.sizeSec;
    const src=audioCtx.createBufferSource(); src.buffer=buf; src.playbackRate.value=P.rate;
    const gNode=audioCtx.createGain(); gNode.gain.value=0.0;
    src.connect(gNode).connect(granularOut);
    grainActive.add(src);
    const t0=t, t1=t0+Math.max(.003,dur*.25), t2=t0+Math.max(.006,dur*.75), t3=t0+dur;
    gNode.gain.setValueAtTime(0.0,t0); gNode.gain.linearRampToValueAtTime(P.gain,t1); gNode.gain.linearRampToValueAtTime(P.gain,t2); gNode.gain.linearRampToValueAtTime(0.0,t3);
    try{ src.start(t0, Math.max(0,start), dur); src.stop(t3+.05); }catch{}
    src.onended=()=>{ try{ grainActive.delete(src); }catch{} };
  }
  grainTicker=setInterval(()=>{
    const now=audioCtx.currentTime; const dt=Math.max(.005, now-last); last=now;
    const P=read();
    acc += P.density*dt; const n=(acc|0); acc-=n;
    for(let i=0;i<n;i++) spawn(now+.02+i*.002,P);
  },20);
  scanTicker=setInterval(()=>{
    const P=read();
    if(!P.freeze){ posPct += P.scan*.02; if(P.loop){ while(posPct<0) posPct+=1; while(posPct>1) posPct-=1; } else { posPct=clamp(posPct,0,1); } document.getElementById('g_pos').value=(posPct*100).toFixed(1); }
  },20);
  setGranularStatus('Granular: playing');
}
function stopGranular(hard=false){
  try{ clearInterval(grainTicker); clearInterval(scanTicker); }catch{}
  grainTicker=null; scanTicker=null;
  if(hard && grainActive){ try{ grainActive.forEach(s=>{ try{s.stop(0);}catch{} }); grainActive.clear(); }catch{} }
  try{ if(granularOut){ granularOut.disconnect(); granularOut=null; } }catch{}
  setGranularStatus('Granular: stopped');
}
function bindGranularPanel(){
  ['g_pos','g_scan','g_size','g_overlap','g_density','g_spray','g_rate','g_gain','g_loop','g_freeze'].forEach(id=> g[id]=document.getElementById(id));
  const recA=document.getElementById('g_startRec');
  const recB=document.getElementById('g_stopRec');
  const save=document.getElementById('g_saveTake');
  const imp=document.getElementById('g_importFile');
  const file=document.getElementById('g_file');
  const exp=document.getElementById('g_exportTake');
  const play=document.getElementById('g_play');
  const stop=document.getElementById('g_stop');
  const list=document.getElementById('g_takeList');
  recA.onclick=()=>{ ensureAudio().then(()=>{ startTopRecording(); recA.disabled=true; recB.disabled=false; }); };
  recB.onclick=()=>{ stopTopRecording(); recA.disabled=false; recB.disabled=true; };
  save.onclick=saveCurrentTake;
  imp.onclick=()=>file.click();
  file.onchange=async()=>{ const f=file.files?.[0]; if(!f) return; const arr=await f.arrayBuffer(); await ensureAudio(); const buf=await audioCtx.decodeAudioData(arr.slice(0)); currentTakeBuffer=buf; currentTakeName=f.name.replace(/\.[^/.]+$/,'')||'Imported'; enableGranularButtons(); setGranularStatus('Loaded file '+currentTakeName); refreshTakeList(); file.value=''; };
  exp.onclick=exportCurrentTake;
  play.onclick=()=> startGranular();
  stop.onclick=()=> stopGranular();
  list.onchange=loadSelectedTake;
  refreshTakeList(); enableGranularButtons();
}

/* ===== Sampler ===== */
const SAMPLER_KEY='stagsynth_sampler_v3';
let samplerLib={}; let samplerCurrent={name:'',buffer:null,root:60};
let samplerVoices=new Map(); let samplerBus={out:null, filter:null};
function loadSamplerLib(){ try{ samplerLib=JSON.parse(localStorage.getItem(SAMPLER_KEY)||'{}'); }catch{ samplerLib={}; } }
function saveSamplerLib(){ try{ localStorage.setItem(SAMPLER_KEY, JSON.stringify(samplerLib)); }catch{} }
function refreshSamplerList(selName){
  const list=document.getElementById('sam_list'); if(!list) return;
  const names=Object.keys(samplerLib).sort(); const prev=list.value; list.innerHTML=''; names.forEach(n=>{ const o=document.createElement('option'); o.value=n; o.textContent=n; list.appendChild(o); });
  list.value = selName ? selName : (prev || list.value);
  document.getElementById('sam_delete').disabled = !list.value;
  document.getElementById('sam_export').disabled = !list.value;
  document.getElementById('sam_save').disabled = !samplerCurrent.buffer;
}
async function decodeB64ToBuffer(b64){
  const bin=atob(b64); const u8=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) u8[i]=bin.charCodeAt(i);
  await ensureAudio(); return audioCtx.decodeAudioData(u8.buffer.slice(0));
}
async function samplerLoadByName(nm){
  const rec=samplerLib[nm]; if(!rec) return;
  const buf=await decodeB64ToBuffer(rec.wavB64);
  samplerCurrent={ name:nm, buffer:buf, root:rec.root||60 };
  document.getElementById('sam_name').value=nm;
  document.getElementById('sam_root').value=String(rec.root||60);
  setSamStatus('Loaded '+nm+' ('+buf.duration.toFixed(2)+'s)');
  document.getElementById('sam_save').disabled=false;
}
function initSamplerBus(){
  if(!audioCtx) return;
  try{ if(samplerBus.out && samplerBus.out.context !== audioCtx) samplerBus={out:null,filter:null}; }catch{}
  if(samplerBus.out) return;
  const out=audioCtx.createGain(); out.gain.value=parseFloat(document.getElementById('sam_gain').value||'0.9');
  const filter=audioCtx.createBiquadFilter(); filter.type='lowpass'; filter.frequency.value=parseFloat(document.getElementById('sam_cut').value||'10000'); filter.Q.value=parseFloat(document.getElementById('sam_q').value||'0')*20;
  out.connect(filter).connect(mixNode);
  samplerBus={out,filter};
}
function setSamStatus(t){ const el=document.getElementById('sam_status'); if(el) el.textContent=t||''; }
function bindSamplerPanel(){
  const panel=document.getElementById('samplerPanel');
  const toggle=document.getElementById('samplerToggle');
  toggle.onclick=()=>{ const open=panel.classList.toggle('open'); toggle.setAttribute('aria-expanded',open?'true':'false'); if(open){ ensureAudio().then(initSamplerBus); } };
  loadSamplerLib(); refreshSamplerList();
  const list=document.getElementById('sam_list');
  list.onchange=()=>{ const nm=list.value; if(nm){ samplerLoadByName(nm); } refreshSamplerList(nm); };
  document.getElementById('sam_fromGranular').onclick=async()=>{
    if(!currentTakeBuffer){ setSamStatus('No granular take'); return; } await ensureAudio(); initSamplerBus();
    samplerCurrent={ name:'Granular '+new Date().toLocaleTimeString(), buffer:currentTakeBuffer, root:parseInt(document.getElementById('sam_root').value||'60')|0 };
    document.getElementById('sam_name').value=samplerCurrent.name; document.getElementById('sam_save').disabled=false; setSamStatus('Loaded from granular');
  };
  document.getElementById('sam_import').onclick=()=>document.getElementById('sam_file').click();
  document.getElementById('sam_file').onchange=async(e)=>{
    const f=e.target.files?.[0]; if(!f) return;
    const arr=await f.arrayBuffer(); await ensureAudio(); initSamplerBus();
    const ab=await audioCtx.decodeAudioData(arr.slice(0));
    samplerCurrent={ name:f.name.replace(/\.[^/.]+$/,''), buffer:ab, root:parseInt(document.getElementById('sam_root').value||'60')|0 };
    document.getElementById('sam_name').value=samplerCurrent.name; document.getElementById('sam_save').disabled=false;
    refreshSamplerList(); setSamStatus('Imported '+samplerCurrent.name); e.target.value='';
  };
  document.getElementById('sam_save').onclick=()=>{
    if(!samplerCurrent.buffer) return; const nm=(document.getElementById('sam_name').value||'Sample').trim(); const root=parseInt(document.getElementById('sam_root').value||'60')|0;
    const wav=encodeWAVFromBuffer(samplerCurrent.buffer); const b64=u8ToB64(new Uint8Array(wav));
    samplerLib[nm]={ wavB64:b64, sampleRate:samplerCurrent.buffer.sampleRate, root }; saveSamplerLib(); refreshSamplerList(nm); setSamStatus('Saved "'+nm+'"');
  };
  document.getElementById('sam_delete').onclick=()=>{ const nm=list.value; if(!nm) return; delete samplerLib[nm]; saveSamplerLib(); refreshSamplerList(); setSamStatus('Deleted '+nm); };
  document.getElementById('sam_export').onclick=()=>{
    const nm=list.value; const rec=samplerLib[nm]; if(!rec) return;
    const bin=atob(rec.wavB64); const u8=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) u8[i]=bin.charCodeAt(i);
    const blob=new Blob([u8.buffer],{type:'audio/wav'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=(nm||'sample')+'.wav'; a.click(); setTimeout(()=>URL.revokeObjectURL(url),1000);
  };
  ['sam_gain','sam_cut','sam_q'].forEach(id=> document.getElementById(id)?.addEventListener('input', ()=>{
    if(!audioCtx) return; initSamplerBus();
    if(id==='sam_gain') samplerBus.out.gain.value=parseFloat(document.getElementById('sam_gain').value||'0.9');
    if(id==='sam_cut')  samplerBus.filter.frequency.value=Math.max(60,parseFloat(document.getElementById('sam_cut').value||'10000'));
    if(id==='sam_q')    samplerBus.filter.Q.value=Math.max(0,Math.min(20,parseFloat(document.getElementById('sam_q').value||'0')*20));
  }));
}
function samplerEnv(){ const clamp01=x=>Math.max(0,Math.min(1,x)); return { a:Math.max(.001,parseFloat(document.getElementById('sam_a').value||'0.005')), d:Math.max(.001,parseFloat(document.getElementById('sam_d').value||'0.08')), s:clamp01(parseFloat(document.getElementById('sam_s').value||'0.8')), r:Math.max(.001,parseFloat(document.getElementById('sam_r').value||'0.2')) }; }
function samplerMode(){ const sel=document.getElementById('sam_mode'); return sel? sel.value : 'off'; }
function samplerNoteOn(m,vel=0.9){
  if(!samplerCurrent.buffer || samplerMode()==='off') return; initSamplerBus();
  const buf=samplerCurrent.buffer; const root=parseInt(document.getElementById('sam_root').value||String(samplerCurrent.root||60))|0;
  const cents=parseFloat(document.getElementById('sam_tune').value||'0')||0; const semi=(m-root)+(cents/100);
  const rate=Math.pow(2,semi/12);
  const startPct=Math.max(0,Math.min(.99,parseFloat(document.getElementById('sam_start').value||'0')/100));
  const endPct=Math.max(startPct+.005,Math.min(1,parseFloat(document.getElementById('sam_end').value||'100')/100));
  const start=startPct*buf.duration; const dur=Math.max(.01,(endPct-startPct)*buf.duration);
  const src=audioCtx.createBufferSource(); src.buffer=buf; src.playbackRate.value=rate; src.loop=!!document.getElementById('sam_loop').checked; if(src.loop){ src.loopStart=start; src.loopEnd=start+dur; }
  const g=audioCtx.createGain(); g.gain.value=1e-5;
  const e=samplerEnv(); const t=audioCtx.currentTime; const peak=.8*vel*parseFloat(document.getElementById('sam_gain').value||'0.9');
  g.gain.setValueAtTime(1e-5,t); g.gain.linearRampToValueAtTime(peak,t+e.a); g.gain.linearRampToValueAtTime(peak*e.s,t+e.a+e.d);
  src.connect(g).connect(samplerBus.out);
  const key=Math.round(m*2)/2; samplerVoices.set(key,{src,g,e});
  try{ src.start(t,start,dur); }catch{}
}
function samplerNoteOff(m){
  const key=Math.round(m*2)/2; const v=samplerVoices.get(key); if(!v) return;
  const t=audioCtx.currentTime; const stopAt=t+v.e.r+.02;
  v.g.gain.cancelScheduledValues(t); v.g.gain.setValueAtTime(v.g.gain.value,t); v.g.gain.linearRampToValueAtTime(1e-5,stopAt);
  try{ v.src.stop(stopAt+.01); }catch{} setTimeout(()=>samplerVoices.delete(key),Math.max(10,(stopAt-audioCtx.currentTime)*1000));
}
function killSamplerAll(){ for(const [k,v] of samplerVoices.entries()){ try{ v.src.stop(0); }catch{} } samplerVoices.clear(); }

/* ===== Routing ===== */
function routeNoteOn(m,amp){ ensureAudio().then(()=>{ const mode=samplerMode(); if(mode==='sampler'||mode==='both') samplerNoteOn(m,amp); if(mode!=='sampler') synth?.noteOn(m,amp); }); }
function routeNoteOff(m){ try{ const mode=samplerMode(); if(mode==='sampler'||mode==='both') samplerNoteOff(m); if(mode!=='sampler') synth?.noteOff(m); }catch{} }

/* ===== Header & main ===== */
function measureTopbar(){
  const tb=document.getElementById('topbar');
  const h=tb ? tb.getBoundingClientRect().height : 60;
  document.documentElement.style.setProperty('--tb', Math.round(h)+'px');
}
function bindHeader(){
  measureTopbar();
  window.addEventListener('resize', measureTopbar);
  document.getElementById('startBtn').onclick=()=>ensureAudio();
  document.getElementById('resetBtn').onclick=()=>hardResetAudio();
  document.getElementById('midiBtn').onclick=()=>ensureAudio().then(connectMIDI);
  const st=document.getElementById('synthToggle'), sp=document.getElementById('synthPanel'); st.onclick=()=>{ const o=sp.classList.toggle('open'); st.setAttribute('aria-expanded',o?'true':'false'); };
  const gt=document.getElementById('granularToggle'), gp=document.getElementById('granularPanel'); gt.onclick=()=>{ const o=gp.classList.toggle('open'); gt.setAttribute('aria-expanded',o?'true':'false'); };
  const sat=document.getElementById('samplerToggle'), sap=document.getElementById('samplerPanel'); sat.onclick=()=>{ const o=sap.classList.toggle('open'); sat.setAttribute('aria-expanded',o?'true':'false'); if(o){ ensureAudio().then(initSamplerBus);} };
  const rec=document.getElementById('recBtn'); rec.onclick=()=>{ ensureAudio().then(()=>{ if(!mediaRecorder||mediaRecorder.state!=='recording') startTopRecording(); else stopTopRecording(); }); };

  const ml=document.getElementById('midiLearnBtn');
  ml.onclick=()=>{ if(ml.disabled) return; midiLearn=!midiLearn; learnTarget=null; if(midiLearn) ml.classList.add('midi-learn-on'); else ml.classList.remove('midi-learn-on'); document.getElementById('midiState').textContent = midiLearn ? 'Click a control, then move a CC' : 'MIDI map off'; };
}
function bindMain(){
  const rd=document.getElementById('octReadout');
  document.getElementById('octUp').onclick=()=>{ octaveOffset=clamp(octaveOffset+1,-2,2); rd.textContent=String(octaveOffset); buildKeypad(); };
  document.getElementById('octDown').onclick=()=>{ octaveOffset=clamp(octaveOffset-1,-2,2); rd.textContent=String(octaveOffset); buildKeypad(); };
  buildKeypad(); bindKeyboard(); bindBendAndMicro();
  [
   'shape','subShape','detune','subDetune','mode','cutoff','resonance','a','d','s','r','drive','mix','subLevel','subOctave','noiseColor',
   'fx_rev_room','fx_rev_decay','fx_rev_predelay','fx_rev_damp','fx_rev_mix',
   'fx_ch_rate','fx_ch_depth','fx_ch_voices','fx_ch_width','fx_ch_mix',
   'fx_dist_type','fx_dist_drive','fx_dist_tone','fx_dist_mix',
   'fx_comp_thr','fx_comp_ratio','fx_comp_att','fx_comp_rel','fx_comp_makeup',
   'fx_bc_bits','fx_bc_rate','fx_bc_mix',
   'fx_rm_freq','fx_rm_wave','fx_rm_depth','fx_rm_mix'
  ].forEach(id=> document.getElementById(id)?.addEventListener('input',pushParams));
  attachLearnClicks();
}
function main(){ loadPresetStore(); loadTakes(); bindHeader(); bindMain(); initPresets(); bindGranularPanel(); bindSamplerPanel(); loadMidiMap(); }
document.addEventListener('DOMContentLoaded', main);

/* ==== Low Latency Mode (robust toggle, desktop + mobile) ==== */
(() => {
  if (window.__LL_FINAL_PATCH__) return; window.__LL_FINAL_PATCH__ = true;

  let LOW_LATENCY = false;
  let _lastToggleAt = 0;

  function reflectButton(on){
    const el = document.getElementById('llToggleOverlay');
    if(!el) return;
    el.classList.toggle('ll-on', on);
    el.setAttribute('aria-pressed', on ? 'true' : 'false');
    el.setAttribute('aria-checked', on ? 'true' : 'false');
  }

  function applyLowLatencyTweaks(on){
    LOW_LATENCY = !!on;
    reflectButton(LOW_LATENCY);

    try{ if (typeof ai!=='undefined' && ai && ai.tap) ai.tap.fftSize = on ? 512 : 2048; }catch{}
    try{ if (window.rec && window.rec.dest && !window.rec.active){ try{ window.rec.dest.disconnect(); }catch{} } }catch{}
    try{
      if (window.comp){
        window._compAttackDefault = window._compAttackDefault ?? comp.attack;
        window._compReleaseDefault = window._compReleaseDefault ?? comp.release;
        comp.attack = on ? 0.001 : window._compAttackDefault;
        comp.release = on ? 0.06  : window._compReleaseDefault;
      }
    }catch{}
    try{
      const chRate=document.getElementById('fx_ch_rate');
      const chDepth=document.getElementById('fx_ch_depth');
      if(on){
        if(chDepth){ const v=Math.min(parseFloat(chDepth.value)||6,6); if(v!=parseFloat(chDepth.value||0)){ chDepth.value=String(v); chDepth.dispatchEvent(new Event('input',{bubbles:true})); } }
        if(chRate){ const v=Math.min(parseFloat(chRate.value)||2,2); if(v!=parseFloat(chRate.value||0)){ chRate.value=String(v); chRate.dispatchEvent(new Event('input',{bubbles:true})); } }
      }
    }catch{}
    try{ window._bcLazy = on; }catch{}

    if (window.DEBUG_LL) console.log('[LL] state =', LOW_LATENCY);
  }

  function bindLL(){
    const btn = document.getElementById('llToggleOverlay');
    if(!btn) return;
    const onPointerUp = (e) => {
      const now = performance.now();
      if (now - _lastToggleAt < 150) return; // debounce
      _lastToggleAt = now;
      e.preventDefault();
      e.stopPropagation();
      applyLowLatencyTweaks(!LOW_LATENCY);
    };
    const clone = btn.cloneNode(true);
    btn.parentNode.replaceChild(clone, btn);
    clone.addEventListener('pointerup', onPointerUp, {passive:false, capture:true});
    clone.addEventListener('click', onPointerUp, {passive:false, capture:true});
    clone.addEventListener('keydown', (ev)=>{ ev.stopPropagation(); }, {capture:true});
  }

  const _ensure = window.ensureAudio;
  if(typeof _ensure === 'function'){
    window.ensureAudio = function(){
      return _ensure().then(()=>{ bindLL(); });
    }
  }

  document.addEventListener('DOMContentLoaded', bindLL, {once:true});
  window.toggleLL = (on)=> applyLowLatencyTweaks(on==null ? !LOW_LATENCY : !!on);
})();
</script>


<script>
(function(){
  let vocCtx={ inited:false, bands:[], modStream:null, modSrc:null, modPre:null, sibHP:null, sibGain:null, envLPs:[], carBPFs:[], modBPFs:[], vcaGains:[], wet:null, dry:null, out:null, sum:null, carIn:null, modGate:null, modGain:null, carrierSel:'off' };
  function hzForBand(i,N,lo,hi,semi){ const f=lo*Math.pow(hi/lo,i/(N-1)); return f*Math.pow(2,(semi||0)/12); }

  async function ensureMic(){ if(vocCtx.modSrc) return true; try{ const ms=await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:false,noiseSuppression:false,autoGainControl:false},video:false}); vocCtx.modStream=ms; await ensureAudio(); const a=audioCtx; vocCtx.modSrc=a.createMediaStreamSource(ms); vocCtx.modGain=a.createGain(); vocCtx.modGain.gain.value=parseFloat(document.getElementById('voc_mod_gain').value||1); vocCtx.modPre=a.createBiquadFilter(); vocCtx.modPre.type='highpass'; vocCtx.modPre.frequency.value=90; vocCtx.modGate=a.createDynamicsCompressor(); vocCtx.modGate.threshold.value=parseFloat(document.getElementById('voc_gate').value||-70); vocCtx.modGate.ratio.value=20; vocCtx.modGate.knee.value=0; vocCtx.modGate.attack.value=0.005; vocCtx.modGate.release.value=0.25; vocCtx.modSrc.connect(vocCtx.modGain).connect(vocCtx.modPre).connect(vocCtx.modGate); return true; }catch(e){ const s=document.getElementById('voc_status'); if(s) s.textContent='Mic permission denied'; return false; } }

  function destroyBands(){ vocCtx.bands.forEach(b=>{ try{ b.modBPF.disconnect(); b.carBPF.disconnect(); b.envRect?.disconnect(); b.envLP.disconnect(); b.vca.disconnect(); }catch{} }); vocCtx.bands=[]; try{ vocCtx.sum?.disconnect(); }catch{} }

  function rebuildVocoder(){ if(!window.audioCtx) return; const a=audioCtx; destroyBands(); if(!vocCtx.wet){ vocCtx.wet=a.createGain(); } if(!vocCtx.dry){ vocCtx.dry=a.createGain(); } if(!vocCtx.out){ vocCtx.out=a.createGain(); } if(!vocCtx.sum){ vocCtx.sum=a.createGain(); vocCtx.sum.gain.value=1; }
    const N=parseInt(document.getElementById('voc_bands').value||12,10), lo=parseFloat(document.getElementById('voc_lo').value||200), hi=parseFloat(document.getElementById('voc_hi').value||5000), Q=parseFloat(document.getElementById('voc_q').value||2.0), sh=parseFloat(document.getElementById('voc_shift').value||0), att=Math.max(0.0005,(parseFloat(document.getElementById('voc_att').value||12))/1000), rel=Math.max(0.005,(parseFloat(document.getElementById('voc_rel').value||160))/1000);
    vocCtx.wet.gain.value=parseFloat(document.getElementById('voc_mix').value||0); vocCtx.dry.gain.value=1-vocCtx.wet.gain.value; vocCtx.out.gain.value=parseFloat(document.getElementById('voc_out').value||1);
    if(!vocCtx.sibHP){ vocCtx.sibHP=a.createBiquadFilter(); vocCtx.sibHP.type='highpass'; vocCtx.sibHP.frequency.value=5000; } if(!vocCtx.sibGain){ vocCtx.sibGain=a.createGain(); } vocCtx.sibGain.gain.value=parseFloat(document.getElementById('voc_sib').value||0.15);
    for(let i=0;i<N;i++){ const fc=hzForBand(i,N,lo,hi,sh); const modBPF=a.createBiquadFilter(); modBPF.type='bandpass'; modBPF.Q.value=Q; modBPF.frequency.value=fc; const carBPF=a.createBiquadFilter(); carBPF.type='bandpass'; carBPF.Q.value=Q; carBPF.frequency.value=fc; const rect=a.createWaveShaper(); const n=2048,curve=new Float32Array(n); for(let j=0;j<n;j++){ const x=j/(n-1)*2-1; curve[j]=Math.abs(x);} rect.curve=curve; rect.oversample='2x'; const envLP=a.createBiquadFilter(); envLP.type='lowpass'; envLP.frequency.value=1/(2*Math.PI*att)*0.25; const vca=a.createGain(); vca.gain.value=0; vocCtx.modGate.connect(modBPF).connect(rect).connect(envLP); envLP.connect(vca.gain); vocCtx.carIn.connect(carBPF).connect(vca).connect(vocCtx.sum); vocCtx.bands.push({modBPF,carBPF,envRect:rect,envLP,vca}); }
    vocCtx.modGate.connect(vocCtx.sibHP).connect(vocCtx.sibGain).connect(vocCtx.sum);
    try{ vocCtx.wet.disconnect(); vocCtx.dry.disconnect(); vocCtx.out.disconnect(); }catch{}
    vocCtx.sum.connect(vocCtx.wet).connect(vocCtx.out).connect(mixNode);
  }

  function waitForSynthBusAndWire(maxMs=4000){
    const t0=performance.now();
    (function tick(){
      const bus=window._stagsynth_synthBus;
      if(bus && vocCtx?.carIn){ try{ vocCtx.carIn.disconnect(); }catch{} bus.connect(vocCtx.carIn); console.log('[voc] carrier wired to synthBus'); return; }
      if(performance.now()-t0<maxMs) requestAnimationFrame(tick);
    })();
  }

  function setCarrier(sel){
    vocCtx.carrierSel=sel; if(!window.audioCtx) return;
    if(!vocCtx.carIn){ vocCtx.carIn=audioCtx.createGain(); vocCtx.carIn.gain.value=1; }
    try{ vocCtx.carIn.disconnect(); }catch{}
    const synthBus=window._stagsynth_synthBus;
    const samOut=(typeof samplerBus==='object' && samplerBus.out) ? samplerBus.out : null;
    if(sel==='synth'){ if(synthBus) synthBus.connect(vocCtx.carIn); else waitForSynthBusAndWire(); }
    else if(sel==='sampler'){ if(samOut) samOut.connect(vocCtx.carIn); }
    else if(sel==='both'){ if(synthBus) synthBus.connect(vocCtx.carIn); else waitForSynthBusAndWire(); if(samOut) samOut.connect(vocCtx.carIn); }
  }

  async function enableVocoderIfNeeded(){
    const sel=document.getElementById('voc_carrier').value;
    const needOn=(sel!=='off'); if(!needOn) return;
    await ensureAudio(); const ok=await ensureMic(); if(!ok) return;
    if(!vocCtx.inited){ vocCtx.inited=true; }
    setCarrier(sel); rebuildVocoder();
    const s=document.getElementById('voc_status'); if(s) s.textContent='Vocoder ready';
  }

  // Bind UI
  document.addEventListener('DOMContentLoaded',()=>{
    const btn=document.getElementById('vocoderToggle');
    const panel=document.getElementById('vocoderPanel');
    if(btn && panel){
      btn.onclick=()=>{ const o=panel.classList.toggle('open'); btn.setAttribute('aria-expanded', o?'true':'false'); if(o) enableVocoderIfNeeded(); };
    }
    const id=s=>document.getElementById(s);
    id('voc_carrier')?.addEventListener('change', async ()=>{ await enableVocoderIfNeeded(); setCarrier(vocCtx.carrierSel); });
    ['voc_bands','voc_lo','voc_hi','voc_q','voc_shift','voc_att','voc_rel','voc_sib'].forEach(k=> id(k)?.addEventListener('input', ()=>{ if(vocCtx.carrierSel!=='off'){ rebuildVocoder(); }}));
    id('voc_mix')?.addEventListener('input', ()=>{ const mix=parseFloat(id('voc_mix').value||0); if(vocCtx.wet) vocCtx.wet.gain.value=mix; if(vocCtx.dry) vocCtx.dry.gain.value=1-mix; });
    id('voc_out')?.addEventListener('input', ()=>{ if(vocCtx.out) vocCtx.out.gain.value=parseFloat(id('voc_out').value||1); });
    id('voc_mod_gain')?.addEventListener('input', ()=>{ if(vocCtx.modGain) vocCtx.modGain.gain.value=parseFloat(id('voc_mod_gain').value||1); });
    id('voc_gate')?.addEventListener('input', ()=>{ if(vocCtx.modGate) vocCtx.modGate.threshold.value=parseFloat(id('voc_gate').value||-70); });
    id('voc_att')?.addEventListener('input', ()=>{ if(vocCtx.carrierSel!=='off') rebuildVocoder(); });
    id('voc_rel')?.addEventListener('input', ()=>{ if(vocCtx.carrierSel!=='off') rebuildVocoder(); });
    id('voc_test')?.addEventListener('click', async ()=>{ const ok=await ensureMic(); const s=id('voc_status'); if(s) s.textContent= ok ? 'Mic OK' : 'Mic blocked'; });
  });
})();
</script>



<!-- Vocoder engine -->
<script>
(function(){
  let vocCtx={ inited:false, bands:[], modStream:null, modSrc:null, modPre:null, sibHP:null, sibGain:null, envLPs:[], carBPFs:[], modBPFs:[], vcaGains:[], wet:null, dry:null, out:null, sum:null, carIn:null, modGate:null, modGain:null, carrierSel:'off' };
  function hzForBand(i,N,lo,hi,semi){ const f=lo*Math.pow(hi/lo,i/(N-1)); return f*Math.pow(2,(semi||0)/12); }

  async function ensureMic(){
    if(vocCtx.modSrc) return true;
    try{
      const ms=await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:false,noiseSuppression:false,autoGainControl:false},video:false});
      vocCtx.modStream=ms;
      await ensureAudio();
      const a=audioCtx;
      vocCtx.modSrc=a.createMediaStreamSource(ms);
      vocCtx.modGain=a.createGain(); vocCtx.modGain.gain.value=parseFloat(document.getElementById('voc_mod_gain').value||1);
      vocCtx.modPre=a.createBiquadFilter(); vocCtx.modPre.type='highpass'; vocCtx.modPre.frequency.value=90;
      vocCtx.modGate=a.createDynamicsCompressor();
      vocCtx.modGate.threshold.value=parseFloat(document.getElementById('voc_gate').value||-70);
      vocCtx.modGate.ratio.value=20; vocCtx.modGate.knee.value=0; vocCtx.modGate.attack.value=0.005; vocCtx.modGate.release.value=0.25;
      vocCtx.modSrc.connect(vocCtx.modGain).connect(vocCtx.modPre).connect(vocCtx.modGate);
      return true;
    }catch(e){
      const s=document.getElementById('voc_status'); if(s) s.textContent='Mic permission denied';
      return false;
    }
  }

  function destroyBands(){
    vocCtx.bands.forEach(b=>{ try{ b.modBPF.disconnect(); b.carBPF.disconnect(); b.envRect?.disconnect(); b.envLP.disconnect(); b.vca.disconnect(); }catch{} });
    vocCtx.bands=[]; try{ vocCtx.sum?.disconnect(); }catch{}
  }

  function rebuildVocoder(){
    if(!window.audioCtx) return;
    const a=audioCtx;
    destroyBands();
    if(!vocCtx.wet){ vocCtx.wet=a.createGain(); }
    if(!vocCtx.dry){ vocCtx.dry=a.createGain(); }
    if(!vocCtx.out){ vocCtx.out=a.createGain(); }
    if(!vocCtx.sum){ vocCtx.sum=a.createGain(); vocCtx.sum.gain.value=1; }

    const N=parseInt(document.getElementById('voc_bands').value||12,10),
          lo=parseFloat(document.getElementById('voc_lo').value||200),
          hi=parseFloat(document.getElementById('voc_hi').value||5000),
          Q=parseFloat(document.getElementById('voc_q').value||2.0),
          sh=parseFloat(document.getElementById('voc_shift').value||0),
          att=Math.max(0.0005,(parseFloat(document.getElementById('voc_att').value||12))/1000),
          rel=Math.max(0.005,(parseFloat(document.getElementById('voc_rel').value||160))/1000);

    vocCtx.wet.gain.value=parseFloat(document.getElementById('voc_mix').value||0);
    vocCtx.dry.gain.value=1-vocCtx.wet.gain.value;
    vocCtx.out.gain.value=parseFloat(document.getElementById('voc_out').value||1);

    if(!vocCtx.sibHP){ vocCtx.sibHP=a.createBiquadFilter(); vocCtx.sibHP.type='highpass'; vocCtx.sibHP.frequency.value=5000; }
    if(!vocCtx.sibGain){ vocCtx.sibGain=a.createGain(); }
    vocCtx.sibGain.gain.value=parseFloat(document.getElementById('voc_sib').value||0.15);

    for(let i=0;i<N;i++){
      const fc=hzForBand(i,N,lo,hi,sh);
      const modBPF=a.createBiquadFilter(); modBPF.type='bandpass'; modBPF.Q.value=Q; modBPF.frequency.value=fc;
      const carBPF=a.createBiquadFilter(); carBPF.type='bandpass'; carBPF.Q.value=Q; carBPF.frequency.value=fc;
      const rect=a.createWaveShaper(); const n=2048,curve=new Float32Array(n); for(let j=0;j<n;j++){ const x=j/(n-1)*2-1; curve[j]=Math.abs(x);} rect.curve=curve; rect.oversample='2x';
      const envLP=a.createBiquadFilter(); envLP.type='lowpass'; envLP.frequency.value=1/(2*Math.PI*att)*0.25;
      const vca=a.createGain(); vca.gain.value=0;
      vocCtx.modGate.connect(modBPF).connect(rect).connect(envLP);
      envLP.connect(vca.gain);
      vocCtx.carIn.connect(carBPF).connect(vca).connect(vocCtx.sum);
      vocCtx.bands.push({modBPF,carBPF,envRect:rect,envLP,vca});
    }
    vocCtx.modGate.connect(vocCtx.sibHP).connect(vocCtx.sibGain).connect(vocCtx.sum);

    try{ vocCtx.wet.disconnect(); vocCtx.dry.disconnect(); vocCtx.out.disconnect(); }catch{}
    vocCtx.sum.connect(vocCtx.wet).connect(vocCtx.out).connect(mixNode);
  }

  function waitForSynthBusAndWire(maxMs=4000){
    const t0=performance.now();
    (function tick(){
      const bus=window._stagsynth_synthBus;
      if(bus && vocCtx?.carIn){
        try{ vocCtx.carIn.disconnect(); }catch{}
        bus.connect(vocCtx.carIn);
        console.log('[voc] carrier wired to synthBus');
        return;
      }
      if(performance.now()-t0<maxMs) requestAnimationFrame(tick);
    })();
  }

  function setCarrier(sel){
    vocCtx.carrierSel=sel; if(!window.audioCtx) return;
    if(!vocCtx.carIn){ vocCtx.carIn=audioCtx.createGain(); vocCtx.carIn.gain.value=1; }
    try{ vocCtx.carIn.disconnect(); }catch{}
    const synthBus=window._stagsynth_synthBus;
    const samOut=(typeof samplerBus==='object' && samplerBus.out) ? samplerBus.out : null;
    if(sel==='synth'){ if(synthBus) synthBus.connect(vocCtx.carIn); else waitForSynthBusAndWire(); }
    else if(sel==='sampler'){ if(samOut) samOut.connect(vocCtx.carIn); }
    else if(sel==='both'){ if(synthBus) synthBus.connect(vocCtx.carIn); else waitForSynthBusAndWire(); if(samOut) samOut.connect(vocCtx.carIn); }
  }

  async function enableVocoderIfNeeded(){
    const sel=document.getElementById('voc_carrier').value;
    const needOn=(sel!=='off'); if(!needOn) return;
    await ensureAudio(); const ok=await ensureMic(); if(!ok) return;
    if(!vocCtx.inited){ vocCtx.inited=true; }
    setCarrier(sel);
    rebuildVocoder();
    const s=document.getElementById('voc_status'); if(s) s.textContent='Vocoder ready';
  }

  // Bind UI
  document.addEventListener('DOMContentLoaded',()=>{
    const btn=document.getElementById('vocoderToggle');
    const panel=document.getElementById('vocoderPanel');
    if(btn && panel){
      btn.onclick=()=>{ const o=panel.classList.toggle('open'); btn.setAttribute('aria-expanded', o?'true':'false'); if(o) enableVocoderIfNeeded(); };
    }
    const id=s=>document.getElementById(s);
    id('voc_carrier')?.addEventListener('change', async ()=>{ await enableVocoderIfNeeded(); setCarrier(vocCtx.carrierSel); });
    ['voc_bands','voc_lo','voc_hi','voc_q','voc_shift','voc_att','voc_rel','voc_sib'].forEach(k=> id(k)?.addEventListener('input', ()=>{ if(vocCtx.carrierSel!=='off'){ rebuildVocoder(); }}));
    id('voc_mix')?.addEventListener('input', ()=>{ const mix=parseFloat(id('voc_mix').value||0); if(vocCtx.wet) vocCtx.wet.gain.value=mix; if(vocCtx.dry) vocCtx.dry.gain.value=1-mix; });
    id('voc_out')?.addEventListener('input', ()=>{ if(vocCtx.out) vocCtx.out.gain.value=parseFloat(id('voc_out').value||1); });
    id('voc_mod_gain')?.addEventListener('input', ()=>{ if(vocCtx.modGain) vocCtx.modGain.gain.value=parseFloat(id('voc_mod_gain').value||1); });
    id('voc_gate')?.addEventListener('input', ()=>{ if(vocCtx.modGate) vocCtx.modGate.threshold.value=parseFloat(id('voc_gate').value||-70); });
    id('voc_att')?.addEventListener('input', ()=>{ if(vocCtx.carrierSel!=='off') rebuildVocoder(); });
    id('voc_rel')?.addEventListener('input', ()=>{ if(vocCtx.carrierSel!=='off') rebuildVocoder(); });
    id('voc_test')?.addEventListener('click', async ()=>{ const ok=await ensureMic(); const s=id('voc_status'); if(s) s.textContent= ok ? 'Mic OK' : 'Mic blocked'; });
  });
})();
</script>
<script>
document.addEventListener('DOMContentLoaded',()=>{
  if(window.audioCtx && audioCtx.audioWorklet){
    const aw=audioCtx.audioWorklet;
    const orig=aw.addModule.bind(aw);
    aw.addModule=async function(url, opts){
      try{ return await orig(url, opts); }
      catch(e){ if(String(e).includes('already registered')){ console.warn('[worklet] duplicate register ignored:', url); return; } throw e; }
    };
  }
});
</script>

<script>
/* ---- Safe pointer-capture: swallow NotFoundError without changing your handlers ---- */
(function(){
  if (!Element.prototype._setPointerCapturePatched) {
    const _orig = Element.prototype.setPointerCapture;
    if (_orig) {
      Element.prototype.setPointerCapture = function(pointerId){
        try { return _orig.call(this, pointerId); }
        catch (e) {
          // Ignore "No active pointer" race (common when mixed mouse/touch/pointer listeners run)
          if (e && (e.name === 'NotFoundError' || String(e).includes('No active pointer'))) return;
          throw e;
        }
      };
    }
    Element.prototype._setPointerCapturePatched = true;
  }
})();
</script>

<script>
/* ========= Vocoder v2 (add-only) ‚Äî uses your existing UI, zero changes elsewhere ========= */
(function(){
  if (window.__VocoderV2Mounted) return; window.__VocoderV2Mounted = true;
  const $ = (id)=>document.getElementById(id);

  let ctx=null, wet=null, out=null, noiseGain=null, noiseGen=null;
  let bands=[], modHP=null, micStream=null, micSrc=null;

  // Tuned defaults (you can keep using your UI to tweak)
  const cfg = { nb:16, lo:160, hi:6000, attMs:12, relMs:120, envGain:3.0, noise:0.0, wet:0.6, out:1.0 };

  // Wait for your audio engine (no changes to your code)
  async function boot(){
    if (!window.ensureAudio) return;
    await ensureAudio();
    ctx = window.audioCtx;
    if (!ctx || !window.mixNode) return;

    if (ctx.state === 'suspended') { try { await ctx.resume(); } catch{} }

    if (!wet) {
      // Outputs
      wet = ctx.createGain();   wet.gain.value = parseFloat($('#voc_wet')?.value ?? cfg.wet);
      out = ctx.createGain();   out.gain.value = parseFloat($('#voc_out')?.value ?? cfg.out);
      noiseGain = ctx.createGain(); noiseGain.gain.value = parseFloat($('#voc_noise')?.value ?? cfg.noise);

      // Light noise to recover sibilants
      noiseGen = ctx.createBufferSource();
      const nbuf = ctx.createBuffer(1, ctx.sampleRate*2, ctx.sampleRate);
      const d = nbuf.getChannelData(0); for (let i=0;i<d.length;i++) d[i] = Math.random()*2-1;
      noiseGen.buffer = nbuf; noiseGen.loop = true; try{ noiseGen.start(); }catch{}
      noiseGen.connect(noiseGain);

      // Sum ‚Üí your master bus
      wet.connect(out);
      noiseGain.connect(out);
      out.connect(window.mixNode);

      // Build and wire
      readCfg(); rebuildBands(); connectRouting();
    }
  }

  function readCfg(){
    cfg.nb     = parseInt($('#voc_bands')?.value ?? cfg.nb, 10) || cfg.nb;
    cfg.lo     = Math.max(40, parseFloat($('#voc_lo')?.value ?? cfg.lo));
    cfg.hi     = Math.max(cfg.lo+200, parseFloat($('#voc_hi')?.value ?? cfg.hi));
    cfg.attMs  = parseFloat($('#voc_att')?.value ?? cfg.attMs);
    cfg.relMs  = parseFloat($('#voc_rel')?.value ?? cfg.relMs);
    // Keep envGain internal; we bias it so the bands actually open
  }

  function destroyBands(){
    bands.forEach(b=>{
      try{ b.modBP.disconnect(); b.rect.disconnect(); b.envLP.disconnect(); b.envGain.disconnect(); b.carBP.disconnect(); b.mul.disconnect(); }catch{}
    });
    bands.length = 0;
  }

  function hz(i,n,lo,hi){ const t = n<=1 ? 0 : i/(n-1); return Math.exp(Math.log(lo) + t*(Math.log(hi)-Math.log(lo))); }

  function rebuildBands(){
    if (!ctx) return;
    destroyBands();

    for(let i=0;i<cfg.nb;i++){
      const f = hz(i, cfg.nb, cfg.lo, cfg.hi);

      // Modulator path: bandpass -> rectify -> lowpass (envelope) -> envGain (crucial!)
      const modBP = ctx.createBiquadFilter(); modBP.type='bandpass'; modBP.frequency.value=f; modBP.Q.value=8;

      const rect = ctx.createWaveShaper();
      const curve = new Float32Array(65536);
      for (let j=0;j<curve.length;j++){ const x=j/32768-1; curve[j]=Math.abs(x); }
      rect.curve = curve;

      const envLP = ctx.createBiquadFilter(); envLP.type='lowpass';
      // Low cutoff gives a smooth envelope; attack/release are applied via coefficient math below
      envLP.frequency.value = 60;

      const envGain = ctx.createGain(); envGain.gain.value = cfg.envGain; // <-- boosts envelope amplitude

      // Carrier path: bandpass
      const carBP = ctx.createBiquadFilter(); carBP.type='bandpass'; carBP.frequency.value=f; carBP.Q.value=8;

      // Multiply (envelope controls car band gain)
      const mul = ctx.createGain(); mul.gain.value = 0;

      // Wire per-band
      modBP.connect(rect).connect(envLP).connect(envGain).connect(mul.gain);
      carBP.connect(mul);
      mul.connect(wet);

      bands.push({modBP, rect, envLP, envGain, carBP, mul});
    }
  }

  async function setMic(on){
    const badge = $('#voc_micStatus');
    if (on){
      try{
        const stream = await navigator.mediaDevices.getUserMedia({
          audio:{ echoCancellation:false, noiseSuppression:false, autoGainControl:false }
        });
        micStream = stream; micSrc = ctx.createMediaStreamSource(stream);
        modHP = ctx.createBiquadFilter(); modHP.type='highpass'; modHP.frequency.value = 120;
        micSrc.connect(modHP);
        if (badge) badge.textContent = 'Mic: on';
      }catch(e){
        if (badge) badge.textContent = 'Mic permission denied';
      }
    }else{
      try{ micStream?.getTracks().forEach(t=>t.stop()); }catch{}
      micStream=null; micSrc=null; modHP=null;
      if (badge) badge.textContent = 'Mic: off';
    }
  }

  function pickCarrier(){
    const choice = $('#voc_carrier')?.value || 'synth';
    // Prefer explicit sampler bus if chosen
    if (choice==='sampler' && window.samplerBus?.out) return window.samplerBus.out;

    // If your synth exposes a carrier tap, use it
    try{
      const tap = window.synth?.getVocoderCarrierTap?.();
      if (tap) return tap;
    }catch{}

    // Safe fallback: pre-limiter mix (still produces vocoder effect)
    return window.mixNode || null;
  }

  function connectRouting(){
    // Disconnect prior
    bands.forEach(b=>{ try{ b.modBP.disconnect(); }catch{} try{ b.carBP.disconnect(); }catch{} });

    // Modulator (mic) ‚Üí all mod bands
    if (modHP){ bands.forEach(b=> modHP.connect(b.modBP)); }

    // Carrier ‚Üí all carrier bands
    const car = pickCarrier();
    if (car){ bands.forEach(b=> car.connect(b.carBP)); }

    // Apply current gains
    if (wet)       wet.gain.value       = parseFloat($('#voc_wet')?.value ?? cfg.wet);
    if (out)       out.gain.value       = parseFloat($('#voc_out')?.value ?? cfg.out);
    if (noiseGain) noiseGain.gain.value = parseFloat($('#voc_noise')?.value ?? cfg.noise);

    // Optional: simple envelope ‚Äúfeel‚Äù by tweaking envLP frequency in relation to attack/release
    const att = Math.max(0.001, (parseFloat($('#voc_att')?.value ?? cfg.attMs))/1000);
    const rel = Math.max(0.005, (parseFloat($('#voc_rel')?.value ?? cfg.relMs))/1000);
    const smoothHz = Math.max(20, 1/Math.max(att, rel)); // higher cutoff = faster envelope
    bands.forEach(b=> b.envLP.frequency.value = smoothHz);
  }

  // Bind only your Vocoder controls; avoids touching other UI
  function bindUI(){
    $('#startBtn')?.addEventListener('click', boot);
    $('#resetBtn')?.addEventListener('click', ()=> setTimeout(boot,50));

    $('#voc_enableMic')?.addEventListener('change', async (e)=>{
      await boot();
      await setMic(e.target.checked);
      connectRouting();
    });
    $('#voc_carrier')?.addEventListener('change', connectRouting);
    $('#voc_wet')?.addEventListener('input',   ()=> { if (wet)  wet.gain.value  = parseFloat($('#voc_wet').value||'0'); });
    $('#voc_out')?.addEventListener('input',   ()=> { if (out)  out.gain.value  = parseFloat($('#voc_out').value||'1'); });
    $('#voc_noise')?.addEventListener('input', ()=> { if (noiseGain) noiseGain.gain.value = parseFloat($('#voc_noise').value||'0'); });

    ['voc_bands','voc_lo','voc_hi','voc_att','voc_rel'].forEach(id=>{
      $(id)?.addEventListener('input', ()=>{ readCfg(); rebuildBands(); connectRouting(); });
    });
    $('#voc_rebuild')?.addEventListener('click', ()=>{
      readCfg(); rebuildBands(); connectRouting();
      const s=$('#voc_status'); if(s){ s.textContent='Bands rebuilt'; setTimeout(()=>s.textContent='',1000); }
    });
  }

  // Install listeners immediately; the nodes are created after Start Audio
  bindUI();
})();
</script>


</body>
</html>


